/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Inject, Optional } from '@angular/core';
import { MODEL_SETTINGS_TOKEN } from '../../../form-rules/injection-tokens/model-settings.token';
import { TraceService } from '../../../utils/trace/trace.service';
import { CommonService } from '../../../utils/common/common.service';
import { forkJoin, of } from 'rxjs';
import { map, flatMap, mergeMap, take } from 'rxjs/operators';
import { TestResultsBase } from '../../../form-rules/models/test-results-base';
import { PropertyBase } from '../../../form-rules/models/property-base';
import { ProcessResultType } from '../../../form-rules/models/proccess-result-type';
import { ResultsPassRequirement } from '../../../form-rules/models/results-pass-requirement';
/**
 * Engine that digests model settings and applies their rules appropriately
 */
var RulesEngineService = /** @class */ (function () {
    function RulesEngineService(settings, traceSvc, commonSvc) {
        var _this = this;
        this.traceSvc = traceSvc;
        this.commonSvc = commonSvc;
        this.registeredSettings = {};
        if (!Array.isArray(settings))
            return;
        settings.forEach(function (setting) {
            _this.initializeModelSetting(setting);
            _this.registeredSettings[setting.name] = setting;
        });
    }
    /**
     * Initializes model settings and prepares them to be used in a form group
     * @param setting Model setting to initialize
     */
    /**
     * Initializes model settings and prepares them to be used in a form group
     * @param {?} setting Model setting to initialize
     * @return {?}
     */
    RulesEngineService.prototype.initializeModelSetting = /**
     * Initializes model settings and prepares them to be used in a form group
     * @param {?} setting Model setting to initialize
     * @return {?}
     */
    function (setting) {
        this.traceSvc.trace("Initializing model settings \"" + setting.name + "\"");
        this.setPropertyMetadata(setting.properties, setting.name);
    };
    /**
     * Gets model settings with the provided name
     * @param name Name of model setting
     * @returns Model settings with the provided name
     */
    /**
     * Gets model settings with the provided name
     * @template T
     * @param {?} name Name of model setting
     * @return {?} Model settings with the provided name
     */
    RulesEngineService.prototype.getModelSettings = /**
     * Gets model settings with the provided name
     * @template T
     * @param {?} name Name of model setting
     * @return {?} Model settings with the provided name
     */
    function (name) {
        this.traceSvc.trace("Retrieving model settings \"" + name + "\"");
        var /** @type {?} */ settings = this.registeredSettings[name];
        // create new object
        return settings
            ? Object.assign({}, this.registeredSettings[name])
            : null;
    };
    /**
     * Gets the dependency properties for an array of tests
     * @param tests Tests to get the dependency properties for
     * @returns Dependency properties
     */
    /**
     * Gets the dependency properties for an array of tests
     * @template T
     * @param {?} tests Tests to get the dependency properties for
     * @return {?} Dependency properties
     */
    RulesEngineService.prototype.getDependencyProperties = /**
     * Gets the dependency properties for an array of tests
     * @template T
     * @param {?} tests Tests to get the dependency properties for
     * @return {?} Dependency properties
     */
    function (tests) {
        var _this = this;
        if (!tests)
            return [];
        var /** @type {?} */ deps = tests
            .map(function (t) { return _this.getDependencyPropertiesFromTest(t); })
            .reduce(function (prev, current) { return prev.concat(current); }, []);
        return this.commonSvc.unique(deps);
    };
    /**
     * Gets tests grouped by their sync type (e.g. sync vs. async)
     * @param tests Test to groups
     * @returns Tests grouped by sync type
     */
    /**
     * Gets tests grouped by their sync type (e.g. sync vs. async)
     * @template T
     * @param {?} tests Test to groups
     * @return {?} Tests grouped by sync type
     */
    RulesEngineService.prototype.groupTestsBySyncType = /**
     * Gets tests grouped by their sync type (e.g. sync vs. async)
     * @template T
     * @param {?} tests Test to groups
     * @return {?} Tests grouped by sync type
     */
    function (tests) {
        var _this = this;
        var /** @type {?} */ testGroups = /** @type {?} */ ({
            sync: [],
            async: []
        });
        if (!tests)
            return testGroups;
        tests.forEach(function (test) {
            var /** @type {?} */ testFuncTypes = /** @type {?} */ ({
                sync: false,
                async: false
            });
            var /** @type {?} */ conditionResults = _this.getConfiguredFuncTypes(test.condition);
            var /** @type {?} */ checkResults = _this.getConfiguredFuncTypes(test.check);
            testFuncTypes.sync = conditionResults.sync || checkResults.sync;
            testFuncTypes.async = conditionResults.async || checkResults.async;
            // if there is an async func anywhere in the test's rule sets, then it is considered an async test
            if (testFuncTypes.sync && !testFuncTypes.async)
                testGroups.sync.push(test);
            if (testFuncTypes.async)
                testGroups.async.push(test);
        });
        return testGroups;
    };
    /**
     * Runs validation tests
     * @param data Data to run validation tests against
     * @param property Property to run validation tests for
     * @returns Results of validation tests
     */
    /**
     * Runs validation tests
     * @template T
     * @param {?} data Data to run validation tests against
     * @param {?} property Property to run validation tests for
     * @param {?=} state
     * @return {?} Results of validation tests
     */
    RulesEngineService.prototype.validate = /**
     * Runs validation tests
     * @template T
     * @param {?} data Data to run validation tests against
     * @param {?} property Property to run validation tests for
     * @param {?=} state
     * @return {?} Results of validation tests
     */
    function (data, property, state) {
        return this.runAllTests(data, property.valid, state)
            .pipe(map(function (results) {
            results.propertyName = property.absolutePath;
            return /** @type {?} */ (results);
        }));
    };
    /**
     * Runs editability tests
     * @param data Data to run editability tests against
     * @param property Property to run editability tests for
     * * @returns Results of editability tests
     */
    /**
     * Runs editability tests
     * @template T
     * @param {?} data Data to run editability tests against
     * @param {?} property Property to run editability tests for
     * * \@returns Results of editability tests
     * @param {?=} state
     * @return {?}
     */
    RulesEngineService.prototype.editable = /**
     * Runs editability tests
     * @template T
     * @param {?} data Data to run editability tests against
     * @param {?} property Property to run editability tests for
     * * \@returns Results of editability tests
     * @param {?=} state
     * @return {?}
     */
    function (data, property, state) {
        return this.runAllTests(data, property.edit, state)
            .pipe(map(function (results) {
            results.propertyName = property.absolutePath;
            return /** @type {?} */ (results);
        }));
    };
    /**
     * Runs visibility tests
     * @param data Data to run visibility tests against
     * @param property Property to run visibility tests for
     * * @returns Results of visibility tests
     */
    // visible<T>(data: T, property: Property<T>, state?: TestRunState): Observable<PropertyTestResults<T>> {
    //     return this.runAllTests(data, property.view, state)
    //         .pipe(
    //             map((results: PropertyTestResults<T>) => {
    //                 results.propertyName = property.absolutePath;
    //                 return results as PropertyTestResults<T>;
    //             })
    //         );
    // }
    /**
     * Runs an array of sync tests
     * @param data Data to perform tests against
     * @param tests Tests to run
     * @returns Result of tests
     */
    /**
     * Runs an array of sync tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    RulesEngineService.prototype.runTests = /**
     * Runs an array of sync tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    function (data, tests, state) {
        var _this = this;
        if (!tests || !tests.length)
            return new TestResultsBase([]);
        var /** @type {?} */ testResults = tests
            .map(function (t) { return _this.runTest(data, t, state); })
            .filter(function (x) { return !!x; });
        return new TestResultsBase(testResults);
    };
    /**
     * Runs an array of async tests
     * @param data Data to perform tests against
     * @param tests Tests to run
     * @returns Result of tests
     */
    /**
     * Runs an array of async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    RulesEngineService.prototype.runTestsAsync = /**
     * Runs an array of async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    function (data, tests, state) {
        var _this = this;
        if (!tests || !tests.length)
            return of(new TestResultsBase([]));
        var /** @type {?} */ runTest$ = tests
            .map(function (test) { return _this.runTestAsync(data, test, state); });
        return forkJoin(runTest$)
            .pipe(map(function (testResults) { return new TestResultsBase(testResults.filter(function (x) { return !!x; })); }));
    };
    /**
     * Runs an array of sync and async tests
     * @param data Data to perform tests against
     * @param tests Tests to run
     * @returns Result of tests
     */
    /**
     * Runs an array of sync and async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    RulesEngineService.prototype.runAllTests = /**
     * Runs an array of sync and async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    function (data, tests, state) {
        var _this = this;
        if (!tests || !tests.length)
            return of(new TestResultsBase([]));
        var /** @type {?} */ syncGroups = this.groupTestsBySyncType(tests);
        var /** @type {?} */ syncTestResults = of(this.runTests(data, syncGroups.sync, state));
        return syncTestResults.pipe(mergeMap(function (result) {
            if (!result.passed)
                return of(result);
            return _this.runTestsAsync(data, syncGroups.async, state);
        }), take(1));
    };
    /**
     * Performs sync test on a set of data
     * @param data Data to perform test against
     * @param test Test to run
     * @returns Result of test
     */
    /**
     * Performs sync test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    RulesEngineService.prototype.runTest = /**
     * Performs sync test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    function (data, test, state) {
        if (!test)
            return null;
        var /** @type {?} */ passedTestResult = { passed: true, name: test.name, message: null };
        var /** @type {?} */ failedTestResult = { passed: false, name: test.name, message: test.message };
        var /** @type {?} */ skippedTestResult = { passed: true, skipped: true, name: test.name, message: null };
        var /** @type {?} */ conditionsRuleSetResult = this.processRuleSet(data, test.condition, state);
        if (conditionsRuleSetResult === ProcessResultType.Failed)
            return skippedTestResult;
        var /** @type {?} */ checkRuleSetResult = this.processRuleSet(data, test.check, state);
        switch (checkRuleSetResult) {
            case ProcessResultType.Passed:
                return passedTestResult;
            case ProcessResultType.Failed:
                return failedTestResult;
            case ProcessResultType.Skipped:
            default:
                return skippedTestResult;
        }
    };
    /**
     * Performs async test on a set of data
     * @param data Data to perform test against
     * @param test Test to run
     * @returns Result of test
     */
    /**
     * Performs async test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    RulesEngineService.prototype.runTestAsync = /**
     * Performs async test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    function (data, test, state) {
        if (!test)
            return of(null);
        var /** @type {?} */ passedTestResult = { passed: true, name: test.name, message: null };
        var /** @type {?} */ failedTestResult = { passed: false, name: test.name, message: test.message };
        var /** @type {?} */ skippedTestResult = { passed: true, skipped: true, name: test.name, message: null };
        var /** @type {?} */ conditionsRuleSetResult$ = this.processRuleSetAsync(data, test.condition, state);
        var /** @type {?} */ checkRuleSetResult$ = this.processRuleSetAsync(data, test.check, state);
        return conditionsRuleSetResult$
            .pipe(flatMap(function (conditionsRuleSetResult) {
            if (conditionsRuleSetResult === ProcessResultType.Failed)
                return of(skippedTestResult);
            return checkRuleSetResult$
                .pipe(map(function (checkRuleSetResult) {
                switch (checkRuleSetResult) {
                    case ProcessResultType.Passed:
                        return passedTestResult;
                    case ProcessResultType.Failed:
                        return failedTestResult;
                    case ProcessResultType.Skipped:
                    default:
                        return skippedTestResult;
                }
            }));
        }));
    };
    /**
     * Processes a sync rule set
     * @param data Data to process rule set against
     * @param ruleSet Rule set to process
     * @returns Result of rule set processing
     */
    /**
     * Processes a sync rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    RulesEngineService.prototype.processRuleSet = /**
     * Processes a sync rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    function (data, ruleSet, state) {
        if (!ruleSet)
            return ProcessResultType.Skipped;
        var /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        return isRuleGroup
            ? this.processRuleGroup(data, /** @type {?} */ (ruleSet), state)
            : this.processRule(data, /** @type {?} */ (ruleSet), state);
    };
    /**
     * Processes an async rule set
     * @param data Data to process rule set against
     * @param ruleSet Rule set to process
     * @returns Result of rule set processing
     */
    /**
     * Processes an async rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    RulesEngineService.prototype.processRuleSetAsync = /**
     * Processes an async rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    function (data, ruleSet, state) {
        if (!ruleSet)
            return of(ProcessResultType.Skipped);
        var /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        return isRuleGroup
            ? this.processRuleGroupAsync(data, /** @type {?} */ (ruleSet), state)
            : this.processRuleAsync(data, /** @type {?} */ (ruleSet), state);
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    RulesEngineService.prototype.processRuleGroup = /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    function (data, ruleGroup, state) {
        if (!ruleGroup.rules)
            return ProcessResultType.Skipped;
        var /** @type {?} */ passedCount = 0;
        var /** @type {?} */ skippedCount = 0;
        for (var /** @type {?} */ i = 0; i < ruleGroup.rules.length; i++) {
            var /** @type {?} */ rule = ruleGroup.rules[i];
            var /** @type {?} */ ruleSetResult = this.processRuleSet(data, rule, state);
            if (this.canShortCircuitRuleGroup(ruleSetResult, ruleGroup))
                return ruleSetResult;
            if (ruleSetResult == ProcessResultType.Passed)
                passedCount++;
            else if (ruleSetResult == ProcessResultType.Skipped)
                skippedCount++;
        }
        // if we skipped them all, then return skipped
        if (skippedCount === ruleGroup.rules.length)
            return ProcessResultType.Skipped;
        // if we got this far, make sure all tests were passed
        return passedCount === ruleGroup.rules.length ? ProcessResultType.Passed : ProcessResultType.Failed;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    RulesEngineService.prototype.processRuleGroupAsync = /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    function (data, ruleGroup, state) {
        var _this = this;
        if (!ruleGroup.rules)
            return of(ProcessResultType.Skipped);
        var /** @type {?} */ asyncRuleSetResults$ = ruleGroup.rules.map(function (x) { return _this.processRuleSetAsync(data, x, state); });
        return forkJoin(asyncRuleSetResults$).pipe(map(function (ruleSetResults) {
            var /** @type {?} */ counts = {
                passed: ruleSetResults.filter(function (x) { return x === ProcessResultType.Passed; }).length,
                failed: ruleSetResults.filter(function (x) { return x === ProcessResultType.Failed; }).length,
                skipped: ruleSetResults.filter(function (x) { return x === ProcessResultType.Skipped; }).length,
            };
            var /** @type {?} */ ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };
            if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass && counts.passed > 0)
                return ProcessResultType.Passed;
            if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass && counts.passed === ruleSetResults.length)
                return ProcessResultType.Passed;
            if (counts.skipped === ruleSetResults.length)
                return ProcessResultType.Skipped;
            return ProcessResultType.Failed;
        }));
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    RulesEngineService.prototype.processRule = /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    function (data, rule, state) {
        if (!rule.func)
            return ProcessResultType.Skipped;
        var /** @type {?} */ rootData = state ? state.rootData : null;
        return rule.func(data, rootData) ? ProcessResultType.Passed : ProcessResultType.Failed;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    RulesEngineService.prototype.processRuleAsync = /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    function (data, rule, state) {
        if (!rule.func && !rule.asyncFunc)
            return of(ProcessResultType.Skipped);
        var /** @type {?} */ rootData = state ? state.rootData : null;
        var /** @type {?} */ funcResult = rule.func
            ? of(rule.func(data, rootData))
            : rule.asyncFunc(data, rootData);
        return funcResult
            .pipe(map(function (passed) { return passed ? ProcessResultType.Passed : ProcessResultType.Failed; }));
    };
    /**
     * @template T
     * @param {?} ruleSetResult
     * @param {?} ruleGroup
     * @return {?}
     */
    RulesEngineService.prototype.canShortCircuitRuleGroup = /**
     * @template T
     * @param {?} ruleSetResult
     * @param {?} ruleGroup
     * @return {?}
     */
    function (ruleSetResult, ruleGroup) {
        var /** @type {?} */ ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };
        return (
        // it passed, and we only need one to pass
        (ruleSetResult == ProcessResultType.Passed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass)
            ||
                // if failed, and we need all to pass
                (ruleSetResult == ProcessResultType.Failed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass));
    };
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    RulesEngineService.prototype.isRuleGroup = /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    function (ruleSet) {
        var /** @type {?} */ rule = /** @type {?} */ (ruleSet);
        return !rule.func && !rule.asyncFunc;
    };
    /**
     * @template T
     * @param {?} test
     * @return {?}
     */
    RulesEngineService.prototype.getDependencyPropertiesFromTest = /**
     * @template T
     * @param {?} test
     * @return {?}
     */
    function (test) {
        var /** @type {?} */ checkDeps = this.getDependencyPropertiesFromRuleSet(test.check);
        var /** @type {?} */ conditionDeps = this.getDependencyPropertiesFromRuleSet(test.condition);
        return this.commonSvc.unique(checkDeps.concat(conditionDeps));
    };
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    RulesEngineService.prototype.getDependencyPropertiesFromRuleSet = /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    function (ruleSet) {
        var _this = this;
        if (!ruleSet)
            return [];
        var /** @type {?} */ result = [];
        if (this.isRuleGroup(ruleSet)) {
            var /** @type {?} */ ruleGroup = /** @type {?} */ (ruleSet);
            ruleGroup.rules.forEach(function (x) {
                result.push.apply(result, tslib_1.__spread(_this.commonSvc.unique(_this.getDependencyPropertiesFromRuleSet(x))));
            });
        }
        var /** @type {?} */ rule = /** @type {?} */ (ruleSet);
        if (rule.options && Array.isArray(rule.options.dependencyProperties)) {
            result.push.apply(result, tslib_1.__spread(this.commonSvc.unique(rule.options.dependencyProperties)));
        }
        return this.commonSvc.unique(result);
    };
    /**
     * @param {?} properties
     * @param {?} modelSettingsName
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    RulesEngineService.prototype.setPropertyMetadata = /**
     * @param {?} properties
     * @param {?} modelSettingsName
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    function (properties, modelSettingsName, currentAbsolutePath) {
        var _this = this;
        if (currentAbsolutePath === void 0) { currentAbsolutePath = ''; }
        if (!properties)
            return;
        properties.forEach(function (prop) {
            var /** @type {?} */ newAbsolutePath = _this.setPropertyAbsolutePath(prop, currentAbsolutePath);
            _this.fillInEmptyTestNames(prop);
            prop.setOwnerModelSettingsName(modelSettingsName);
            if (prop.properties) {
                _this.setPropertyMetadata(prop.properties, modelSettingsName, newAbsolutePath);
            }
            else if (prop.arrayItemProperty) {
                _this.setPropertyMetadata([prop.arrayItemProperty], modelSettingsName, newAbsolutePath);
            }
        });
    };
    /**
     * @param {?} property
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    RulesEngineService.prototype.setPropertyAbsolutePath = /**
     * @param {?} property
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    function (property, currentAbsolutePath) {
        if (currentAbsolutePath === void 0) { currentAbsolutePath = ''; }
        var /** @type {?} */ isArrayItemProperty = PropertyBase.isArrayItemProperty(property);
        var /** @type {?} */ newAbsolutePathSegment = isArrayItemProperty ? '[]' : (/** @type {?} */ (property)).name;
        var /** @type {?} */ isAtRoot = !currentAbsolutePath;
        var /** @type {?} */ newAbsolutePath = "" + currentAbsolutePath + (isAtRoot ? '' : '.') + newAbsolutePathSegment;
        // set absolute path for property
        property.setAbsolutePath(newAbsolutePath);
        return newAbsolutePath;
    };
    /**
     * @param {?} property
     * @return {?}
     */
    RulesEngineService.prototype.fillInEmptyTestNames = /**
     * @param {?} property
     * @return {?}
     */
    function (property) {
        property.valid
            .filter(function (test) { return !test.name; })
            .forEach(function (test, i) { return test.name = "validTest" + i; });
        property.edit
            .filter(function (test) { return !test.name; })
            .forEach(function (test, i) { return test.name = "editTest" + i; });
    };
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    RulesEngineService.prototype.getConfiguredFuncTypes = /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    function (ruleSet) {
        var _this = this;
        if (!ruleSet)
            return { sync: false, async: false };
        var /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        if (isRuleGroup) {
            var /** @type {?} */ ruleGroup = /** @type {?} */ (ruleSet);
            var /** @type {?} */ results = ruleGroup.rules
                .map(function (rs) {
                return _this.getConfiguredFuncTypes(rs);
            });
            return {
                sync: results.findIndex(function (x) { return !!x.sync; }) >= 0,
                async: results.findIndex(function (x) { return !!x.async; }) >= 0,
            };
        }
        else {
            var /** @type {?} */ rule = /** @type {?} */ (ruleSet);
            return {
                sync: !!rule.func,
                async: !!rule.asyncFunc
            };
        }
    };
    RulesEngineService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    RulesEngineService.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [MODEL_SETTINGS_TOKEN,] },] },
        { type: TraceService, },
        { type: CommonService, },
    ]; };
    return RulesEngineService;
}());
export { RulesEngineService };
function RulesEngineService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    RulesEngineService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    RulesEngineService.ctorParameters;
    /** @type {?} */
    RulesEngineService.prototype.registeredSettings;
    /** @type {?} */
    RulesEngineService.prototype.traceSvc;
    /** @type {?} */
    RulesEngineService.prototype.commonSvc;
}
/**
 * @record
 */
function ConfiguredFuncTypes() { }
function ConfiguredFuncTypes_tsickle_Closure_declarations() {
    /** @type {?} */
    ConfiguredFuncTypes.prototype.sync;
    /** @type {?} */
    ConfiguredFuncTypes.prototype.async;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVsZXMtZW5naW5lLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1mb3JtLXJ1bGVzLyIsInNvdXJjZXMiOlsibGliL3J1bGVzLWVuZ2luZS9zZXJ2aWNlcy9ydWxlcy1lbmdpbmUvcnVsZXMtZW5naW5lLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sMkRBQTJELENBQUM7QUFTakcsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUNyRSxPQUFPLEVBQWMsUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRCxPQUFPLEVBQUcsR0FBRyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFPLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBRS9FLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpREFBaUQsQ0FBQztBQUVwRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxxREFBcUQsQ0FBQzs7Ozs7SUFTekYsNEJBQzhDLFVBQ2xDLFVBQ0E7UUFIWixpQkFhQztRQVhXLGFBQVEsR0FBUixRQUFRO1FBQ1IsY0FBUyxHQUFULFNBQVM7UUFFakIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEVBQUUsQ0FBQztRQUU3QixFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFBQyxNQUFNLENBQUM7UUFFckMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFB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LENBQUM7WUFDZCxxQkFBTSxTQUFTLHFCQUFHLE9BQXVCLENBQUEsQ0FBQztZQUMxQyxxQkFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEtBQUs7aUJBQzFCLEdBQUcsQ0FBQyxVQUFBLEVBQUU7Z0JBQ0gsTUFBTSxDQUFDLEtBQUksQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUMxQyxDQUFDLENBQUM7WUFFUCxNQUFNLENBQUM7Z0JBQ0gsSUFBSSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBUixDQUFRLENBQUMsSUFBSSxDQUFDO2dCQUMzQyxLQUFLLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFULENBQVMsQ0FBQyxJQUFJLENBQUM7YUFDaEQsQ0FBQztTQUNMO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDSixxQkFBTSxJQUFJLHFCQUFHLE9BQWtCLENBQUEsQ0FBQztZQUNoQyxNQUFNLENBQUM7Z0JBQ0gsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSTtnQkFDakIsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUzthQUMxQixDQUFDO1NBQ0w7OztnQkE5ZFIsVUFBVTs7Ozs0Q0FLRixRQUFRLFlBQUksTUFBTSxTQUFDLG9CQUFvQjtnQkFuQnZDLFlBQVk7Z0JBQ1osYUFBYTs7NkJBWHRCOztTQXlCYSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1PREVMX1NFVFRJTkdTX1RPS0VOIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9pbmplY3Rpb24tdG9rZW5zL21vZGVsLXNldHRpbmdzLnRva2VuJztcclxuaW1wb3J0IHsgQWJzdHJhY3RNb2RlbFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvYWJzdHJhY3QtbW9kZWwtc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eSB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Byb3BlcnR5JztcclxuaW1wb3J0IHsgUnVsZUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcnVsZS1ncm91cCc7XHJcbmltcG9ydCB7IFJ1bGUgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9ydWxlJztcclxuaW1wb3J0IHsgVGVzdCB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Rlc3QnO1xyXG5pbXBvcnQgeyBUZXN0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1yZXN1bHQnO1xyXG5pbXBvcnQgeyBSdWxlU2V0IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcnVsZS1zZXQnO1xyXG5pbXBvcnQgeyBUZXN0UnVuU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy90ZXN0LXJ1bi1zdGF0ZSc7XHJcbmltcG9ydCB7IFRyYWNlU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3RyYWNlL3RyYWNlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDb21tb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29tbW9uL2NvbW1vbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZm9ya0pvaW4sIG9mIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7ICBtYXAsIGZsYXRNYXAsIG1lcmdlTWFwLCB0YWtlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFRlc3RSZXN1bHRzQmFzZSB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Rlc3QtcmVzdWx0cy1iYXNlJztcclxuaW1wb3J0IHsgUHJvcGVydHlUZXN0UmVzdWx0cyB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Byb3BlcnR5LXRlc3QtcmVzdWx0JztcclxuaW1wb3J0IHsgUHJvcGVydHlCYXNlIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcHJvcGVydHktYmFzZSc7XHJcbmltcG9ydCB7IFByb2Nlc3NSZXN1bHRUeXBlIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcHJvY2Nlc3MtcmVzdWx0LXR5cGUnO1xyXG5pbXBvcnQgeyBUZXN0U3luY0dyb3VwcyB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Rlc3Qtc3luYy1ncm91cHMnO1xyXG5pbXBvcnQgeyBSZXN1bHRzUGFzc1JlcXVpcmVtZW50IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcmVzdWx0cy1wYXNzLXJlcXVpcmVtZW50JztcclxuXHJcbi8qKlxyXG4gKiBFbmdpbmUgdGhhdCBkaWdlc3RzIG1vZGVsIHNldHRpbmdzIGFuZCBhcHBsaWVzIHRoZWlyIHJ1bGVzIGFwcHJvcHJpYXRlbHlcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFJ1bGVzRW5naW5lU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRTZXR0aW5nczogeyBba2V5OiBzdHJpbmddOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8YW55PjsgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1PREVMX1NFVFRJTkdTX1RPS0VOKSBzZXR0aW5nczogQWJzdHJhY3RNb2RlbFNldHRpbmdzPGFueT5bXSxcclxuICAgICAgICBwcml2YXRlIHRyYWNlU3ZjOiBUcmFjZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBjb21tb25TdmM6IENvbW1vblNlcnZpY2VcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNldHRpbmdzID0ge307XHJcblxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXR0aW5ncykpIHJldHVybjtcclxuXHJcbiAgICAgICAgc2V0dGluZ3MuZm9yRWFjaChzZXR0aW5nID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTW9kZWxTZXR0aW5nKHNldHRpbmcpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTZXR0aW5nc1tzZXR0aW5nLm5hbWVdID0gc2V0dGluZztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIG1vZGVsIHNldHRpbmdzIGFuZCBwcmVwYXJlcyB0aGVtIHRvIGJlIHVzZWQgaW4gYSBmb3JtIGdyb3VwXHJcbiAgICAgKiBAcGFyYW0gc2V0dGluZyBNb2RlbCBzZXR0aW5nIHRvIGluaXRpYWxpemVcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZU1vZGVsU2V0dGluZyhzZXR0aW5nOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8YW55Pik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudHJhY2VTdmMudHJhY2UoYEluaXRpYWxpemluZyBtb2RlbCBzZXR0aW5ncyBcIiR7c2V0dGluZy5uYW1lfVwiYCk7XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU1ldGFkYXRhKHNldHRpbmcucHJvcGVydGllcywgc2V0dGluZy5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgbW9kZWwgc2V0dGluZ3Mgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZVxyXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiBtb2RlbCBzZXR0aW5nXHJcbiAgICAgKiBAcmV0dXJucyBNb2RlbCBzZXR0aW5ncyB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcbiAgICAgKi9cclxuICAgIGdldE1vZGVsU2V0dGluZ3M8VD4obmFtZTogc3RyaW5nKTogQWJzdHJhY3RNb2RlbFNldHRpbmdzPFQ+IHtcclxuICAgICAgICB0aGlzLnRyYWNlU3ZjLnRyYWNlKGBSZXRyaWV2aW5nIG1vZGVsIHNldHRpbmdzIFwiJHtuYW1lfVwiYCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5yZWdpc3RlcmVkU2V0dGluZ3NbbmFtZV07XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0XHJcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzXHJcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZWdpc3RlcmVkU2V0dGluZ3NbbmFtZV0pXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRlcGVuZGVuY3kgcHJvcGVydGllcyBmb3IgYW4gYXJyYXkgb2YgdGVzdHNcclxuICAgICAqIEBwYXJhbSB0ZXN0cyBUZXN0cyB0byBnZXQgdGhlIGRlcGVuZGVuY3kgcHJvcGVydGllcyBmb3JcclxuICAgICAqIEByZXR1cm5zIERlcGVuZGVuY3kgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBnZXREZXBlbmRlbmN5UHJvcGVydGllczxUPih0ZXN0czogVGVzdDxUPltdKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGlmICghdGVzdHMpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgZGVwcyA9IHRlc3RzXHJcbiAgICAgICAgICAgIC5tYXAodCA9PiB0aGlzLmdldERlcGVuZGVuY3lQcm9wZXJ0aWVzRnJvbVRlc3QodCkpXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHByZXYuY29uY2F0KGN1cnJlbnQpLCBbXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1vblN2Yy51bmlxdWUoZGVwcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRlc3RzIGdyb3VwZWQgYnkgdGhlaXIgc3luYyB0eXBlIChlLmcuIHN5bmMgdnMuIGFzeW5jKVxyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3QgdG8gZ3JvdXBzXHJcbiAgICAgKiBAcmV0dXJucyBUZXN0cyBncm91cGVkIGJ5IHN5bmMgdHlwZVxyXG4gICAgICovXHJcbiAgICBncm91cFRlc3RzQnlTeW5jVHlwZTxUPih0ZXN0czogVGVzdDxUPltdKTogVGVzdFN5bmNHcm91cHM8VD4ge1xyXG4gICAgICAgIGNvbnN0IHRlc3RHcm91cHMgPSB7XHJcbiAgICAgICAgICAgIHN5bmM6IFtdLFxyXG4gICAgICAgICAgICBhc3luYzogW11cclxuICAgICAgICB9IGFzIFRlc3RTeW5jR3JvdXBzPFQ+O1xyXG5cclxuICAgICAgICBpZiAoIXRlc3RzKSByZXR1cm4gdGVzdEdyb3VwcztcclxuXHJcbiAgICAgICAgdGVzdHMuZm9yRWFjaCh0ZXN0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGVzdEZ1bmNUeXBlcyA9IHtcclxuICAgICAgICAgICAgICAgIHN5bmM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcbiAgICAgICAgICAgIH0gYXMgQ29uZmlndXJlZEZ1bmNUeXBlcztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvblJlc3VsdHMgPSB0aGlzLmdldENvbmZpZ3VyZWRGdW5jVHlwZXModGVzdC5jb25kaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja1Jlc3VsdHMgPSB0aGlzLmdldENvbmZpZ3VyZWRGdW5jVHlwZXModGVzdC5jaGVjayk7XHJcblxyXG4gICAgICAgICAgICB0ZXN0RnVuY1R5cGVzLnN5bmMgPSBjb25kaXRpb25SZXN1bHRzLnN5bmMgfHwgY2hlY2tSZXN1bHRzLnN5bmM7XHJcbiAgICAgICAgICAgIHRlc3RGdW5jVHlwZXMuYXN5bmMgPSBjb25kaXRpb25SZXN1bHRzLmFzeW5jIHx8IGNoZWNrUmVzdWx0cy5hc3luYztcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGFzeW5jIGZ1bmMgYW55d2hlcmUgaW4gdGhlIHRlc3QncyBydWxlIHNldHMsIHRoZW4gaXQgaXMgY29uc2lkZXJlZCBhbiBhc3luYyB0ZXN0XHJcbiAgICAgICAgICAgIGlmICh0ZXN0RnVuY1R5cGVzLnN5bmMgJiYgIXRlc3RGdW5jVHlwZXMuYXN5bmMpIHRlc3RHcm91cHMuc3luYy5wdXNoKHRlc3QpO1xyXG4gICAgICAgICAgICBpZiAodGVzdEZ1bmNUeXBlcy5hc3luYykgdGVzdEdyb3Vwcy5hc3luYy5wdXNoKHRlc3QpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGVzdEdyb3VwcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdmFsaWRhdGlvbiB0ZXN0c1xyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBydW4gdmFsaWRhdGlvbiB0ZXN0cyBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgUHJvcGVydHkgdG8gcnVuIHZhbGlkYXRpb24gdGVzdHMgZm9yXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRzIG9mIHZhbGlkYXRpb24gdGVzdHNcclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGU8VD4oZGF0YTogVCwgcHJvcGVydHk6IFByb3BlcnR5PFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8UHJvcGVydHlUZXN0UmVzdWx0czxUPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bkFsbFRlc3RzKGRhdGEsIHByb3BlcnR5LnZhbGlkLCBzdGF0ZSlcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3VsdHM6IFByb3BlcnR5VGVzdFJlc3VsdHM8VD4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5LmFic29sdXRlUGF0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cyBhcyBQcm9wZXJ0eVRlc3RSZXN1bHRzPFQ+O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgZWRpdGFiaWxpdHkgdGVzdHNcclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcnVuIGVkaXRhYmlsaXR5IHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBydW4gZWRpdGFiaWxpdHkgdGVzdHMgZm9yXHJcbiAgICAgKiAqIEByZXR1cm5zIFJlc3VsdHMgb2YgZWRpdGFiaWxpdHkgdGVzdHNcclxuICAgICAqL1xyXG4gICAgZWRpdGFibGU8VD4oZGF0YTogVCwgcHJvcGVydHk6IFByb3BlcnR5QmFzZTxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFByb3BlcnR5VGVzdFJlc3VsdHM8VD4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5BbGxUZXN0cyhkYXRhLCBwcm9wZXJ0eS5lZGl0LCBzdGF0ZSlcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3VsdHM6IFByb3BlcnR5VGVzdFJlc3VsdHM8VD4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5LmFic29sdXRlUGF0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cyBhcyBQcm9wZXJ0eVRlc3RSZXN1bHRzPFQ+O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdmlzaWJpbGl0eSB0ZXN0c1xyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBydW4gdmlzaWJpbGl0eSB0ZXN0cyBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgUHJvcGVydHkgdG8gcnVuIHZpc2liaWxpdHkgdGVzdHMgZm9yXHJcbiAgICAgKiAqIEByZXR1cm5zIFJlc3VsdHMgb2YgdmlzaWJpbGl0eSB0ZXN0c1xyXG4gICAgICovXHJcbiAgICAvLyB2aXNpYmxlPFQ+KGRhdGE6IFQsIHByb3BlcnR5OiBQcm9wZXJ0eTxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFByb3BlcnR5VGVzdFJlc3VsdHM8VD4+IHtcclxuICAgIC8vICAgICByZXR1cm4gdGhpcy5ydW5BbGxUZXN0cyhkYXRhLCBwcm9wZXJ0eS52aWV3LCBzdGF0ZSlcclxuICAgIC8vICAgICAgICAgLnBpcGUoXHJcbiAgICAvLyAgICAgICAgICAgICBtYXAoKHJlc3VsdHM6IFByb3BlcnR5VGVzdFJlc3VsdHM8VD4pID0+IHtcclxuICAgIC8vICAgICAgICAgICAgICAgICByZXN1bHRzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5LmFic29sdXRlUGF0aDtcclxuICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cyBhcyBQcm9wZXJ0eVRlc3RSZXN1bHRzPFQ+O1xyXG4gICAgLy8gICAgICAgICAgICAgfSlcclxuICAgIC8vICAgICAgICAgKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYW4gYXJyYXkgb2Ygc3luYyB0ZXN0c1xyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBwZXJmb3JtIHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSB0ZXN0cyBUZXN0cyB0byBydW5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiB0ZXN0c1xyXG4gICAgICovXHJcbiAgICBydW5UZXN0czxUPihkYXRhOiBULCB0ZXN0czogVGVzdDxUPltdLCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IFRlc3RSZXN1bHRzQmFzZTxUPiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0cyB8fCAhdGVzdHMubGVuZ3RoKSByZXR1cm4gbmV3IFRlc3RSZXN1bHRzQmFzZShbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRlc3RSZXN1bHRzID0gdGVzdHNcclxuICAgICAgICAgICAgLm1hcCh0ID0+IHRoaXMucnVuVGVzdChkYXRhLCB0LCBzdGF0ZSkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiAhIXgpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRlc3RSZXN1bHRzQmFzZSh0ZXN0UmVzdWx0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGFuIGFycmF5IG9mIGFzeW5jIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RzXHJcbiAgICAgKi9cclxuICAgIHJ1blRlc3RzQXN5bmM8VD4oZGF0YTogVCwgdGVzdHM6IFRlc3Q8VD5bXSwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFRlc3RSZXN1bHRzQmFzZTxUPj4ge1xyXG4gICAgICAgIGlmICghdGVzdHMgfHwgIXRlc3RzLmxlbmd0aCkgcmV0dXJuIG9mKG5ldyBUZXN0UmVzdWx0c0Jhc2UoW10pKTtcclxuXHJcbiAgICAgICAgY29uc3QgcnVuVGVzdCQgPSB0ZXN0c1xyXG4gICAgICAgICAgICAubWFwKHRlc3QgPT4gdGhpcy5ydW5UZXN0QXN5bmMoZGF0YSwgdGVzdCwgc3RhdGUpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKHJ1blRlc3QkKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCh0ZXN0UmVzdWx0cyA9PiBuZXcgVGVzdFJlc3VsdHNCYXNlKHRlc3RSZXN1bHRzLmZpbHRlcih4ID0+ICEheCkpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBhbiBhcnJheSBvZiBzeW5jIGFuZCBhc3luYyB0ZXN0c1xyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBwZXJmb3JtIHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSB0ZXN0cyBUZXN0cyB0byBydW5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiB0ZXN0c1xyXG4gICAgICovXHJcbiAgICBydW5BbGxUZXN0czxUPihkYXRhOiBULCB0ZXN0czogVGVzdDxUPltdLCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8VGVzdFJlc3VsdHNCYXNlPFQ+PiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0cyB8fCAhdGVzdHMubGVuZ3RoKSByZXR1cm4gb2YobmV3IFRlc3RSZXN1bHRzQmFzZShbXSkpO1xyXG5cclxuICAgICAgICBjb25zdCBzeW5jR3JvdXBzID0gdGhpcy5ncm91cFRlc3RzQnlTeW5jVHlwZSh0ZXN0cyk7XHJcbiAgICAgICAgY29uc3Qgc3luY1Rlc3RSZXN1bHRzID0gb2YodGhpcy5ydW5UZXN0cyhkYXRhLCBzeW5jR3JvdXBzLnN5bmMsIHN0YXRlKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzeW5jVGVzdFJlc3VsdHMucGlwZShcclxuICAgICAgICAgICAgbWVyZ2VNYXAocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnBhc3NlZCkgcmV0dXJuIG9mKHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuVGVzdHNBc3luYyhkYXRhLCBzeW5jR3JvdXBzLmFzeW5jLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB0YWtlKDEpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIHN5bmMgdGVzdCBvbiBhIHNldCBvZiBkYXRhXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdCBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gdGVzdCBUZXN0IHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RcclxuICAgICAqL1xyXG4gICAgcnVuVGVzdDxUPihkYXRhOiBULCB0ZXN0OiBUZXN0PFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IFRlc3RSZXN1bHQ8VD4ge1xyXG4gICAgICAgIGlmICghdGVzdCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhc3NlZFRlc3RSZXN1bHQ6IFRlc3RSZXN1bHQ8VD4gPSB7IHBhc3NlZDogdHJ1ZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiBudWxsIH07XHJcbiAgICAgICAgY29uc3QgZmFpbGVkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiBmYWxzZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiB0ZXN0Lm1lc3NhZ2UgfTtcclxuICAgICAgICBjb25zdCBza2lwcGVkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiB0cnVlLCBza2lwcGVkOiB0cnVlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IG51bGwgfTtcclxuXHJcbiAgICAgICAgY29uc3QgY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQgPSB0aGlzLnByb2Nlc3NSdWxlU2V0KGRhdGEsIHRlc3QuY29uZGl0aW9uLCBzdGF0ZSk7XHJcbiAgICAgICAgaWYgKGNvbmRpdGlvbnNSdWxlU2V0UmVzdWx0ID09PSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQpIHJldHVybiBza2lwcGVkVGVzdFJlc3VsdDtcclxuXHJcbiAgICAgICAgY29uc3QgY2hlY2tSdWxlU2V0UmVzdWx0ID0gdGhpcy5wcm9jZXNzUnVsZVNldChkYXRhLCB0ZXN0LmNoZWNrLCBzdGF0ZSk7XHJcbiAgICAgICAgc3dpdGNoIChjaGVja1J1bGVTZXRSZXN1bHQpIHtcclxuICAgICAgICAgICAgY2FzZSBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFzc2VkVGVzdFJlc3VsdDtcclxuICAgICAgICAgICAgY2FzZSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbGVkVGVzdFJlc3VsdDtcclxuICAgICAgICAgICAgY2FzZSBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkOlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXBwZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGFzeW5jIHRlc3Qgb24gYSBzZXQgb2YgZGF0YVxyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBwZXJmb3JtIHRlc3QgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHRlc3QgVGVzdCB0byBydW5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiB0ZXN0XHJcbiAgICAgKi9cclxuICAgIHJ1blRlc3RBc3luYzxUPihkYXRhOiBULCB0ZXN0OiBUZXN0PFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8VGVzdFJlc3VsdDxUPj4ge1xyXG4gICAgICAgIGlmICghdGVzdCkgcmV0dXJuIG9mKG51bGwpO1xyXG5cclxuICAgICAgICBjb25zdCBwYXNzZWRUZXN0UmVzdWx0OiBUZXN0UmVzdWx0PFQ+ID0geyBwYXNzZWQ6IHRydWUsIG5hbWU6IHRlc3QubmFtZSwgbWVzc2FnZTogbnVsbCB9O1xyXG4gICAgICAgIGNvbnN0IGZhaWxlZFRlc3RSZXN1bHQ6IFRlc3RSZXN1bHQ8VD4gPSB7IHBhc3NlZDogZmFsc2UsIG5hbWU6IHRlc3QubmFtZSwgbWVzc2FnZTogdGVzdC5tZXNzYWdlIH07XHJcbiAgICAgICAgY29uc3Qgc2tpcHBlZFRlc3RSZXN1bHQ6IFRlc3RSZXN1bHQ8VD4gPSB7IHBhc3NlZDogdHJ1ZSwgc2tpcHBlZDogdHJ1ZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiBudWxsIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbnNSdWxlU2V0UmVzdWx0JCA9IHRoaXMucHJvY2Vzc1J1bGVTZXRBc3luYyhkYXRhLCB0ZXN0LmNvbmRpdGlvbiwgc3RhdGUpO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrUnVsZVNldFJlc3VsdCQgPSB0aGlzLnByb2Nlc3NSdWxlU2V0QXN5bmMoZGF0YSwgdGVzdC5jaGVjaywgc3RhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQkXHJcbiAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgZmxhdE1hcChjb25kaXRpb25zUnVsZVNldFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbnNSdWxlU2V0UmVzdWx0ID09PSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQpIHJldHVybiBvZihza2lwcGVkVGVzdFJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1J1bGVTZXRSZXN1bHQkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwKGNoZWNrUnVsZVNldFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGVja1J1bGVTZXRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFzc2VkVGVzdFJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbGVkVGVzdFJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNraXBwZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2Vzc2VzIGEgc3luYyBydWxlIHNldFxyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBwcm9jZXNzIHJ1bGUgc2V0IGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBydWxlU2V0IFJ1bGUgc2V0IHRvIHByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiBydWxlIHNldCBwcm9jZXNzaW5nXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NSdWxlU2V0PFQ+KGRhdGE6IFQsIHJ1bGVTZXQ6IFJ1bGVTZXQ8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogUHJvY2Vzc1Jlc3VsdFR5cGUge1xyXG4gICAgICAgIGlmICghcnVsZVNldCkgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUnVsZUdyb3VwID0gdGhpcy5pc1J1bGVHcm91cChydWxlU2V0KTtcclxuICAgICAgICByZXR1cm4gaXNSdWxlR3JvdXBcclxuICAgICAgICAgICAgPyB0aGlzLnByb2Nlc3NSdWxlR3JvdXAoZGF0YSwgcnVsZVNldCBhcyBSdWxlR3JvdXA8VD4sIHN0YXRlKVxyXG4gICAgICAgICAgICA6IHRoaXMucHJvY2Vzc1J1bGUoZGF0YSwgcnVsZVNldCBhcyBSdWxlPFQ+LCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzZXMgYW4gYXN5bmMgcnVsZSBzZXRcclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcHJvY2VzcyBydWxlIHNldCBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gcnVsZVNldCBSdWxlIHNldCB0byBwcm9jZXNzXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHQgb2YgcnVsZSBzZXQgcHJvY2Vzc2luZ1xyXG4gICAgICovXHJcbiAgICBwcm9jZXNzUnVsZVNldEFzeW5jPFQ+KGRhdGE6IFQsIHJ1bGVTZXQ6IFJ1bGVTZXQ8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxQcm9jZXNzUmVzdWx0VHlwZT4ge1xyXG4gICAgICAgIGlmICghcnVsZVNldCkgcmV0dXJuIG9mKFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1J1bGVHcm91cCA9IHRoaXMuaXNSdWxlR3JvdXAocnVsZVNldCk7XHJcbiAgICAgICAgcmV0dXJuIGlzUnVsZUdyb3VwXHJcbiAgICAgICAgICAgID8gdGhpcy5wcm9jZXNzUnVsZUdyb3VwQXN5bmMoZGF0YSwgcnVsZVNldCBhcyBSdWxlR3JvdXA8VD4sIHN0YXRlKVxyXG4gICAgICAgICAgICA6IHRoaXMucHJvY2Vzc1J1bGVBc3luYyhkYXRhLCBydWxlU2V0IGFzIFJ1bGU8VD4sIHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHByb2Nlc3NSdWxlR3JvdXA8VD4oZGF0YTogVCwgcnVsZUdyb3VwOiBSdWxlR3JvdXA8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogUHJvY2Vzc1Jlc3VsdFR5cGUge1xyXG4gICAgICAgIGlmICghcnVsZUdyb3VwLnJ1bGVzKSByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZDtcclxuXHJcbiAgICAgICAgbGV0IHBhc3NlZENvdW50ID0gMDtcclxuICAgICAgICBsZXQgc2tpcHBlZENvdW50ID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlR3JvdXAucnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVHcm91cC5ydWxlc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgcnVsZVNldFJlc3VsdCA9IHRoaXMucHJvY2Vzc1J1bGVTZXQoZGF0YSwgcnVsZSwgc3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2hvcnRDaXJjdWl0UnVsZUdyb3VwKHJ1bGVTZXRSZXN1bHQsIHJ1bGVHcm91cCkpIHJldHVybiBydWxlU2V0UmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHJ1bGVTZXRSZXN1bHQgPT0gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkKSBwYXNzZWRDb3VudCsrO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChydWxlU2V0UmVzdWx0ID09IFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQpIHNraXBwZWRDb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgd2Ugc2tpcHBlZCB0aGVtIGFsbCwgdGhlbiByZXR1cm4gc2tpcHBlZFxyXG4gICAgICAgIGlmIChza2lwcGVkQ291bnQgPT09IHJ1bGVHcm91cC5ydWxlcy5sZW5ndGgpIHJldHVybiBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkO1xyXG5cclxuICAgICAgICAvLyBpZiB3ZSBnb3QgdGhpcyBmYXIsIG1ha2Ugc3VyZSBhbGwgdGVzdHMgd2VyZSBwYXNzZWRcclxuICAgICAgICByZXR1cm4gcGFzc2VkQ291bnQgPT09IHJ1bGVHcm91cC5ydWxlcy5sZW5ndGggPyBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQgOiBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwcm9jZXNzUnVsZUdyb3VwQXN5bmM8VD4oZGF0YTogVCwgcnVsZUdyb3VwOiBSdWxlR3JvdXA8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxQcm9jZXNzUmVzdWx0VHlwZT4ge1xyXG4gICAgICAgIGlmICghcnVsZUdyb3VwLnJ1bGVzKSByZXR1cm4gb2YoUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZCk7XHJcbiAgICAgICAgY29uc3QgYXN5bmNSdWxlU2V0UmVzdWx0cyQgPSBydWxlR3JvdXAucnVsZXMubWFwKHggPT4gdGhpcy5wcm9jZXNzUnVsZVNldEFzeW5jKGRhdGEsIHgsIHN0YXRlKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JrSm9pbihhc3luY1J1bGVTZXRSZXN1bHRzJCkucGlwZShcclxuICAgICAgICAgICAgbWFwKHJ1bGVTZXRSZXN1bHRzID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwYXNzZWQ6IHJ1bGVTZXRSZXN1bHRzLmZpbHRlcih4ID0+IHggPT09IFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZCkubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZDogcnVsZVNldFJlc3VsdHMuZmlsdGVyKHggPT4geCA9PT0gUHJvY2Vzc1Jlc3VsdFR5cGUuRmFpbGVkKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZDogcnVsZVNldFJlc3VsdHMuZmlsdGVyKHggPT4geCA9PT0gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZCkubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlR3JvdXBPcHRpb25zID0gcnVsZUdyb3VwLm9wdGlvbnMgfHwgeyByZXN1bHRSZXF1aXJlbWVudHM6IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQWxsUGFzcyB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChydWxlR3JvdXBPcHRpb25zLnJlc3VsdFJlcXVpcmVtZW50cyA9PSBSZXN1bHRzUGFzc1JlcXVpcmVtZW50LkFueVBhc3MgJiYgY291bnRzLnBhc3NlZCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlR3JvdXBPcHRpb25zLnJlc3VsdFJlcXVpcmVtZW50cyA9PSBSZXN1bHRzUGFzc1JlcXVpcmVtZW50LkFsbFBhc3MgJiYgY291bnRzLnBhc3NlZCA9PT0gcnVsZVNldFJlc3VsdHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRzLnNraXBwZWQgPT09IHJ1bGVTZXRSZXN1bHRzLmxlbmd0aCkgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcHJvY2Vzc1J1bGU8VD4oZGF0YTogVCwgcnVsZTogUnVsZTxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBQcm9jZXNzUmVzdWx0VHlwZSB7XHJcbiAgICAgICAgaWYgKCFydWxlLmZ1bmMpIHJldHVybiBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkO1xyXG5cclxuICAgICAgICBjb25zdCByb290RGF0YSA9IHN0YXRlID8gc3RhdGUucm9vdERhdGEgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBydWxlLmZ1bmMoZGF0YSwgcm9vdERhdGEpID8gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkIDogUHJvY2Vzc1Jlc3VsdFR5cGUuRmFpbGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcHJvY2Vzc1J1bGVBc3luYzxUPihkYXRhOiBULCBydWxlOiBSdWxlPFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8UHJvY2Vzc1Jlc3VsdFR5cGU+IHtcclxuICAgICAgICBpZiAoIXJ1bGUuZnVuYyAmJiAhcnVsZS5hc3luY0Z1bmMpIHJldHVybiBvZihQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm9vdERhdGEgPSBzdGF0ZSA/IHN0YXRlLnJvb3REYXRhIDogbnVsbDtcclxuICAgICAgICBjb25zdCBmdW5jUmVzdWx0ID0gcnVsZS5mdW5jXHJcbiAgICAgICAgICAgID8gb2YocnVsZS5mdW5jKGRhdGEsIHJvb3REYXRhKSlcclxuICAgICAgICAgICAgOiBydWxlLmFzeW5jRnVuYyhkYXRhLCByb290RGF0YSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jUmVzdWx0XHJcbiAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgbWFwKHBhc3NlZCA9PiBwYXNzZWQgPyBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQgOiBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJpdmF0ZSBkb1Byb2Nlc3NSdWxlPFQ+KHJ1bGU6IFJ1bGU8VD4sIHN0YXRlOiBUZXN0UnVuU3RhdGUsIGlzQXN5bmM6IGJvb2xlYW4pOiBib29sZWFuIHtcclxuICAgIC8vICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgZnVuYyB0byBjYWxsXHJcbiAgICAvLyAgICAgaWYgKChpc0FzeW5jICYmICFydWxlLmFzeW5jRnVuYykgfHwgKCFpc0FzeW5jICYmICFydWxlLmZ1bmMpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgLy8gICAgIC8vIC8vIGlmIHRoZXJlIGlzIG1pc3NpbmcgZGF0YSwgdGhlbiBhc3N1bWUgd2Ugc2hvdWxkIHByb2Nlc3MgdGhlIHJ1bGVcclxuICAgIC8vICAgICAvLyBpZiAoIXJ1bGUub3B0aW9ucyB8fCAhcnVsZS5vcHRpb25zLmNvbnRyb2xTdGF0ZU9wdGlvbnMgfHwgIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sU3RhdGUpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIC8vICAgICAvLyBpZiAocnVsZS5vcHRpb25zLmNvbnRyb2xTdGF0ZU9wdGlvbnMuc2tpcFByaXN0aW5lICYmIHN0YXRlLmNvbnRyb2xTdGF0ZS5wcmlzdGluZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gICAgIC8vIGlmIChydWxlLm9wdGlvbnMuY29udHJvbFN0YXRlT3B0aW9ucy5za2lwVW50b3VjaGVkICYmIHN0YXRlLmNvbnRyb2xTdGF0ZS51bnRvdWNoZWQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJpdmF0ZSBjYW5TaG9ydENpcmN1aXRSdWxlR3JvdXA8VD4ocnVsZVNldFJlc3VsdDogUHJvY2Vzc1Jlc3VsdFR5cGUsIHJ1bGVHcm91cDogUnVsZUdyb3VwPFQ+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgcnVsZUdyb3VwT3B0aW9ucyA9IHJ1bGVHcm91cC5vcHRpb25zIHx8IHsgcmVzdWx0UmVxdWlyZW1lbnRzOiBSZXN1bHRzUGFzc1JlcXVpcmVtZW50LkFsbFBhc3MgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgLy8gaXQgcGFzc2VkLCBhbmQgd2Ugb25seSBuZWVkIG9uZSB0byBwYXNzXHJcbiAgICAgICAgICAgIChydWxlU2V0UmVzdWx0ID09IFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZCAmJiBydWxlR3JvdXBPcHRpb25zLnJlc3VsdFJlcXVpcmVtZW50cyA9PSBSZXN1bHRzUGFzc1JlcXVpcmVtZW50LkFueVBhc3MpXHJcbiAgICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgIC8vIGlmIGZhaWxlZCwgYW5kIHdlIG5lZWQgYWxsIHRvIHBhc3NcclxuICAgICAgICAgICAgKHJ1bGVTZXRSZXN1bHQgPT0gUHJvY2Vzc1Jlc3VsdFR5cGUuRmFpbGVkICYmIHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQWxsUGFzcylcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNSdWxlR3JvdXA8VD4ocnVsZVNldDogUnVsZVNldDxUPik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlU2V0IGFzIFJ1bGU8VD47XHJcbiAgICAgICAgcmV0dXJuICFydWxlLmZ1bmMgJiYgIXJ1bGUuYXN5bmNGdW5jO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tVGVzdDxUPih0ZXN0OiBUZXN0PFQ+KTogc3RyaW5nW10ge1xyXG4gICAgICAgIGNvbnN0IGNoZWNrRGVwcyA9IHRoaXMuZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tUnVsZVNldDxUPih0ZXN0LmNoZWNrKTtcclxuICAgICAgICBjb25zdCBjb25kaXRpb25EZXBzID0gdGhpcy5nZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21SdWxlU2V0PFQ+KHRlc3QuY29uZGl0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21tb25TdmMudW5pcXVlKGNoZWNrRGVwcy5jb25jYXQoY29uZGl0aW9uRGVwcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tUnVsZVNldDxUPihydWxlU2V0OiBSdWxlU2V0PFQ+KTogc3RyaW5nW10ge1xyXG4gICAgICAgIGlmICghcnVsZVNldCkgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzUnVsZUdyb3VwKHJ1bGVTZXQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVHcm91cCA9IHJ1bGVTZXQgYXMgUnVsZUdyb3VwPFQ+O1xyXG4gICAgICAgICAgICBydWxlR3JvdXAucnVsZXMuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMuY29tbW9uU3ZjLnVuaXF1ZSh0aGlzLmdldERlcGVuZGVuY3lQcm9wZXJ0aWVzRnJvbVJ1bGVTZXQoeCkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBydWxlID0gcnVsZVNldCBhcyBSdWxlPFQ+O1xyXG4gICAgICAgIGlmIChydWxlLm9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShydWxlLm9wdGlvbnMuZGVwZW5kZW5jeVByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMuY29tbW9uU3ZjLnVuaXF1ZShydWxlLm9wdGlvbnMuZGVwZW5kZW5jeVByb3BlcnRpZXMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1vblN2Yy51bmlxdWUocmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldFByb3BlcnR5TWV0YWRhdGEocHJvcGVydGllczogUHJvcGVydHlCYXNlPGFueT5bXSwgbW9kZWxTZXR0aW5nc05hbWU6IHN0cmluZywgY3VycmVudEFic29sdXRlUGF0aDogc3RyaW5nID0gJycpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHJldHVybjtcclxuXHJcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdBYnNvbHV0ZVBhdGggPSB0aGlzLnNldFByb3BlcnR5QWJzb2x1dGVQYXRoKHByb3AsIGN1cnJlbnRBYnNvbHV0ZVBhdGgpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxJbkVtcHR5VGVzdE5hbWVzKHByb3ApO1xyXG4gICAgICAgICAgICBwcm9wLnNldE93bmVyTW9kZWxTZXR0aW5nc05hbWUobW9kZWxTZXR0aW5nc05hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3AucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU1ldGFkYXRhKHByb3AucHJvcGVydGllcywgbW9kZWxTZXR0aW5nc05hbWUsIG5ld0Fic29sdXRlUGF0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5hcnJheUl0ZW1Qcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU1ldGFkYXRhKFtwcm9wLmFycmF5SXRlbVByb3BlcnR5XSwgbW9kZWxTZXR0aW5nc05hbWUsIG5ld0Fic29sdXRlUGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldFByb3BlcnR5QWJzb2x1dGVQYXRoKHByb3BlcnR5OiBQcm9wZXJ0eUJhc2U8YW55PiwgY3VycmVudEFic29sdXRlUGF0aDogc3RyaW5nID0gJycpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGlzQXJyYXlJdGVtUHJvcGVydHkgPSBQcm9wZXJ0eUJhc2UuaXNBcnJheUl0ZW1Qcm9wZXJ0eShwcm9wZXJ0eSk7XHJcbiAgICAgICAgY29uc3QgbmV3QWJzb2x1dGVQYXRoU2VnbWVudCA9IGlzQXJyYXlJdGVtUHJvcGVydHkgPyAnW10nIDogKHByb3BlcnR5IGFzIFByb3BlcnR5PGFueT4pLm5hbWU7XHJcbiAgICAgICAgY29uc3QgaXNBdFJvb3QgPSAhY3VycmVudEFic29sdXRlUGF0aDtcclxuICAgICAgICBjb25zdCBuZXdBYnNvbHV0ZVBhdGggPSBgJHtjdXJyZW50QWJzb2x1dGVQYXRofSR7aXNBdFJvb3QgPyAnJyA6ICcuJ30ke25ld0Fic29sdXRlUGF0aFNlZ21lbnR9YDtcclxuXHJcbiAgICAgICAgLy8gc2V0IGFic29sdXRlIHBhdGggZm9yIHByb3BlcnR5XHJcbiAgICAgICAgcHJvcGVydHkuc2V0QWJzb2x1dGVQYXRoKG5ld0Fic29sdXRlUGF0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdBYnNvbHV0ZVBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBmaWxsSW5FbXB0eVRlc3ROYW1lcyhwcm9wZXJ0eTogUHJvcGVydHlCYXNlPGFueT4pIHtcclxuICAgICAgICBwcm9wZXJ0eS52YWxpZFxyXG4gICAgICAgICAgICAuZmlsdGVyKHRlc3QgPT4gIXRlc3QubmFtZSlcclxuICAgICAgICAgICAgLmZvckVhY2goKHRlc3QsIGkpID0+IHRlc3QubmFtZSA9IGB2YWxpZFRlc3Qke2l9YCk7XHJcblxyXG4gICAgICAgIHByb3BlcnR5LmVkaXRcclxuICAgICAgICAgICAgLmZpbHRlcih0ZXN0ID0+ICF0ZXN0Lm5hbWUpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKCh0ZXN0LCBpKSA9PiB0ZXN0Lm5hbWUgPSBgZWRpdFRlc3Qke2l9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRDb25maWd1cmVkRnVuY1R5cGVzPFQ+KHJ1bGVTZXQ6IFJ1bGVTZXQ8VD4pOiBDb25maWd1cmVkRnVuY1R5cGVzIHtcclxuICAgICAgICBpZiAoIXJ1bGVTZXQpIHJldHVybiB7IHN5bmM6IGZhbHNlLCBhc3luYzogZmFsc2UgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNSdWxlR3JvdXAgPSB0aGlzLmlzUnVsZUdyb3VwKHJ1bGVTZXQpO1xyXG5cclxuICAgICAgICBpZiAoaXNSdWxlR3JvdXApIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZUdyb3VwID0gcnVsZVNldCBhcyBSdWxlR3JvdXA8VD47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBydWxlR3JvdXAucnVsZXNcclxuICAgICAgICAgICAgICAgIC5tYXAocnMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ3VyZWRGdW5jVHlwZXMocnMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3luYzogcmVzdWx0cy5maW5kSW5kZXgoeCA9PiAhIXguc3luYykgPj0gMCxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiByZXN1bHRzLmZpbmRJbmRleCh4ID0+ICEheC5hc3luYykgPj0gMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZVNldCBhcyBSdWxlPFQ+O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3luYzogISFydWxlLmZ1bmMsXHJcbiAgICAgICAgICAgICAgICBhc3luYzogISFydWxlLmFzeW5jRnVuY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIENvbmZpZ3VyZWRGdW5jVHlwZXMge1xyXG4gICAgc3luYzogYm9vbGVhbjtcclxuICAgIGFzeW5jOiBib29sZWFuO1xyXG59XHJcbiJdfQ==