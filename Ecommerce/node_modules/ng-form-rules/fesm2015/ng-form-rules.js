import { InjectionToken, Injectable, Inject, Optional, NgModule } from '@angular/core';
import { forkJoin, of, BehaviorSubject, timer, EMPTY } from 'rxjs';
import { map, flatMap, mergeMap, take, tap, switchMap, distinctUntilChanged, debounce } from 'rxjs/operators';
import { FormGroup, FormBuilder, FormControl, FormArray } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token for providing an array of model settings
 */
let /** @type {?} */ MODEL_SETTINGS_TOKEN = new InjectionToken('ngfr.model-settings');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token for enabling ng-form-rules tracing
 */
let /** @type {?} */ TRACE_SETTINGS_TOKEN = new InjectionToken('ngfr.trace-settings');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TraceService {
    /**
     * @param {?=} doTrace
     */
    constructor(doTrace = false) {
        this.doTrace = doTrace;
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    trace(msg) {
        if (!this.doTrace)
            return;
        const /** @type {?} */ fullMsg = `[NGFR - ${this.getTimeStamp()}] ${msg}`;
        console.log(fullMsg);
    }
    /**
     * @return {?}
     */
    getTimeStamp() {
        return (new Date).toLocaleTimeString();
    }
}
TraceService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
TraceService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRACE_SETTINGS_TOKEN,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CommonService {
    /**
     * Gets unique values from an array
     * @param {?} values Values to get unique items from
     * @return {?} Unique values array
     */
    unique(values) {
        if (!Array.isArray(values))
            return [];
        return Array.from(new Set(values));
    }
    /**
     * Determines if number is zero or greater
     * @param {?} value If number is greater than or equal zero
     * @return {?}
     */
    isZeroOrGreater(value) {
        if (!value && value === 0)
            return true;
        if (!value || typeof value !== "number")
            return false;
        return value > 0;
    }
}
CommonService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Results of executing a collection of tests
 * @template T
 */
class TestResultsBase {
    /**
     * @param {?} results
     */
    constructor(results) {
        this.results = results;
        this.results = this.results || [];
    }
    /**
     * Whether the tests passed
     * @return {?}
     */
    get passed() {
        return !this.failedResults.length;
    }
    /**
     * Array of test results that passed
     * @return {?}
     */
    get passedResults() {
        return this.results.filter(x => !!x.passed && !x.skipped);
    }
    /**
     * Array of test results that failed
     * @return {?}
     */
    get failedResults() {
        return this.results.filter(x => !x.passed);
    }
    /**
     * Array of test results that were skipped
     * @return {?}
     */
    get skippedResults() {
        return this.results.filter(x => !!x.skipped);
    }
    /**
     * Message of the first test that failed
     * @return {?}
     */
    get message() {
        return this.messages[0];
    }
    /**
     * Messages of all failed tests
     * @return {?}
     */
    get messages() {
        const /** @type {?} */ messages = this.failedResults.map(x => x.message);
        return Array.from(new Set(messages));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for a property
 * @abstract
 * @template T
 */
class PropertyBase {
    constructor() {
        this._dependencyPropertySubscriptions = [];
        /**
         * Validation tests
         */
        this.valid = [];
        /**
         * Editability tests
         */
        this.edit = [];
        /**
         * The event name for control to update upon.
         */
        this.updateOn = 'change';
        /**
         * Options for how to respond to value changes on property control and dependency controls
         */
        this.valueChangeOptions = {
            dependencyProperties: {
                valid: { distinctUntilChanged: false, debounceMilliseconds: 0 },
                edit: { distinctUntilChanged: false, debounceMilliseconds: 0 }
            },
            self: {
                asyncValid: { distinctUntilChanged: false, debounceMilliseconds: 0 },
                edit: { distinctUntilChanged: false, debounceMilliseconds: 0 }
            }
        };
    }
    /**
     * Absolute path to the property from root
     * @return {?}
     */
    get absolutePath() {
        return this._absolutePath;
    }
    /**
     * Absolute path to property from root
     * @return {?}
     */
    get dependencyPropertySubscriptions() {
        return this._dependencyPropertySubscriptions;
    }
    /**
     * Absolute path to property from root
     * @return {?}
     */
    get ownerModelSettingsName() {
        return this._ownerModelSettingsName;
    }
    /**
     * Determines if the property is an ArrayItemProperty
     * @template T
     * @param {?} property Property to check
     * @return {?} Whether or not the property is an ArrayItemProperty
     */
    static isArrayItemProperty(property) {
        return !(/** @type {?} */ (property)).name;
    }
    /**
     * DO NOT CALL! Internal use only
     * @param {?} absolutePath Absolute path to the property from the root
     * @return {?}
     */
    setAbsolutePath(absolutePath) {
        this._absolutePath = absolutePath;
    }
    /**
     * DO NOT CALL! Internal use only
     * @param {?} subscription Subscription for the dependency property
     * @return {?}
     */
    addDependencyPropertySubscription(subscription) {
        this._dependencyPropertySubscriptions.push(subscription);
    }
    /**
     * DO NOT CALL! Internal use only
     * @return {?}
     */
    clearDependencyPropertySubscriptions() {
        this.dependencyPropertySubscriptions.forEach(sub$ => sub$.unsubscribe());
        this._dependencyPropertySubscriptions = [];
    }
    /**
     * DO NOT CALL! Internal use only
     * @param {?} name Name of the owner model settings
     * @return {?}
     */
    setOwnerModelSettingsName(name) {
        this._ownerModelSettingsName = name;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const ProcessResultType = {
    Passed: 0,
    Failed: 1,
    Skipped: 2,
};
ProcessResultType[ProcessResultType.Passed] = "Passed";
ProcessResultType[ProcessResultType.Failed] = "Failed";
ProcessResultType[ProcessResultType.Skipped] = "Skipped";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const ResultsPassRequirement = {
    /**
         * All results must pass
         */
    AllPass: 0,
    /**
         * Any results have passed
         */
    AnyPass: 1,
};
ResultsPassRequirement[ResultsPassRequirement.AllPass] = "AllPass";
ResultsPassRequirement[ResultsPassRequirement.AnyPass] = "AnyPass";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Engine that digests model settings and applies their rules appropriately
 */
class RulesEngineService {
    /**
     * @param {?} settings
     * @param {?} traceSvc
     * @param {?} commonSvc
     */
    constructor(settings, traceSvc, commonSvc) {
        this.traceSvc = traceSvc;
        this.commonSvc = commonSvc;
        this.registeredSettings = {};
        if (!Array.isArray(settings))
            return;
        settings.forEach(setting => {
            this.initializeModelSetting(setting);
            this.registeredSettings[setting.name] = setting;
        });
    }
    /**
     * Initializes model settings and prepares them to be used in a form group
     * @param {?} setting Model setting to initialize
     * @return {?}
     */
    initializeModelSetting(setting) {
        this.traceSvc.trace(`Initializing model settings "${setting.name}"`);
        this.setPropertyMetadata(setting.properties, setting.name);
    }
    /**
     * Gets model settings with the provided name
     * @template T
     * @param {?} name Name of model setting
     * @return {?} Model settings with the provided name
     */
    getModelSettings(name) {
        this.traceSvc.trace(`Retrieving model settings "${name}"`);
        const /** @type {?} */ settings = this.registeredSettings[name];
        // create new object
        return settings
            ? Object.assign({}, this.registeredSettings[name])
            : null;
    }
    /**
     * Gets the dependency properties for an array of tests
     * @template T
     * @param {?} tests Tests to get the dependency properties for
     * @return {?} Dependency properties
     */
    getDependencyProperties(tests) {
        if (!tests)
            return [];
        const /** @type {?} */ deps = tests
            .map(t => this.getDependencyPropertiesFromTest(t))
            .reduce((prev, current) => prev.concat(current), []);
        return this.commonSvc.unique(deps);
    }
    /**
     * Gets tests grouped by their sync type (e.g. sync vs. async)
     * @template T
     * @param {?} tests Test to groups
     * @return {?} Tests grouped by sync type
     */
    groupTestsBySyncType(tests) {
        const /** @type {?} */ testGroups = /** @type {?} */ ({
            sync: [],
            async: []
        });
        if (!tests)
            return testGroups;
        tests.forEach(test => {
            const /** @type {?} */ testFuncTypes = /** @type {?} */ ({
                sync: false,
                async: false
            });
            const /** @type {?} */ conditionResults = this.getConfiguredFuncTypes(test.condition);
            const /** @type {?} */ checkResults = this.getConfiguredFuncTypes(test.check);
            testFuncTypes.sync = conditionResults.sync || checkResults.sync;
            testFuncTypes.async = conditionResults.async || checkResults.async;
            // if there is an async func anywhere in the test's rule sets, then it is considered an async test
            if (testFuncTypes.sync && !testFuncTypes.async)
                testGroups.sync.push(test);
            if (testFuncTypes.async)
                testGroups.async.push(test);
        });
        return testGroups;
    }
    /**
     * Runs validation tests
     * @template T
     * @param {?} data Data to run validation tests against
     * @param {?} property Property to run validation tests for
     * @param {?=} state
     * @return {?} Results of validation tests
     */
    validate(data, property, state) {
        return this.runAllTests(data, property.valid, state)
            .pipe(map((results) => {
            results.propertyName = property.absolutePath;
            return /** @type {?} */ (results);
        }));
    }
    /**
     * Runs editability tests
     * @template T
     * @param {?} data Data to run editability tests against
     * @param {?} property Property to run editability tests for
     * * \@returns Results of editability tests
     * @param {?=} state
     * @return {?}
     */
    editable(data, property, state) {
        return this.runAllTests(data, property.edit, state)
            .pipe(map((results) => {
            results.propertyName = property.absolutePath;
            return /** @type {?} */ (results);
        }));
    }
    /**
     * Runs an array of sync tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    runTests(data, tests, state) {
        if (!tests || !tests.length)
            return new TestResultsBase([]);
        const /** @type {?} */ testResults = tests
            .map(t => this.runTest(data, t, state))
            .filter(x => !!x);
        return new TestResultsBase(testResults);
    }
    /**
     * Runs an array of async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    runTestsAsync(data, tests, state) {
        if (!tests || !tests.length)
            return of(new TestResultsBase([]));
        const /** @type {?} */ runTest$ = tests
            .map(test => this.runTestAsync(data, test, state));
        return forkJoin(runTest$)
            .pipe(map(testResults => new TestResultsBase(testResults.filter(x => !!x))));
    }
    /**
     * Runs an array of sync and async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    runAllTests(data, tests, state) {
        if (!tests || !tests.length)
            return of(new TestResultsBase([]));
        const /** @type {?} */ syncGroups = this.groupTestsBySyncType(tests);
        const /** @type {?} */ syncTestResults = of(this.runTests(data, syncGroups.sync, state));
        return syncTestResults.pipe(mergeMap(result => {
            if (!result.passed)
                return of(result);
            return this.runTestsAsync(data, syncGroups.async, state);
        }), take(1));
    }
    /**
     * Performs sync test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    runTest(data, test, state) {
        if (!test)
            return null;
        const /** @type {?} */ passedTestResult = { passed: true, name: test.name, message: null };
        const /** @type {?} */ failedTestResult = { passed: false, name: test.name, message: test.message };
        const /** @type {?} */ skippedTestResult = { passed: true, skipped: true, name: test.name, message: null };
        const /** @type {?} */ conditionsRuleSetResult = this.processRuleSet(data, test.condition, state);
        if (conditionsRuleSetResult === ProcessResultType.Failed)
            return skippedTestResult;
        const /** @type {?} */ checkRuleSetResult = this.processRuleSet(data, test.check, state);
        switch (checkRuleSetResult) {
            case ProcessResultType.Passed:
                return passedTestResult;
            case ProcessResultType.Failed:
                return failedTestResult;
            case ProcessResultType.Skipped:
            default:
                return skippedTestResult;
        }
    }
    /**
     * Performs async test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    runTestAsync(data, test, state) {
        if (!test)
            return of(null);
        const /** @type {?} */ passedTestResult = { passed: true, name: test.name, message: null };
        const /** @type {?} */ failedTestResult = { passed: false, name: test.name, message: test.message };
        const /** @type {?} */ skippedTestResult = { passed: true, skipped: true, name: test.name, message: null };
        const /** @type {?} */ conditionsRuleSetResult$ = this.processRuleSetAsync(data, test.condition, state);
        const /** @type {?} */ checkRuleSetResult$ = this.processRuleSetAsync(data, test.check, state);
        return conditionsRuleSetResult$
            .pipe(flatMap(conditionsRuleSetResult => {
            if (conditionsRuleSetResult === ProcessResultType.Failed)
                return of(skippedTestResult);
            return checkRuleSetResult$
                .pipe(map(checkRuleSetResult => {
                switch (checkRuleSetResult) {
                    case ProcessResultType.Passed:
                        return passedTestResult;
                    case ProcessResultType.Failed:
                        return failedTestResult;
                    case ProcessResultType.Skipped:
                    default:
                        return skippedTestResult;
                }
            }));
        }));
    }
    /**
     * Processes a sync rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    processRuleSet(data, ruleSet, state) {
        if (!ruleSet)
            return ProcessResultType.Skipped;
        const /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        return isRuleGroup
            ? this.processRuleGroup(data, /** @type {?} */ (ruleSet), state)
            : this.processRule(data, /** @type {?} */ (ruleSet), state);
    }
    /**
     * Processes an async rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    processRuleSetAsync(data, ruleSet, state) {
        if (!ruleSet)
            return of(ProcessResultType.Skipped);
        const /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        return isRuleGroup
            ? this.processRuleGroupAsync(data, /** @type {?} */ (ruleSet), state)
            : this.processRuleAsync(data, /** @type {?} */ (ruleSet), state);
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    processRuleGroup(data, ruleGroup, state) {
        if (!ruleGroup.rules)
            return ProcessResultType.Skipped;
        let /** @type {?} */ passedCount = 0;
        let /** @type {?} */ skippedCount = 0;
        for (let /** @type {?} */ i = 0; i < ruleGroup.rules.length; i++) {
            const /** @type {?} */ rule = ruleGroup.rules[i];
            const /** @type {?} */ ruleSetResult = this.processRuleSet(data, rule, state);
            if (this.canShortCircuitRuleGroup(ruleSetResult, ruleGroup))
                return ruleSetResult;
            if (ruleSetResult == ProcessResultType.Passed)
                passedCount++;
            else if (ruleSetResult == ProcessResultType.Skipped)
                skippedCount++;
        }
        // if we skipped them all, then return skipped
        if (skippedCount === ruleGroup.rules.length)
            return ProcessResultType.Skipped;
        // if we got this far, make sure all tests were passed
        return passedCount === ruleGroup.rules.length ? ProcessResultType.Passed : ProcessResultType.Failed;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    processRuleGroupAsync(data, ruleGroup, state) {
        if (!ruleGroup.rules)
            return of(ProcessResultType.Skipped);
        const /** @type {?} */ asyncRuleSetResults$ = ruleGroup.rules.map(x => this.processRuleSetAsync(data, x, state));
        return forkJoin(asyncRuleSetResults$).pipe(map(ruleSetResults => {
            const /** @type {?} */ counts = {
                passed: ruleSetResults.filter(x => x === ProcessResultType.Passed).length,
                failed: ruleSetResults.filter(x => x === ProcessResultType.Failed).length,
                skipped: ruleSetResults.filter(x => x === ProcessResultType.Skipped).length,
            };
            const /** @type {?} */ ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };
            if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass && counts.passed > 0)
                return ProcessResultType.Passed;
            if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass && counts.passed === ruleSetResults.length)
                return ProcessResultType.Passed;
            if (counts.skipped === ruleSetResults.length)
                return ProcessResultType.Skipped;
            return ProcessResultType.Failed;
        }));
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    processRule(data, rule, state) {
        if (!rule.func)
            return ProcessResultType.Skipped;
        const /** @type {?} */ rootData = state ? state.rootData : null;
        return rule.func(data, rootData) ? ProcessResultType.Passed : ProcessResultType.Failed;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    processRuleAsync(data, rule, state) {
        if (!rule.func && !rule.asyncFunc)
            return of(ProcessResultType.Skipped);
        const /** @type {?} */ rootData = state ? state.rootData : null;
        const /** @type {?} */ funcResult = rule.func
            ? of(rule.func(data, rootData))
            : rule.asyncFunc(data, rootData);
        return funcResult
            .pipe(map(passed => passed ? ProcessResultType.Passed : ProcessResultType.Failed));
    }
    /**
     * @template T
     * @param {?} ruleSetResult
     * @param {?} ruleGroup
     * @return {?}
     */
    canShortCircuitRuleGroup(ruleSetResult, ruleGroup) {
        const /** @type {?} */ ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };
        return (
        // it passed, and we only need one to pass
        (ruleSetResult == ProcessResultType.Passed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass)
            ||
                // if failed, and we need all to pass
                (ruleSetResult == ProcessResultType.Failed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass));
    }
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    isRuleGroup(ruleSet) {
        const /** @type {?} */ rule = /** @type {?} */ (ruleSet);
        return !rule.func && !rule.asyncFunc;
    }
    /**
     * @template T
     * @param {?} test
     * @return {?}
     */
    getDependencyPropertiesFromTest(test) {
        const /** @type {?} */ checkDeps = this.getDependencyPropertiesFromRuleSet(test.check);
        const /** @type {?} */ conditionDeps = this.getDependencyPropertiesFromRuleSet(test.condition);
        return this.commonSvc.unique(checkDeps.concat(conditionDeps));
    }
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    getDependencyPropertiesFromRuleSet(ruleSet) {
        if (!ruleSet)
            return [];
        const /** @type {?} */ result = [];
        if (this.isRuleGroup(ruleSet)) {
            const /** @type {?} */ ruleGroup = /** @type {?} */ (ruleSet);
            ruleGroup.rules.forEach(x => {
                result.push(...this.commonSvc.unique(this.getDependencyPropertiesFromRuleSet(x)));
            });
        }
        const /** @type {?} */ rule = /** @type {?} */ (ruleSet);
        if (rule.options && Array.isArray(rule.options.dependencyProperties)) {
            result.push(...this.commonSvc.unique(rule.options.dependencyProperties));
        }
        return this.commonSvc.unique(result);
    }
    /**
     * @param {?} properties
     * @param {?} modelSettingsName
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    setPropertyMetadata(properties, modelSettingsName, currentAbsolutePath = '') {
        if (!properties)
            return;
        properties.forEach(prop => {
            const /** @type {?} */ newAbsolutePath = this.setPropertyAbsolutePath(prop, currentAbsolutePath);
            this.fillInEmptyTestNames(prop);
            prop.setOwnerModelSettingsName(modelSettingsName);
            if (prop.properties) {
                this.setPropertyMetadata(prop.properties, modelSettingsName, newAbsolutePath);
            }
            else if (prop.arrayItemProperty) {
                this.setPropertyMetadata([prop.arrayItemProperty], modelSettingsName, newAbsolutePath);
            }
        });
    }
    /**
     * @param {?} property
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    setPropertyAbsolutePath(property, currentAbsolutePath = '') {
        const /** @type {?} */ isArrayItemProperty = PropertyBase.isArrayItemProperty(property);
        const /** @type {?} */ newAbsolutePathSegment = isArrayItemProperty ? '[]' : (/** @type {?} */ (property)).name;
        const /** @type {?} */ isAtRoot = !currentAbsolutePath;
        const /** @type {?} */ newAbsolutePath = `${currentAbsolutePath}${isAtRoot ? '' : '.'}${newAbsolutePathSegment}`;
        // set absolute path for property
        property.setAbsolutePath(newAbsolutePath);
        return newAbsolutePath;
    }
    /**
     * @param {?} property
     * @return {?}
     */
    fillInEmptyTestNames(property) {
        property.valid
            .filter(test => !test.name)
            .forEach((test, i) => test.name = `validTest${i}`);
        property.edit
            .filter(test => !test.name)
            .forEach((test, i) => test.name = `editTest${i}`);
    }
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    getConfiguredFuncTypes(ruleSet) {
        if (!ruleSet)
            return { sync: false, async: false };
        const /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        if (isRuleGroup) {
            const /** @type {?} */ ruleGroup = /** @type {?} */ (ruleSet);
            const /** @type {?} */ results = ruleGroup.rules
                .map(rs => {
                return this.getConfiguredFuncTypes(rs);
            });
            return {
                sync: results.findIndex(x => !!x.sync) >= 0,
                async: results.findIndex(x => !!x.async) >= 0,
            };
        }
        else {
            const /** @type {?} */ rule = /** @type {?} */ (ruleSet);
            return {
                sync: !!rule.func,
                async: !!rule.asyncFunc
            };
        }
    }
}
RulesEngineService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RulesEngineService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [MODEL_SETTINGS_TOKEN,] },] },
    { type: TraceService, },
    { type: CommonService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * State of an Angular AbstractControl at the time of running a test
 */
class ControlState {
    /**
     * @param {?} control
     */
    constructor(control) {
        this._pristine = control.pristine;
        this._untouched = control.untouched;
    }
    /**
     * Creates a ControlState object based on an Angular control
     * @param {?} control Angular control to generate state from
     * @return {?} Control state base on Angular control
     */
    static create(control) {
        return new ControlState(control);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Builds reactive forms using configured model settings
 */
class ReactiveFormsRuleService {
    /**
     * @param {?} rulesEngineSvc
     * @param {?} formBuilder
     * @param {?} traceSvc
     * @param {?} commonSvc
     */
    constructor(rulesEngineSvc, formBuilder, traceSvc, commonSvc) {
        this.rulesEngineSvc = rulesEngineSvc;
        this.formBuilder = formBuilder;
        this.traceSvc = traceSvc;
        this.commonSvc = commonSvc;
    }
    /**
     * Gets model settings with the provided name
     * @template T
     * @param {?} name Name of model setting
     * @return {?} Model settings with the provided name
     */
    getModelSettings(name) {
        return this.rulesEngineSvc.getModelSettings(name);
    }
    /**
     * Creates a form group using an instance of model settings
     * @template T
     * @param {?} modelSettings Name of the model setting or an instance of model settings to use
     * @param {?=} initialValue Initial data to set the form values to
     * @return {?} Form group created according to defined model settings
     */
    createFormGroup(modelSettings, initialValue) {
        let /** @type {?} */ settings;
        if (typeof modelSettings === "string") {
            settings = this.rulesEngineSvc.getModelSettings(/** @type {?} */ (modelSettings));
            if (!settings)
                throw new Error(`No model setting found with the name "${modelSettings}"`);
        }
        else {
            if (!modelSettings)
                throw new Error(`Adhoc model setting provided is invalid`);
            settings = /** @type {?} */ (modelSettings);
            this.rulesEngineSvc.initializeModelSetting(settings);
        }
        this.traceSvc.trace(`Creating form group using model settings "${settings.name}"`);
        const /** @type {?} */ formGroup = this.buildGroup(settings.properties, initialValue);
        this.traceSvc.trace(`Setting up dependency subscriptions`);
        this.resetDependencySubscriptions(formGroup, settings.properties);
        this.traceSvc.trace(`Patching form group with initial value`);
        this.triggerValueChange(formGroup);
        this.traceSvc.trace(`Attaching model settings to form`);
        this.attachModelSettingsToForm(formGroup, settings);
        return formGroup;
    }
    /**
     * Adds an array item property to an existing form array
     * @template T
     * @param {?} property ArrayItemProperty to for the array item to be added
     * @param {?} parentFormArray The parent FormArray
     * @param {?=} initialValue Initial value of the form array item
     * @param {?=} options Options for adding new array item property
     * @return {?}
     */
    addArrayItemPropertyControl(property, parentFormArray, initialValue, options) {
        const /** @type {?} */ control = this.buildAbstractControl(property, initialValue);
        const /** @type {?} */ willBeLastItem = !options || !this.commonSvc.isZeroOrGreater(options.index) || options.index >= parentFormArray.length;
        if (willBeLastItem)
            parentFormArray.push(control);
        else
            parentFormArray.insert(options.index, control);
        const /** @type {?} */ modelSettings = this.getModelSettingsFromForm(/** @type {?} */ (parentFormArray.root));
        this.resetDependencySubscriptions(parentFormArray.root, modelSettings.properties);
        // we need to do this because the item could have been added at any index in the array, and we need
        // trigger a value change to trigger any dependency propertiy valdidations
        this.triggerValueChange(parentFormArray);
    }
    /**
     * Extends validators generated by ng-form-rules with your own validators
     * @param {?} control Control to extends the validators for
     * @param {?} validator Validator to add
     * @return {?}
     */
    extendValidator(control, validator) {
        if (!validator)
            return;
        const /** @type {?} */ validatorArray = Array.isArray(validator) ? validator : [validator];
        control.setValidators([control.validator, ...validatorArray]
            .filter(validatorFn => !!validatorFn));
    }
    /**
     * Extends async validators generated by ng-form-rules with your own async validators
     * @param {?} control Control to extends the async validators for
     * @param {?} asyncValidator Async validator to add
     * @return {?}
     */
    extendAsyncValidator(control, asyncValidator) {
        if (!asyncValidator)
            return;
        const /** @type {?} */ asyncValidatorArray = Array.isArray(asyncValidator) ? asyncValidator : [asyncValidator];
        control.setAsyncValidators([control.asyncValidator, ...asyncValidatorArray]
            .filter(asyncValidatorFn => !!asyncValidatorFn));
    }
    /**
     * @template T
     * @param {?} property
     * @param {?=} initialValue
     * @return {?}
     */
    buildAbstractControl(property, initialValue) {
        let /** @type {?} */ control;
        if (property.arrayItemProperty)
            control = this.buildArray(property.arrayItemProperty, initialValue, property.updateOn);
        else if (property.properties)
            control = this.buildGroup(property.properties, initialValue, property.updateOn);
        else
            control = this.buildControl(initialValue, property.updateOn);
        // setup validation tests on value change
        control.setValidators(this.buildValidatorFunction(property));
        control.setAsyncValidators(this.buildAsyncValidatorFunction(property));
        // setup edit tests on value change
        control.valueChanges
            .pipe(this.applyValueChangeOptions(property.valueChangeOptions.self.edit))
            .subscribe(value => {
            this.persistEditTests(control, property);
        });
        return control;
    }
    /**
     * @template T
     * @param {?} initialValue
     * @param {?=} updateOn
     * @return {?}
     */
    buildControl(initialValue, updateOn) {
        return new FormControl(initialValue, { updateOn: updateOn });
    }
    /**
     * @template T
     * @param {?} properties
     * @param {?} initialValue
     * @param {?=} updateOn
     * @return {?}
     */
    buildGroup(properties, initialValue, updateOn) {
        const /** @type {?} */ formGroup = new FormGroup({}, { updateOn: updateOn });
        (properties || []).forEach(p => {
            const /** @type {?} */ propertyValue = initialValue ? initialValue[p.name] : null;
            const /** @type {?} */ ctrl = this.buildAbstractControl(p, propertyValue);
            formGroup.addControl(p.name, ctrl);
        });
        return formGroup;
    }
    /**
     * @template T
     * @param {?} property
     * @param {?} initialValue
     * @param {?=} updateOn
     * @return {?}
     */
    buildArray(property, initialValue, updateOn) {
        initialValue = Array.isArray(initialValue) ? initialValue : [];
        return new FormArray(initialValue.map(v => this.buildAbstractControl(property, v)), { updateOn: updateOn });
    }
    /**
     * @template T
     * @param {?} property
     * @return {?}
     */
    buildValidatorFunction(property) {
        const /** @type {?} */ syncGroups = this.rulesEngineSvc.groupTestsBySyncType(property.valid);
        if (!syncGroups.sync.length)
            return null;
        return (control) => {
            const /** @type {?} */ controlContextValues = this.getControlContextValues(control, property);
            const /** @type {?} */ testResults = this.rulesEngineSvc
                .runTests(controlContextValues.relative, syncGroups.sync, {
                rootData: controlContextValues.root,
                controlState: ControlState.create(control)
            });
            if (testResults.results.length) {
                this.traceSvc.trace(`Validated property "${property.absolutePath}". ` +
                    this.buildTestResultStatsString(testResults));
            }
            return this.mapToReactiveFormsValidationErrors(testResults);
        };
    }
    /**
     * @template T
     * @param {?} property
     * @return {?}
     */
    buildAsyncValidatorFunction(property) {
        const /** @type {?} */ rawAsyncFunc = this.buildAsyncValidatorFunctionRaw(property);
        if (!rawAsyncFunc)
            return null;
        const /** @type {?} */ values = new BehaviorSubject(null);
        const /** @type {?} */ valid$ = values.pipe(this.applyAsyncValidValueChangeOptions(property.valueChangeOptions.self.asyncValid), switchMap(x => {
            // pass through means we did not execute the ng-form-rules async tests
            if (x.passthrough) {
                const /** @type {?} */ currentErrors = x.control.errors || {};
                const /** @type {?} */ lastNgFormRulesErrors = this.getLastErrorForControl(x.control);
                // return the last ng-form-rules errors (if any) alongside non ng-form-rules errors.
                // this handles scenario where debounce and distinct are used and state goes from:
                //    invalid -> make changes and back them out -> valid
                return of(Object.assign(currentErrors, /** @type {?} */ ({ ngFormRules: lastNgFormRulesErrors })));
            }
            else {
                return rawAsyncFunc(x.control);
            }
        }), take(1));
        return (control) => {
            values.next(control);
            return valid$;
        };
    }
    /**
     * @template T
     * @param {?} property
     * @return {?}
     */
    buildAsyncValidatorFunctionRaw(property) {
        const /** @type {?} */ syncGroups = this.rulesEngineSvc.groupTestsBySyncType(property.valid);
        if (!syncGroups.async.length)
            return null;
        return (control) => {
            const /** @type {?} */ controlContextValues = this.getControlContextValues(control, property);
            return this.rulesEngineSvc.runTestsAsync(controlContextValues.relative, syncGroups.async, {
                rootData: controlContextValues.root,
                controlState: ControlState.create(control)
            }).pipe(tap(testResults => {
                if (testResults.results.length) {
                    this.traceSvc.trace(`Validated (async) property "${property.absolutePath}". ` +
                        this.buildTestResultStatsString(testResults));
                }
            }), map(this.mapToReactiveFormsValidationErrors), tap(x => this.setLastErrorForControl(control, (x || {})["ngFormRules"])));
        };
    }
    /**
     * @template T
     * @param {?} parentControl
     * @param {?} properties
     * @return {?}
     */
    resetDependencySubscriptions(parentControl, properties) {
        this.removeDependencySubscriptions(properties);
        this.addDependencySubscriptions(parentControl, properties);
    }
    /**
     * @template T
     * @param {?} properties
     * @return {?}
     */
    removeDependencySubscriptions(properties) {
        (properties || []).forEach(property => {
            property.clearDependencyPropertySubscriptions();
            if (property.properties) {
                this.removeDependencySubscriptions(property.properties);
            }
            if (property.arrayItemProperty) {
                this.removeDependencySubscriptions([property.arrayItemProperty]);
            }
        });
    }
    /**
     * @template T
     * @param {?} parentControl
     * @param {?} properties
     * @param {?=} arrayIndex
     * @return {?}
     */
    addDependencySubscriptions(parentControl, properties, arrayIndex) {
        (properties || []).forEach(property => {
            const /** @type {?} */ propertyControl = this.getPropertyFromParent(parentControl, property, arrayIndex);
            if (!propertyControl)
                return;
            this.setupEditabilityDependencySubscriptions(propertyControl, parentControl, property);
            this.setupValidationDependencySubscriptions(propertyControl, parentControl, property);
            if (property.properties) {
                this.addDependencySubscriptions(propertyControl, property.properties);
            }
            if (property.arrayItemProperty) {
                // if there is an arrayItemProperty we know that we are working with a FormArray control
                const /** @type {?} */ formArrayControl = (/** @type {?} */ (propertyControl));
                for (let /** @type {?} */ i = 0; i < formArrayControl.length; i++) {
                    this.addDependencySubscriptions(formArrayControl, [property.arrayItemProperty], i);
                }
            }
        });
    }
    /**
     * @template T
     * @param {?} propertyControl
     * @param {?} parentControl
     * @param {?} property
     * @return {?}
     */
    setupValidationDependencySubscriptions(propertyControl, parentControl, property) {
        const /** @type {?} */ dependencyPropNames = this.rulesEngineSvc.getDependencyProperties(property.valid);
        dependencyPropNames.forEach(d => {
            const /** @type {?} */ dependencyControl = this.findControlRelatively(parentControl, d);
            if (!dependencyControl)
                return;
            const /** @type {?} */ sub$ = dependencyControl.valueChanges
                .pipe(this.applyValueChangeOptions(property.valueChangeOptions.dependencyProperties.valid))
                .subscribe(value => {
                this.setForceAsyncValidationTestForControl(propertyControl, true);
                propertyControl.updateValueAndValidity({ onlySelf: true, emitEvent: false });
            });
            property.addDependencyPropertySubscription(sub$);
        });
    }
    /**
     * @template T
     * @param {?} propertyControl
     * @param {?} parentControl
     * @param {?} property
     * @return {?}
     */
    setupEditabilityDependencySubscriptions(propertyControl, parentControl, property) {
        const /** @type {?} */ dependencyPropNames = this.rulesEngineSvc.getDependencyProperties(property.edit);
        dependencyPropNames.forEach(dpn => {
            const /** @type {?} */ dependencyControl = this.findControlRelatively(parentControl, dpn);
            if (!dependencyControl)
                return;
            // setup control to perform edit tests when dependency property changes
            const /** @type {?} */ sub$ = dependencyControl.valueChanges
                .pipe(this.applyValueChangeOptions(property.valueChangeOptions.dependencyProperties.edit))
                .subscribe(value => {
                this.persistEditTests(propertyControl, property);
            });
            property.addDependencyPropertySubscription(sub$);
        });
    }
    /**
     * @template T
     * @param {?} propertyControl
     * @param {?} property
     * @return {?}
     */
    persistEditTests(propertyControl, property) {
        const /** @type {?} */ controlContextValues = this.getControlContextValues(propertyControl, property);
        this.rulesEngineSvc.editable(controlContextValues.relative, property, {
            rootData: controlContextValues.root,
            controlState: ControlState.create(propertyControl)
        }).subscribe(testResults => {
            if (testResults.results.length) {
                this.traceSvc.trace(`Editable property "${property.absolutePath}". ` +
                    this.buildTestResultStatsString(testResults));
            }
            if (testResults.passed && propertyControl.disabled)
                propertyControl.enable({ emitEvent: false });
            else if (!testResults.passed && propertyControl.enabled)
                propertyControl.disable({ emitEvent: false });
        });
    }
    /**
     * @param {?} valueChangeOptions
     * @return {?}
     */
    applyAsyncValidValueChangeOptions(valueChangeOptions) {
        return (source$) => {
            let /** @type {?} */ lastValue;
            let /** @type {?} */ isForce;
            return source$.pipe(tap(control => {
                isForce = this.doesControlHaveForcedAsyncValidation(control);
                this.setForceAsyncValidationTestForControl(control, false);
            }), debounce(x => {
                return isForce || valueChangeOptions.debounceMilliseconds > 0
                    ? timer(valueChangeOptions.debounceMilliseconds)
                    : EMPTY;
            }), map(control => {
                return /** @type {?} */ ({
                    control: control,
                    passthrough: !(control.value !== lastValue || !valueChangeOptions.distinctUntilChanged || isForce)
                });
            }), tap(x => {
                if (!x.passthrough)
                    lastValue = x.control.value;
            }));
        };
    }
    /**
     * @param {?} valueChangeOptions
     * @return {?}
     */
    applyValueChangeOptions(valueChangeOptions) {
        return (source$) => {
            return source$.pipe(debounce(x => {
                return valueChangeOptions.debounceMilliseconds > 0
                    ? timer(valueChangeOptions.debounceMilliseconds)
                    : EMPTY;
            }), valueChangeOptions.distinctUntilChanged ? distinctUntilChanged() : tap());
        };
    }
    /**
     * @template T
     * @param {?} control
     * @param {?} property
     * @return {?}
     */
    getControlContextValues(control, property) {
        const /** @type {?} */ rootValue = (/** @type {?} */ (control.root)).getRawValue();
        // use the control value if an array item, otherwise use the parent control
        const /** @type {?} */ relativeValue = PropertyBase.isArrayItemProperty(property)
            ? control.value
            : control.parent.getRawValue();
        return {
            root: rootValue,
            relative: relativeValue
        };
    }
    /**
     * @template T
     * @param {?} parentControl
     * @param {?} property
     * @param {?=} arrayIndex
     * @return {?}
     */
    getPropertyFromParent(parentControl, property, arrayIndex) {
        return PropertyBase.isArrayItemProperty(property)
            ? (/** @type {?} */ (parentControl)).at(arrayIndex)
            : parentControl.get((/** @type {?} */ (property)).name);
    }
    /**
     * @template T
     * @param {?} testResults
     * @return {?}
     */
    mapToReactiveFormsValidationErrors(testResults) {
        // if passed, Angular reactive forms wants us to return null, otherwise return an object with the validation info
        if (!testResults || testResults.passed)
            return null;
        const /** @type {?} */ failed = {};
        testResults.failedResults.forEach(test => {
            failed[test.name] = { message: test.message };
        });
        return {
            ngFormRules: /** @type {?} */ ({
                message: testResults.message,
                failed: failed
            })
        };
    }
    /**
     * @param {?} control
     * @param {?} path
     * @return {?}
     */
    findControlRelatively(control, path) {
        const /** @type {?} */ relativePaths = this.buildControlRelativePathArray(path);
        if (!relativePaths.length)
            return null;
        let /** @type {?} */ result;
        relativePaths.forEach(pathSegment => {
            result = this.getControlByPathSegment(result || control, pathSegment);
            if (!result)
                return;
        });
        return result;
    }
    /**
     * @param {?} relativePath
     * @return {?}
     */
    buildControlRelativePathArray(relativePath) {
        const /** @type {?} */ result = [];
        if (!relativePath || typeof relativePath !== "string")
            return result;
        // takes care of './', '../', and '/'
        const /** @type {?} */ slashSeparated = relativePath.split("/");
        slashSeparated.forEach(slashItem => {
            const /** @type {?} */ dotSeparated = slashItem.split(".")
                .filter(dotItem => !!dotItem);
            if (dotSeparated.length)
                result.push(...dotSeparated);
            else
                result.push(slashItem);
        });
        return result;
    }
    /**
     * @param {?} control
     * @param {?} pathSegment
     * @return {?}
     */
    getControlByPathSegment(control, pathSegment) {
        switch (pathSegment) {
            case "":
                return control.root;
            case "..":
                return control.parent;
            case ".":
                return control;
            default:
                return control.get(pathSegment);
        }
    }
    /**
     * @template T
     * @param {?} testResults
     * @return {?}
     */
    buildTestResultStatsString(testResults) {
        return `Executed ${testResults.results.length} tests ` +
            `(${testResults.passedResults.length} PASS | ` +
            `${testResults.failedResults.length} FAIL | `
            + `${testResults.skippedResults.length} SKIP)`;
    }
    /**
     * @template T
     * @param {?} formGroup
     * @param {?} modelSettings
     * @return {?}
     */
    attachModelSettingsToForm(formGroup, modelSettings) {
        formGroup[ReactiveFormsRuleService.FORM_MODEL_SETTINGS_PROPERTY_NAME] = modelSettings;
    }
    /**
     * @template T
     * @param {?} formGroup
     * @return {?}
     */
    getModelSettingsFromForm(formGroup) {
        return /** @type {?} */ (formGroup[ReactiveFormsRuleService.FORM_MODEL_SETTINGS_PROPERTY_NAME]);
    }
    /**
     * @param {?} control
     * @param {?} force
     * @return {?}
     */
    setForceAsyncValidationTestForControl(control, force) {
        control[ReactiveFormsRuleService.FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME] = force;
    }
    /**
     * @param {?} control
     * @param {?} errors
     * @return {?}
     */
    setLastErrorForControl(control, errors) {
        control[ReactiveFormsRuleService.CONTROL_LAST_ERROR] = errors;
    }
    /**
     * @param {?} control
     * @return {?}
     */
    getLastErrorForControl(control) {
        return control[ReactiveFormsRuleService.CONTROL_LAST_ERROR];
    }
    /**
     * @param {?} control
     * @return {?}
     */
    doesControlHaveForcedAsyncValidation(control) {
        return !!(control[ReactiveFormsRuleService.FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME]);
    }
    /**
     * @param {?} control
     * @return {?}
     */
    triggerValueChange(control) {
        control.patchValue(control.value);
    }
}
ReactiveFormsRuleService.FORM_MODEL_SETTINGS_PROPERTY_NAME = 'ngFormRulesModelSetting';
ReactiveFormsRuleService.FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME = 'ngFormRulesForceAsyncValidTestRun';
ReactiveFormsRuleService.CONTROL_LAST_ERROR = 'ngFormRulesControlLastError';
ReactiveFormsRuleService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ReactiveFormsRuleService.ctorParameters = () => [
    { type: RulesEngineService, },
    { type: FormBuilder, },
    { type: TraceService, },
    { type: CommonService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UtilsModule {
}
UtilsModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                providers: [
                    TraceService,
                    CommonService
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RulesEngineModule {
}
RulesEngineModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UtilsModule
                ],
                providers: [
                    RulesEngineService,
                    ReactiveFormsRuleService
                ],
                declarations: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Main module for ng-form-rules
 */
class FormRulesModule {
}
FormRulesModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RulesEngineModule,
                ],
                declarations: [],
                exports: [
                    RulesEngineModule,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Non-array item property
 * @template T
 */
class Property extends PropertyBase {
    /**
     * @param {?} name
     */
    constructor(name) {
        super();
        this._name = name;
    }
    /**
     * Name of the property
     * @return {?}
     */
    get name() {
        return this._name;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A property representing an array item (e.g. an array of Address objects)
 * @template T
 */
class ArrayItemProperty extends PropertyBase {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Utility class for building model settings
 */
class ModelSettingsBuilder {
    /**
     * Creates a property
     * @template T
     * @param {?} propertyName Property name
     * @param {?=} extend Function to extend the property
     * @return {?} Created property
     */
    property(propertyName, extend) {
        if (!propertyName || typeof propertyName !== 'string')
            throw Error('Invalid property name');
        const /** @type {?} */ property = new Property(propertyName);
        if (extend)
            extend(property);
        return property;
    }
    /**
     * Creates an array item property
     * @template T
     * @param {?=} extend Function to extend the array item property
     * @return {?} Created array item property
     */
    arrayItemProperty(extend) {
        const /** @type {?} */ property = new ArrayItemProperty();
        if (extend)
            extend(property);
        return property;
    }
    /**
     * Creates a validation test
     * @template T
     * @param {?} message Message when the test fails
     * @param {?} check Check rule set for the test
     * @param {?=} condition Condition rule set for the test
     * @return {?} Created validation test
     */
    validTest(message, check, condition) {
        return this.validNamedTest(null, message, check, condition);
    }
    /**
     * Creates a named validation test
     * @template T
     * @param {?} name Name of the test
     * @param {?} message Message when the test fails
     * @param {?} check Check rule set for the test
     * @param {?=} condition Condition rule set for the test
     * @return {?} Created named validation test
     */
    validNamedTest(name, message, check, condition) {
        return /** @type {?} */ ({
            name: name,
            message: message,
            check: check,
            condition: condition
        });
    }
    /**
     * Creates an edit test
     * @template T
     * @param {?} check Check rule set for the test
     * @param {?=} condition Condition rule set for the test
     * @return {?} Created edit test
     */
    editTest(check, condition) {
        return this.editNamedTest(null, check, condition);
    }
    /**
     * Creates a named edit test
     * @template T
     * @param {?} name Name of the test
     * @param {?} check Check rule set for the test
     * @param {?=} condition Condition rule set for the test
     * @return {?} Created named edit test
     */
    editNamedTest(name, check, condition) {
        return /** @type {?} */ ({
            name: name,
            check: check,
            condition: condition
        });
    }
    /**
     * Creates a rule
     * @template T, R
     * @param {?} func Function for the rule
     * @param {?=} options Additional rule options
     * @return {?} Created rule
     */
    rule(func, options) {
        return this.ruleCombo(func, null, options);
    }
    /**
     * Creates an async rule
     * @template T, R
     * @param {?} asyncFunc Async function for the rule
     * @param {?=} options Additional rule options
     * @return {?} Created rule
     */
    ruleAsync(asyncFunc, options) {
        return this.ruleCombo(null, asyncFunc, options);
    }
    /**
     * Creates a combo rule that has both syncronous and async functions
     * @template T, R
     * @param {?} func Function for the rule
     * @param {?} asyncFunc Async function for the rule
     * @param {?=} options Additional rule options
     * @return {?} Created rule
     */
    ruleCombo(func, asyncFunc, options) {
        return /** @type {?} */ ({
            func: func,
            asyncFunc: asyncFunc,
            options: options
        });
    }
    /**
     * Creates a rule group
     * @template T
     * @param {?} ruleSets Rule sets for the rule group
     * @param {?=} options Additional rule group options
     * @return {?} Created rule group
     */
    ruleGroup(ruleSets, options) {
        return /** @type {?} */ ({
            rules: ruleSets,
            options: options || { resultRequirements: ResultsPassRequirement.AllPass }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for model settings
 * @abstract
 * @template T
 */
class AbstractModelSettings {
    /**
     * Creates model settings
     * @param {?} name Name of the model settings
     */
    constructor(name) {
        this.builder = new ModelSettingsBuilder();
        this._name = name;
        this.properties = this.buildProperties() || [];
    }
    /**
     * Name of the model setting
     * @return {?}
     */
    get name() {
        return this._name;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class PropertyTestResults extends TestResultsBase {
    /**
     * @param {?} propertyName
     * @param {?} results
     */
    constructor(propertyName, results) {
        super(results);
        this.propertyName = propertyName;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Class for creating adhoc (non-registered) model settings
 * @template T
 */
class AdhocModelSettings extends AbstractModelSettings {
    constructor() {
        // since these settings are not registered, just use a static name
        super('adhoc');
    }
    /**
     * Creates model settings
     * @template T
     * @param {?} propertyBuilderFunc Function that takes a ModelSettingsBuilder and uses it to return an array of properties
     * @return {?} Model settings configured with properties returned from the 'propertyBuilderFunc' function parameter
     */
    static create(propertyBuilderFunc) {
        const /** @type {?} */ instance = new AdhocModelSettings();
        instance.properties = !!propertyBuilderFunc ? propertyBuilderFunc(instance.builder) || [] : [];
        return instance;
    }
    /**
     * @return {?}
     */
    buildProperties() {
        // this is just needed to satisfy the AbstractModelSettings<T> contract
        return [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Options for how and when to process value changes in a form control
 */
class ValueChangeOptions {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { FormRulesModule, MODEL_SETTINGS_TOKEN, TRACE_SETTINGS_TOKEN, ReactiveFormsRuleService, AbstractModelSettings, ArrayItemProperty, ControlState, PropertyBase, PropertyTestResults, Property, TestResultsBase, AdhocModelSettings, ValueChangeOptions, ResultsPassRequirement, ModelSettingsBuilder, RulesEngineModule as a, RulesEngineService as e, CommonService as d, TraceService as c, UtilsModule as b };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctZm9ybS1ydWxlcy5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmctZm9ybS1ydWxlcy9saWIvZm9ybS1ydWxlcy9pbmplY3Rpb24tdG9rZW5zL21vZGVsLXNldHRpbmdzLnRva2VuLnRzIiwibmc6Ly9uZy1mb3JtLXJ1bGVzL2xpYi9mb3JtLXJ1bGVzL2luamVjdGlvbi10b2tlbnMvdHJhY2Utc2V0dGluZ3MudG9rZW4udHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL3V0aWxzL3RyYWNlL3RyYWNlLnNlcnZpY2UudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL3V0aWxzL2NvbW1vbi9jb21tb24uc2VydmljZS50cyIsIm5nOi8vbmctZm9ybS1ydWxlcy9saWIvZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1yZXN1bHRzLWJhc2UudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL2Zvcm0tcnVsZXMvbW9kZWxzL3Byb3BlcnR5LWJhc2UudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL3J1bGVzLWVuZ2luZS9zZXJ2aWNlcy9ydWxlcy1lbmdpbmUvcnVsZXMtZW5naW5lLnNlcnZpY2UudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL2Zvcm0tcnVsZXMvbW9kZWxzL2NvbnRyb2wtc3RhdGUudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL3J1bGVzLWVuZ2luZS9zZXJ2aWNlcy9yZWFjdGl2ZS1mb3Jtcy1ydWxlL3JlYWN0aXZlLWZvcm1zLXJ1bGUuc2VydmljZS50cyIsIm5nOi8vbmctZm9ybS1ydWxlcy9saWIvdXRpbHMvdXRpbHMubW9kdWxlLnRzIiwibmc6Ly9uZy1mb3JtLXJ1bGVzL2xpYi9ydWxlcy1lbmdpbmUvcnVsZXMtZW5naW5lLm1vZHVsZS50cyIsIm5nOi8vbmctZm9ybS1ydWxlcy9saWIvZm9ybS1ydWxlcy9mb3JtLXJ1bGVzLm1vZHVsZS50cyIsIm5nOi8vbmctZm9ybS1ydWxlcy9saWIvZm9ybS1ydWxlcy9tb2RlbHMvcHJvcGVydHkudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL2Zvcm0tcnVsZXMvbW9kZWxzL2FycmF5LWl0ZW0tcHJvcGVydHkudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL2Zvcm0tcnVsZXMvaGVscGVyL21vZGVsLXNldHRpbmdzLWJ1aWxkZXIudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL2Zvcm0tcnVsZXMvbW9kZWxzL2Fic3RyYWN0LW1vZGVsLXNldHRpbmdzLnRzIiwibmc6Ly9uZy1mb3JtLXJ1bGVzL2xpYi9mb3JtLXJ1bGVzL21vZGVscy9wcm9wZXJ0eS10ZXN0LXJlc3VsdC50cyIsIm5nOi8vbmctZm9ybS1ydWxlcy9saWIvZm9ybS1ydWxlcy9tb2RlbHMvYWRob2MtbW9kZWwtc2V0dGluZ3MudHMiLCJuZzovL25nLWZvcm0tcnVsZXMvbGliL2Zvcm0tcnVsZXMvbW9kZWxzL3ZhbHVlLWNoYW5nZS1vcHRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuXHJcbi8qKlxyXG4gKiBJbmplY3Rpb24gdG9rZW4gZm9yIHByb3ZpZGluZyBhbiBhcnJheSBvZiBtb2RlbCBzZXR0aW5nc1xyXG4gKi9cclxuZXhwb3J0IGxldCBNT0RFTF9TRVRUSU5HU19UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+KCduZ2ZyLm1vZGVsLXNldHRpbmdzJyk7IiwiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5cclxuLyoqXHJcbiAqIEluamVjdGlvbiB0b2tlbiBmb3IgZW5hYmxpbmcgbmctZm9ybS1ydWxlcyB0cmFjaW5nXHJcbiAqL1xyXG5leHBvcnQgbGV0IFRSQUNFX1NFVFRJTkdTX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuPHN0cmluZz4oJ25nZnIudHJhY2Utc2V0dGluZ3MnKTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRSQUNFX1NFVFRJTkdTX1RPS0VOIH0gZnJvbSAnLi4vLi4vZm9ybS1ydWxlcy9pbmplY3Rpb24tdG9rZW5zL3RyYWNlLXNldHRpbmdzLnRva2VuJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFRyYWNlU2VydmljZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRSQUNFX1NFVFRJTkdTX1RPS0VOKSBwcml2YXRlIGRvVHJhY2U6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICAgKSB7XHJcbiAgICB9XHJcblxyXG4gICAgdHJhY2UobXNnOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9UcmFjZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBmdWxsTXNnID0gYFtOR0ZSIC0gJHt0aGlzLmdldFRpbWVTdGFtcCgpfV0gJHttc2d9YDtcclxuICAgICAgICBjb25zb2xlLmxvZyhmdWxsTXNnKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFRpbWVTdGFtcCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiAobmV3IERhdGUpLnRvTG9jYWxlVGltZVN0cmluZygpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIENvbW1vblNlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHVuaXF1ZSB2YWx1ZXMgZnJvbSBhbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHZhbHVlcyBWYWx1ZXMgdG8gZ2V0IHVuaXF1ZSBpdGVtcyBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyBVbmlxdWUgdmFsdWVzIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHVuaXF1ZSh2YWx1ZXM6IGFueVtdKTogYW55W10ge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIG51bWJlciBpcyB6ZXJvIG9yIGdyZWF0ZXJcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBJZiBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHplcm9cclxuICAgICAqL1xyXG4gICAgaXNaZXJvT3JHcmVhdGVyKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoIXZhbHVlICYmIHZhbHVlID09PSAwKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID4gMDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUZXN0UmVzdWx0IH0gZnJvbSBcIi4vdGVzdC1yZXN1bHRcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXN1bHRzIG9mIGV4ZWN1dGluZyBhIGNvbGxlY3Rpb24gb2YgdGVzdHNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUZXN0UmVzdWx0c0Jhc2U8VD4ge1xyXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlc3VsdHM6IFRlc3RSZXN1bHQ8VD5bXSkge1xyXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMucmVzdWx0cyB8fCBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIHRlc3RzIHBhc3NlZFxyXG4gICAgICovXHJcbiAgICBnZXQgcGFzc2VkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5mYWlsZWRSZXN1bHRzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHRlc3QgcmVzdWx0cyB0aGF0IHBhc3NlZFxyXG4gICAgICovXHJcbiAgICBnZXQgcGFzc2VkUmVzdWx0cygpOiBUZXN0UmVzdWx0PFQ+W10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMuZmlsdGVyKHggPT4gISF4LnBhc3NlZCAmJiAheC5za2lwcGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHRlc3QgcmVzdWx0cyB0aGF0IGZhaWxlZFxyXG4gICAgICovXHJcbiAgICBnZXQgZmFpbGVkUmVzdWx0cygpOiBUZXN0UmVzdWx0PFQ+W10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMuZmlsdGVyKHggPT4gIXgucGFzc2VkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHRlc3QgcmVzdWx0cyB0aGF0IHdlcmUgc2tpcHBlZFxyXG4gICAgICovXHJcbiAgICBnZXQgc2tpcHBlZFJlc3VsdHMoKTogVGVzdFJlc3VsdDxUPltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLmZpbHRlcih4ID0+ICEheC5za2lwcGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lc3NhZ2Ugb2YgdGhlIGZpcnN0IHRlc3QgdGhhdCBmYWlsZWRcclxuICAgICAqL1xyXG4gICAgZ2V0IG1lc3NhZ2UoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1swXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lc3NhZ2VzIG9mIGFsbCBmYWlsZWQgdGVzdHNcclxuICAgICAqL1xyXG4gICAgZ2V0IG1lc3NhZ2VzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuZmFpbGVkUmVzdWx0cy5tYXAoeCA9PiB4Lm1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobWVzc2FnZXMpKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IFRlc3QgfSBmcm9tIFwiLi90ZXN0XCI7XHJcbmltcG9ydCB7IFByb3BlcnR5IH0gZnJvbSBcIi4vcHJvcGVydHlcIjtcclxuaW1wb3J0IHsgQXJyYXlJdGVtUHJvcGVydHkgfSBmcm9tIFwiLi9hcnJheS1pdGVtLXByb3BlcnR5XCI7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gXCJyeGpzXCI7XHJcbmltcG9ydCB7IFZhbHVlQ2hhbmdlT3B0aW9ucyB9IGZyb20gXCIuL3ZhbHVlLWNoYW5nZS1vcHRpb25zXCI7XHJcbmltcG9ydCB7IFVwZGF0ZU9uIH0gZnJvbSBcIi4vdXBkYXRlLW9uXCI7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSBwcm9wZXJ0eVxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFByb3BlcnR5QmFzZTxUPiB7XHJcbiAgICBwcml2YXRlIF9hYnNvbHV0ZVBhdGg6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2RlcGVuZGVuY3lQcm9wZXJ0eVN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XHJcbiAgICBwcml2YXRlIF9vd25lck1vZGVsU2V0dGluZ3NOYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0aW9uIHRlc3RzXHJcbiAgICAgKi9cclxuICAgIHZhbGlkOiBUZXN0PFQ+W10gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXRhYmlsaXR5IHRlc3RzXHJcbiAgICAgKi9cclxuICAgIGVkaXQ6IFRlc3Q8VD5bXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlld2FiaWxpdHkgdGVzdHNcclxuICAgICAqL1xyXG4gICAgLy8gdmlldzogVGVzdDxUPltdID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0aWVzIGZvciBhIGNvbXBsZXggb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByb3BlcnRpZXM/OiBQcm9wZXJ0eTxhbnk+W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0eSBmb3IgYW4gaXRlbSBvZiBhbiBhcnJheVxyXG4gICAgICovXHJcbiAgICBhcnJheUl0ZW1Qcm9wZXJ0eT86IEFycmF5SXRlbVByb3BlcnR5PGFueT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgbmFtZSBmb3IgY29udHJvbCB0byB1cGRhdGUgdXBvbi5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlT24/OiBVcGRhdGVPbiA9ICdjaGFuZ2UnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgcGF0aCB0byB0aGUgcHJvcGVydHkgZnJvbSByb290XHJcbiAgICAgKi9cclxuICAgIGdldCBhYnNvbHV0ZVBhdGgoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVQYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgcGF0aCB0byBwcm9wZXJ0eSBmcm9tIHJvb3RcclxuICAgICAqL1xyXG4gICAgZ2V0IGRlcGVuZGVuY3lQcm9wZXJ0eVN1YnNjcmlwdGlvbnMoKTogU3Vic2NyaXB0aW9uW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBlbmRlbmN5UHJvcGVydHlTdWJzY3JpcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgcGF0aCB0byBwcm9wZXJ0eSBmcm9tIHJvb3RcclxuICAgICAqL1xyXG4gICAgZ2V0IG93bmVyTW9kZWxTZXR0aW5nc05hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3duZXJNb2RlbFNldHRpbmdzTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbnMgZm9yIGhvdyB0byByZXNwb25kIHRvIHZhbHVlIGNoYW5nZXMgb24gcHJvcGVydHkgY29udHJvbCBhbmQgZGVwZW5kZW5jeSBjb250cm9sc1xyXG4gICAgICovXHJcbiAgICB2YWx1ZUNoYW5nZU9wdGlvbnM6IHtcclxuICAgICAgICBkZXBlbmRlbmN5UHJvcGVydGllczoge1xyXG4gICAgICAgICAgICB2YWxpZDogVmFsdWVDaGFuZ2VPcHRpb25zLFxyXG4gICAgICAgICAgICBlZGl0OiBWYWx1ZUNoYW5nZU9wdGlvbnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbGY6IHtcclxuICAgICAgICAgICAgYXN5bmNWYWxpZDogVmFsdWVDaGFuZ2VPcHRpb25zLFxyXG4gICAgICAgICAgICBlZGl0OiBWYWx1ZUNoYW5nZU9wdGlvbnNcclxuICAgICAgICB9XHJcbiAgICB9ID0ge1xyXG4gICAgICAgIGRlcGVuZGVuY3lQcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgIHZhbGlkOiB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkOiBmYWxzZSwgZGVib3VuY2VNaWxsaXNlY29uZHM6IDAgfSxcclxuICAgICAgICAgICAgZWRpdDogeyBkaXN0aW5jdFVudGlsQ2hhbmdlZDogZmFsc2UsIGRlYm91bmNlTWlsbGlzZWNvbmRzOiAwIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbGY6IHtcclxuICAgICAgICAgICAgYXN5bmNWYWxpZDogeyBkaXN0aW5jdFVudGlsQ2hhbmdlZDogZmFsc2UsIGRlYm91bmNlTWlsbGlzZWNvbmRzOiAwIH0sXHJcbiAgICAgICAgICAgIGVkaXQ6IHsgZGlzdGluY3RVbnRpbENoYW5nZWQ6IGZhbHNlLCBkZWJvdW5jZU1pbGxpc2Vjb25kczogMCB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHByb3BlcnR5IGlzIGFuIEFycmF5SXRlbVByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgUHJvcGVydHkgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSBpcyBhbiBBcnJheUl0ZW1Qcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNBcnJheUl0ZW1Qcm9wZXJ0eTxUPihwcm9wZXJ0eTogUHJvcGVydHlCYXNlPFQ+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEocHJvcGVydHkgYXMgUHJvcGVydHk8VD4pLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgQ0FMTCEgSW50ZXJuYWwgdXNlIG9ubHlcclxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZVBhdGggQWJzb2x1dGUgcGF0aCB0byB0aGUgcHJvcGVydHkgZnJvbSB0aGUgcm9vdFxyXG4gICAgICovXHJcbiAgICBzZXRBYnNvbHV0ZVBhdGgoYWJzb2x1dGVQYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9hYnNvbHV0ZVBhdGggPSBhYnNvbHV0ZVBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgQ0FMTCEgSW50ZXJuYWwgdXNlIG9ubHlcclxuICAgICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gU3Vic2NyaXB0aW9uIGZvciB0aGUgZGVwZW5kZW5jeSBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBhZGREZXBlbmRlbmN5UHJvcGVydHlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9kZXBlbmRlbmN5UHJvcGVydHlTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBDQUxMISBJbnRlcm5hbCB1c2Ugb25seVxyXG4gICAgICovXHJcbiAgICBjbGVhckRlcGVuZGVuY3lQcm9wZXJ0eVN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5UHJvcGVydHlTdWJzY3JpcHRpb25zLmZvckVhY2goc3ViJCA9PiBzdWIkLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICAgIHRoaXMuX2RlcGVuZGVuY3lQcm9wZXJ0eVN1YnNjcmlwdGlvbnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBDQUxMISBJbnRlcm5hbCB1c2Ugb25seVxyXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgb3duZXIgbW9kZWwgc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgc2V0T3duZXJNb2RlbFNldHRpbmdzTmFtZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9vd25lck1vZGVsU2V0dGluZ3NOYW1lID0gbmFtZTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTU9ERUxfU0VUVElOR1NfVE9LRU4gfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL2luamVjdGlvbi10b2tlbnMvbW9kZWwtc2V0dGluZ3MudG9rZW4nO1xyXG5pbXBvcnQgeyBBYnN0cmFjdE1vZGVsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9hYnN0cmFjdC1tb2RlbC1zZXR0aW5ncyc7XHJcbmltcG9ydCB7IFByb3BlcnR5IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcHJvcGVydHknO1xyXG5pbXBvcnQgeyBSdWxlR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9ydWxlLWdyb3VwJztcclxuaW1wb3J0IHsgUnVsZSB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3J1bGUnO1xyXG5pbXBvcnQgeyBUZXN0IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdCc7XHJcbmltcG9ydCB7IFRlc3RSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy90ZXN0LXJlc3VsdCc7XHJcbmltcG9ydCB7IFJ1bGVTZXQgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9ydWxlLXNldCc7XHJcbmltcG9ydCB7IFRlc3RSdW5TdGF0ZSB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Rlc3QtcnVuLXN0YXRlJztcclxuaW1wb3J0IHsgVHJhY2VTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvdHJhY2UvdHJhY2Uuc2VydmljZSc7XHJcbmltcG9ydCB7IENvbW1vblNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb21tb24vY29tbW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmb3JrSm9pbiwgb2YgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgIG1hcCwgZmxhdE1hcCwgbWVyZ2VNYXAsIHRha2UsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgVGVzdFJlc3VsdHNCYXNlIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1yZXN1bHRzLWJhc2UnO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eVRlc3RSZXN1bHRzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcHJvcGVydHktdGVzdC1yZXN1bHQnO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eUJhc2UgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9wcm9wZXJ0eS1iYXNlJztcclxuaW1wb3J0IHsgUHJvY2Vzc1Jlc3VsdFR5cGUgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9wcm9jY2Vzcy1yZXN1bHQtdHlwZSc7XHJcbmltcG9ydCB7IFRlc3RTeW5jR3JvdXBzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1zeW5jLWdyb3Vwcyc7XHJcbmltcG9ydCB7IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9yZXN1bHRzLXBhc3MtcmVxdWlyZW1lbnQnO1xyXG5cclxuLyoqXHJcbiAqIEVuZ2luZSB0aGF0IGRpZ2VzdHMgbW9kZWwgc2V0dGluZ3MgYW5kIGFwcGxpZXMgdGhlaXIgcnVsZXMgYXBwcm9wcmlhdGVseVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgUnVsZXNFbmdpbmVTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgcmVnaXN0ZXJlZFNldHRpbmdzOiB7IFtrZXk6IHN0cmluZ106IEFic3RyYWN0TW9kZWxTZXR0aW5nczxhbnk+OyB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTU9ERUxfU0VUVElOR1NfVE9LRU4pIHNldHRpbmdzOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8YW55PltdLFxyXG4gICAgICAgIHByaXZhdGUgdHJhY2VTdmM6IFRyYWNlU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIGNvbW1vblN2YzogQ29tbW9uU2VydmljZVxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2V0dGluZ3MgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNldHRpbmdzKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBzZXR0aW5ncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVNb2RlbFNldHRpbmcoc2V0dGluZyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZFNldHRpbmdzW3NldHRpbmcubmFtZV0gPSBzZXR0aW5nO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgbW9kZWwgc2V0dGluZ3MgYW5kIHByZXBhcmVzIHRoZW0gdG8gYmUgdXNlZCBpbiBhIGZvcm0gZ3JvdXBcclxuICAgICAqIEBwYXJhbSBzZXR0aW5nIE1vZGVsIHNldHRpbmcgdG8gaW5pdGlhbGl6ZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplTW9kZWxTZXR0aW5nKHNldHRpbmc6IEFic3RyYWN0TW9kZWxTZXR0aW5nczxhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50cmFjZVN2Yy50cmFjZShgSW5pdGlhbGl6aW5nIG1vZGVsIHNldHRpbmdzIFwiJHtzZXR0aW5nLm5hbWV9XCJgKTtcclxuICAgICAgICB0aGlzLnNldFByb3BlcnR5TWV0YWRhdGEoc2V0dGluZy5wcm9wZXJ0aWVzLCBzZXR0aW5nLm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBtb2RlbCBzZXR0aW5ncyB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIG1vZGVsIHNldHRpbmdcclxuICAgICAqIEByZXR1cm5zIE1vZGVsIHNldHRpbmdzIHdpdGggdGhlIHByb3ZpZGVkIG5hbWVcclxuICAgICAqL1xyXG4gICAgZ2V0TW9kZWxTZXR0aW5nczxUPihuYW1lOiBzdHJpbmcpOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8VD4ge1xyXG4gICAgICAgIHRoaXMudHJhY2VTdmMudHJhY2UoYFJldHJpZXZpbmcgbW9kZWwgc2V0dGluZ3MgXCIke25hbWV9XCJgKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnJlZ2lzdGVyZWRTZXR0aW5nc1tuYW1lXTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYmplY3RcclxuICAgICAgICByZXR1cm4gc2V0dGluZ3NcclxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlZ2lzdGVyZWRTZXR0aW5nc1tuYW1lXSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGVwZW5kZW5jeSBwcm9wZXJ0aWVzIGZvciBhbiBhcnJheSBvZiB0ZXN0c1xyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIGdldCB0aGUgZGVwZW5kZW5jeSBwcm9wZXJ0aWVzIGZvclxyXG4gICAgICogQHJldHVybnMgRGVwZW5kZW5jeSBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIGdldERlcGVuZGVuY3lQcm9wZXJ0aWVzPFQ+KHRlc3RzOiBUZXN0PFQ+W10pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgaWYgKCF0ZXN0cykgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICBjb25zdCBkZXBzID0gdGVzdHNcclxuICAgICAgICAgICAgLm1hcCh0ID0+IHRoaXMuZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tVGVzdCh0KSlcclxuICAgICAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4gcHJldi5jb25jYXQoY3VycmVudCksIFtdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbW9uU3ZjLnVuaXF1ZShkZXBzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGVzdHMgZ3JvdXBlZCBieSB0aGVpciBzeW5jIHR5cGUgKGUuZy4gc3luYyB2cy4gYXN5bmMpXHJcbiAgICAgKiBAcGFyYW0gdGVzdHMgVGVzdCB0byBncm91cHNcclxuICAgICAqIEByZXR1cm5zIFRlc3RzIGdyb3VwZWQgYnkgc3luYyB0eXBlXHJcbiAgICAgKi9cclxuICAgIGdyb3VwVGVzdHNCeVN5bmNUeXBlPFQ+KHRlc3RzOiBUZXN0PFQ+W10pOiBUZXN0U3luY0dyb3VwczxUPiB7XHJcbiAgICAgICAgY29uc3QgdGVzdEdyb3VwcyA9IHtcclxuICAgICAgICAgICAgc3luYzogW10sXHJcbiAgICAgICAgICAgIGFzeW5jOiBbXVxyXG4gICAgICAgIH0gYXMgVGVzdFN5bmNHcm91cHM8VD47XHJcblxyXG4gICAgICAgIGlmICghdGVzdHMpIHJldHVybiB0ZXN0R3JvdXBzO1xyXG5cclxuICAgICAgICB0ZXN0cy5mb3JFYWNoKHRlc3QgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0RnVuY1R5cGVzID0ge1xyXG4gICAgICAgICAgICAgICAgc3luYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuICAgICAgICAgICAgfSBhcyBDb25maWd1cmVkRnVuY1R5cGVzO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uUmVzdWx0cyA9IHRoaXMuZ2V0Q29uZmlndXJlZEZ1bmNUeXBlcyh0ZXN0LmNvbmRpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0cyA9IHRoaXMuZ2V0Q29uZmlndXJlZEZ1bmNUeXBlcyh0ZXN0LmNoZWNrKTtcclxuXHJcbiAgICAgICAgICAgIHRlc3RGdW5jVHlwZXMuc3luYyA9IGNvbmRpdGlvblJlc3VsdHMuc3luYyB8fCBjaGVja1Jlc3VsdHMuc3luYztcclxuICAgICAgICAgICAgdGVzdEZ1bmNUeXBlcy5hc3luYyA9IGNvbmRpdGlvblJlc3VsdHMuYXN5bmMgfHwgY2hlY2tSZXN1bHRzLmFzeW5jO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYXN5bmMgZnVuYyBhbnl3aGVyZSBpbiB0aGUgdGVzdCdzIHJ1bGUgc2V0cywgdGhlbiBpdCBpcyBjb25zaWRlcmVkIGFuIGFzeW5jIHRlc3RcclxuICAgICAgICAgICAgaWYgKHRlc3RGdW5jVHlwZXMuc3luYyAmJiAhdGVzdEZ1bmNUeXBlcy5hc3luYykgdGVzdEdyb3Vwcy5zeW5jLnB1c2godGVzdCk7XHJcbiAgICAgICAgICAgIGlmICh0ZXN0RnVuY1R5cGVzLmFzeW5jKSB0ZXN0R3JvdXBzLmFzeW5jLnB1c2godGVzdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXN0R3JvdXBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyB2YWxpZGF0aW9uIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHJ1biB2YWxpZGF0aW9uIHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBydW4gdmFsaWRhdGlvbiB0ZXN0cyBmb3JcclxuICAgICAqIEByZXR1cm5zIFJlc3VsdHMgb2YgdmFsaWRhdGlvbiB0ZXN0c1xyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZTxUPihkYXRhOiBULCBwcm9wZXJ0eTogUHJvcGVydHk8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxQcm9wZXJ0eVRlc3RSZXN1bHRzPFQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuQWxsVGVzdHMoZGF0YSwgcHJvcGVydHkudmFsaWQsIHN0YXRlKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgocmVzdWx0czogUHJvcGVydHlUZXN0UmVzdWx0czxUPikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHJvcGVydHlOYW1lID0gcHJvcGVydHkuYWJzb2x1dGVQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzIGFzIFByb3BlcnR5VGVzdFJlc3VsdHM8VD47XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBlZGl0YWJpbGl0eSB0ZXN0c1xyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBydW4gZWRpdGFiaWxpdHkgdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFByb3BlcnR5IHRvIHJ1biBlZGl0YWJpbGl0eSB0ZXN0cyBmb3JcclxuICAgICAqICogQHJldHVybnMgUmVzdWx0cyBvZiBlZGl0YWJpbGl0eSB0ZXN0c1xyXG4gICAgICovXHJcbiAgICBlZGl0YWJsZTxUPihkYXRhOiBULCBwcm9wZXJ0eTogUHJvcGVydHlCYXNlPFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8UHJvcGVydHlUZXN0UmVzdWx0czxUPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bkFsbFRlc3RzKGRhdGEsIHByb3BlcnR5LmVkaXQsIHN0YXRlKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgocmVzdWx0czogUHJvcGVydHlUZXN0UmVzdWx0czxUPikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHJvcGVydHlOYW1lID0gcHJvcGVydHkuYWJzb2x1dGVQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzIGFzIFByb3BlcnR5VGVzdFJlc3VsdHM8VD47XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyB2aXNpYmlsaXR5IHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHJ1biB2aXNpYmlsaXR5IHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBydW4gdmlzaWJpbGl0eSB0ZXN0cyBmb3JcclxuICAgICAqICogQHJldHVybnMgUmVzdWx0cyBvZiB2aXNpYmlsaXR5IHRlc3RzXHJcbiAgICAgKi9cclxuICAgIC8vIHZpc2libGU8VD4oZGF0YTogVCwgcHJvcGVydHk6IFByb3BlcnR5PFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8UHJvcGVydHlUZXN0UmVzdWx0czxUPj4ge1xyXG4gICAgLy8gICAgIHJldHVybiB0aGlzLnJ1bkFsbFRlc3RzKGRhdGEsIHByb3BlcnR5LnZpZXcsIHN0YXRlKVxyXG4gICAgLy8gICAgICAgICAucGlwZShcclxuICAgIC8vICAgICAgICAgICAgIG1hcCgocmVzdWx0czogUHJvcGVydHlUZXN0UmVzdWx0czxUPikgPT4ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIHJlc3VsdHMucHJvcGVydHlOYW1lID0gcHJvcGVydHkuYWJzb2x1dGVQYXRoO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzIGFzIFByb3BlcnR5VGVzdFJlc3VsdHM8VD47XHJcbiAgICAvLyAgICAgICAgICAgICB9KVxyXG4gICAgLy8gICAgICAgICApO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBhbiBhcnJheSBvZiBzeW5jIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RzXHJcbiAgICAgKi9cclxuICAgIHJ1blRlc3RzPFQ+KGRhdGE6IFQsIHRlc3RzOiBUZXN0PFQ+W10sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogVGVzdFJlc3VsdHNCYXNlPFQ+IHtcclxuICAgICAgICBpZiAoIXRlc3RzIHx8ICF0ZXN0cy5sZW5ndGgpIHJldHVybiBuZXcgVGVzdFJlc3VsdHNCYXNlKFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGVzdFJlc3VsdHMgPSB0ZXN0c1xyXG4gICAgICAgICAgICAubWFwKHQgPT4gdGhpcy5ydW5UZXN0KGRhdGEsIHQsIHN0YXRlKSlcclxuICAgICAgICAgICAgLmZpbHRlcih4ID0+ICEheCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVGVzdFJlc3VsdHNCYXNlKHRlc3RSZXN1bHRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYW4gYXJyYXkgb2YgYXN5bmMgdGVzdHNcclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcGVyZm9ybSB0ZXN0cyBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gdGVzdHMgVGVzdHMgdG8gcnVuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHQgb2YgdGVzdHNcclxuICAgICAqL1xyXG4gICAgcnVuVGVzdHNBc3luYzxUPihkYXRhOiBULCB0ZXN0czogVGVzdDxUPltdLCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8VGVzdFJlc3VsdHNCYXNlPFQ+PiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0cyB8fCAhdGVzdHMubGVuZ3RoKSByZXR1cm4gb2YobmV3IFRlc3RSZXN1bHRzQmFzZShbXSkpO1xyXG5cclxuICAgICAgICBjb25zdCBydW5UZXN0JCA9IHRlc3RzXHJcbiAgICAgICAgICAgIC5tYXAodGVzdCA9PiB0aGlzLnJ1blRlc3RBc3luYyhkYXRhLCB0ZXN0LCBzdGF0ZSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4ocnVuVGVzdCQpXHJcbiAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgbWFwKHRlc3RSZXN1bHRzID0+IG5ldyBUZXN0UmVzdWx0c0Jhc2UodGVzdFJlc3VsdHMuZmlsdGVyKHggPT4gISF4KSkpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGFuIGFycmF5IG9mIHN5bmMgYW5kIGFzeW5jIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RzXHJcbiAgICAgKi9cclxuICAgIHJ1bkFsbFRlc3RzPFQ+KGRhdGE6IFQsIHRlc3RzOiBUZXN0PFQ+W10sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxUZXN0UmVzdWx0c0Jhc2U8VD4+IHtcclxuICAgICAgICBpZiAoIXRlc3RzIHx8ICF0ZXN0cy5sZW5ndGgpIHJldHVybiBvZihuZXcgVGVzdFJlc3VsdHNCYXNlKFtdKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN5bmNHcm91cHMgPSB0aGlzLmdyb3VwVGVzdHNCeVN5bmNUeXBlKHRlc3RzKTtcclxuICAgICAgICBjb25zdCBzeW5jVGVzdFJlc3VsdHMgPSBvZih0aGlzLnJ1blRlc3RzKGRhdGEsIHN5bmNHcm91cHMuc3luYywgc3RhdGUpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bmNUZXN0UmVzdWx0cy5waXBlKFxyXG4gICAgICAgICAgICBtZXJnZU1hcChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQucGFzc2VkKSByZXR1cm4gb2YocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UZXN0c0FzeW5jKGRhdGEsIHN5bmNHcm91cHMuYXN5bmMsIHN0YXRlKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRha2UoMSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgc3luYyB0ZXN0IG9uIGEgc2V0IG9mIGRhdGFcclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcGVyZm9ybSB0ZXN0IGFnYWluc3RcclxuICAgICAqIEBwYXJhbSB0ZXN0IFRlc3QgdG8gcnVuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHQgb2YgdGVzdFxyXG4gICAgICovXHJcbiAgICBydW5UZXN0PFQ+KGRhdGE6IFQsIHRlc3Q6IFRlc3Q8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogVGVzdFJlc3VsdDxUPiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgcGFzc2VkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiB0cnVlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IG51bGwgfTtcclxuICAgICAgICBjb25zdCBmYWlsZWRUZXN0UmVzdWx0OiBUZXN0UmVzdWx0PFQ+ID0geyBwYXNzZWQ6IGZhbHNlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IHRlc3QubWVzc2FnZSB9O1xyXG4gICAgICAgIGNvbnN0IHNraXBwZWRUZXN0UmVzdWx0OiBUZXN0UmVzdWx0PFQ+ID0geyBwYXNzZWQ6IHRydWUsIHNraXBwZWQ6IHRydWUsIG5hbWU6IHRlc3QubmFtZSwgbWVzc2FnZTogbnVsbCB9O1xyXG5cclxuICAgICAgICBjb25zdCBjb25kaXRpb25zUnVsZVNldFJlc3VsdCA9IHRoaXMucHJvY2Vzc1J1bGVTZXQoZGF0YSwgdGVzdC5jb25kaXRpb24sIHN0YXRlKTtcclxuICAgICAgICBpZiAoY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQgPT09IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZCkgcmV0dXJuIHNraXBwZWRUZXN0UmVzdWx0O1xyXG5cclxuICAgICAgICBjb25zdCBjaGVja1J1bGVTZXRSZXN1bHQgPSB0aGlzLnByb2Nlc3NSdWxlU2V0KGRhdGEsIHRlc3QuY2hlY2ssIHN0YXRlKTtcclxuICAgICAgICBzd2l0Y2ggKGNoZWNrUnVsZVNldFJlc3VsdCkge1xyXG4gICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXNzZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcHBlZFRlc3RSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYXN5bmMgdGVzdCBvbiBhIHNldCBvZiBkYXRhXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdCBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gdGVzdCBUZXN0IHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RcclxuICAgICAqL1xyXG4gICAgcnVuVGVzdEFzeW5jPFQ+KGRhdGE6IFQsIHRlc3Q6IFRlc3Q8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxUZXN0UmVzdWx0PFQ+PiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0KSByZXR1cm4gb2YobnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhc3NlZFRlc3RSZXN1bHQ6IFRlc3RSZXN1bHQ8VD4gPSB7IHBhc3NlZDogdHJ1ZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiBudWxsIH07XHJcbiAgICAgICAgY29uc3QgZmFpbGVkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiBmYWxzZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiB0ZXN0Lm1lc3NhZ2UgfTtcclxuICAgICAgICBjb25zdCBza2lwcGVkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiB0cnVlLCBza2lwcGVkOiB0cnVlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IG51bGwgfTtcclxuXHJcbiAgICAgICAgY29uc3QgY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQkID0gdGhpcy5wcm9jZXNzUnVsZVNldEFzeW5jKGRhdGEsIHRlc3QuY29uZGl0aW9uLCBzdGF0ZSk7XHJcbiAgICAgICAgY29uc3QgY2hlY2tSdWxlU2V0UmVzdWx0JCA9IHRoaXMucHJvY2Vzc1J1bGVTZXRBc3luYyhkYXRhLCB0ZXN0LmNoZWNrLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25kaXRpb25zUnVsZVNldFJlc3VsdCRcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBmbGF0TWFwKGNvbmRpdGlvbnNSdWxlU2V0UmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQgPT09IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZCkgcmV0dXJuIG9mKHNraXBwZWRUZXN0UmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUnVsZVNldFJlc3VsdCRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAoY2hlY2tSdWxlU2V0UmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoZWNrUnVsZVNldFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXNzZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2tpcHBlZFRlc3RSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzZXMgYSBzeW5jIHJ1bGUgc2V0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHByb2Nlc3MgcnVsZSBzZXQgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHJ1bGVTZXQgUnVsZSBzZXQgdG8gcHJvY2Vzc1xyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHJ1bGUgc2V0IHByb2Nlc3NpbmdcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc1J1bGVTZXQ8VD4oZGF0YTogVCwgcnVsZVNldDogUnVsZVNldDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBQcm9jZXNzUmVzdWx0VHlwZSB7XHJcbiAgICAgICAgaWYgKCFydWxlU2V0KSByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZDtcclxuXHJcbiAgICAgICAgY29uc3QgaXNSdWxlR3JvdXAgPSB0aGlzLmlzUnVsZUdyb3VwKHJ1bGVTZXQpO1xyXG4gICAgICAgIHJldHVybiBpc1J1bGVHcm91cFxyXG4gICAgICAgICAgICA/IHRoaXMucHJvY2Vzc1J1bGVHcm91cChkYXRhLCBydWxlU2V0IGFzIFJ1bGVHcm91cDxUPiwgc3RhdGUpXHJcbiAgICAgICAgICAgIDogdGhpcy5wcm9jZXNzUnVsZShkYXRhLCBydWxlU2V0IGFzIFJ1bGU8VD4sIHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3NlcyBhbiBhc3luYyBydWxlIHNldFxyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBwcm9jZXNzIHJ1bGUgc2V0IGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBydWxlU2V0IFJ1bGUgc2V0IHRvIHByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiBydWxlIHNldCBwcm9jZXNzaW5nXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NSdWxlU2V0QXN5bmM8VD4oZGF0YTogVCwgcnVsZVNldDogUnVsZVNldDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFByb2Nlc3NSZXN1bHRUeXBlPiB7XHJcbiAgICAgICAgaWYgKCFydWxlU2V0KSByZXR1cm4gb2YoUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUnVsZUdyb3VwID0gdGhpcy5pc1J1bGVHcm91cChydWxlU2V0KTtcclxuICAgICAgICByZXR1cm4gaXNSdWxlR3JvdXBcclxuICAgICAgICAgICAgPyB0aGlzLnByb2Nlc3NSdWxlR3JvdXBBc3luYyhkYXRhLCBydWxlU2V0IGFzIFJ1bGVHcm91cDxUPiwgc3RhdGUpXHJcbiAgICAgICAgICAgIDogdGhpcy5wcm9jZXNzUnVsZUFzeW5jKGRhdGEsIHJ1bGVTZXQgYXMgUnVsZTxUPiwgc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcHJvY2Vzc1J1bGVHcm91cDxUPihkYXRhOiBULCBydWxlR3JvdXA6IFJ1bGVHcm91cDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBQcm9jZXNzUmVzdWx0VHlwZSB7XHJcbiAgICAgICAgaWYgKCFydWxlR3JvdXAucnVsZXMpIHJldHVybiBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkO1xyXG5cclxuICAgICAgICBsZXQgcGFzc2VkQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBza2lwcGVkQ291bnQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVHcm91cC5ydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZUdyb3VwLnJ1bGVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBydWxlU2V0UmVzdWx0ID0gdGhpcy5wcm9jZXNzUnVsZVNldChkYXRhLCBydWxlLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5TaG9ydENpcmN1aXRSdWxlR3JvdXAocnVsZVNldFJlc3VsdCwgcnVsZUdyb3VwKSkgcmV0dXJuIHJ1bGVTZXRSZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocnVsZVNldFJlc3VsdCA9PSBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQpIHBhc3NlZENvdW50Kys7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGVTZXRSZXN1bHQgPT0gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZCkgc2tpcHBlZENvdW50Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB3ZSBza2lwcGVkIHRoZW0gYWxsLCB0aGVuIHJldHVybiBza2lwcGVkXHJcbiAgICAgICAgaWYgKHNraXBwZWRDb3VudCA9PT0gcnVsZUdyb3VwLnJ1bGVzLmxlbmd0aCkgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGdvdCB0aGlzIGZhciwgbWFrZSBzdXJlIGFsbCB0ZXN0cyB3ZXJlIHBhc3NlZFxyXG4gICAgICAgIHJldHVybiBwYXNzZWRDb3VudCA9PT0gcnVsZUdyb3VwLnJ1bGVzLmxlbmd0aCA/IFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZCA6IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHByb2Nlc3NSdWxlR3JvdXBBc3luYzxUPihkYXRhOiBULCBydWxlR3JvdXA6IFJ1bGVHcm91cDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFByb2Nlc3NSZXN1bHRUeXBlPiB7XHJcbiAgICAgICAgaWYgKCFydWxlR3JvdXAucnVsZXMpIHJldHVybiBvZihQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkKTtcclxuICAgICAgICBjb25zdCBhc3luY1J1bGVTZXRSZXN1bHRzJCA9IHJ1bGVHcm91cC5ydWxlcy5tYXAoeCA9PiB0aGlzLnByb2Nlc3NSdWxlU2V0QXN5bmMoZGF0YSwgeCwgc3RhdGUpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGFzeW5jUnVsZVNldFJlc3VsdHMkKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAocnVsZVNldFJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZDogcnVsZVNldFJlc3VsdHMuZmlsdGVyKHggPT4geCA9PT0gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkOiBydWxlU2V0UmVzdWx0cy5maWx0ZXIoeCA9PiB4ID09PSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQpLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkOiBydWxlU2V0UmVzdWx0cy5maWx0ZXIoeCA9PiB4ID09PSBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVHcm91cE9wdGlvbnMgPSBydWxlR3JvdXAub3B0aW9ucyB8fCB7IHJlc3VsdFJlcXVpcmVtZW50czogUmVzdWx0c1Bhc3NSZXF1aXJlbWVudC5BbGxQYXNzIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQW55UGFzcyAmJiBjb3VudHMucGFzc2VkID4gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQWxsUGFzcyAmJiBjb3VudHMucGFzc2VkID09PSBydWxlU2V0UmVzdWx0cy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudHMuc2tpcHBlZCA9PT0gcnVsZVNldFJlc3VsdHMubGVuZ3RoKSByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuRmFpbGVkO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwcm9jZXNzUnVsZTxUPihkYXRhOiBULCBydWxlOiBSdWxlPFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IFByb2Nlc3NSZXN1bHRUeXBlIHtcclxuICAgICAgICBpZiAoIXJ1bGUuZnVuYykgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvb3REYXRhID0gc3RhdGUgPyBzdGF0ZS5yb290RGF0YSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGUuZnVuYyhkYXRhLCByb290RGF0YSkgPyBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQgOiBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwcm9jZXNzUnVsZUFzeW5jPFQ+KGRhdGE6IFQsIHJ1bGU6IFJ1bGU8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxQcm9jZXNzUmVzdWx0VHlwZT4ge1xyXG4gICAgICAgIGlmICghcnVsZS5mdW5jICYmICFydWxlLmFzeW5jRnVuYykgcmV0dXJuIG9mKFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQpO1xyXG5cclxuICAgICAgICBjb25zdCByb290RGF0YSA9IHN0YXRlID8gc3RhdGUucm9vdERhdGEgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGZ1bmNSZXN1bHQgPSBydWxlLmZ1bmNcclxuICAgICAgICAgICAgPyBvZihydWxlLmZ1bmMoZGF0YSwgcm9vdERhdGEpKVxyXG4gICAgICAgICAgICA6IHJ1bGUuYXN5bmNGdW5jKGRhdGEsIHJvb3REYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmNSZXN1bHRcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBtYXAocGFzc2VkID0+IHBhc3NlZCA/IFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZCA6IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZClcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcml2YXRlIGRvUHJvY2Vzc1J1bGU8VD4ocnVsZTogUnVsZTxUPiwgc3RhdGU6IFRlc3RSdW5TdGF0ZSwgaXNBc3luYzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgLy8gICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSBmdW5jIHRvIGNhbGxcclxuICAgIC8vICAgICBpZiAoKGlzQXN5bmMgJiYgIXJ1bGUuYXN5bmNGdW5jKSB8fCAoIWlzQXN5bmMgJiYgIXJ1bGUuZnVuYykpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyAgICAgLy8gLy8gaWYgdGhlcmUgaXMgbWlzc2luZyBkYXRhLCB0aGVuIGFzc3VtZSB3ZSBzaG91bGQgcHJvY2VzcyB0aGUgcnVsZVxyXG4gICAgLy8gICAgIC8vIGlmICghcnVsZS5vcHRpb25zIHx8ICFydWxlLm9wdGlvbnMuY29udHJvbFN0YXRlT3B0aW9ucyB8fCAhc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xTdGF0ZSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgLy8gICAgIC8vIGlmIChydWxlLm9wdGlvbnMuY29udHJvbFN0YXRlT3B0aW9ucy5za2lwUHJpc3RpbmUgJiYgc3RhdGUuY29udHJvbFN0YXRlLnByaXN0aW5lKSByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyAgICAgLy8gaWYgKHJ1bGUub3B0aW9ucy5jb250cm9sU3RhdGVPcHRpb25zLnNraXBVbnRvdWNoZWQgJiYgc3RhdGUuY29udHJvbFN0YXRlLnVudG91Y2hlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwcml2YXRlIGNhblNob3J0Q2lyY3VpdFJ1bGVHcm91cDxUPihydWxlU2V0UmVzdWx0OiBQcm9jZXNzUmVzdWx0VHlwZSwgcnVsZUdyb3VwOiBSdWxlR3JvdXA8VD4pOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBydWxlR3JvdXBPcHRpb25zID0gcnVsZUdyb3VwLm9wdGlvbnMgfHwgeyByZXN1bHRSZXF1aXJlbWVudHM6IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQWxsUGFzcyB9O1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAvLyBpdCBwYXNzZWQsIGFuZCB3ZSBvbmx5IG5lZWQgb25lIHRvIHBhc3NcclxuICAgICAgICAgICAgKHJ1bGVTZXRSZXN1bHQgPT0gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkICYmIHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQW55UGFzcylcclxuICAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgLy8gaWYgZmFpbGVkLCBhbmQgd2UgbmVlZCBhbGwgdG8gcGFzc1xyXG4gICAgICAgICAgICAocnVsZVNldFJlc3VsdCA9PSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQgJiYgcnVsZUdyb3VwT3B0aW9ucy5yZXN1bHRSZXF1aXJlbWVudHMgPT0gUmVzdWx0c1Bhc3NSZXF1aXJlbWVudC5BbGxQYXNzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc1J1bGVHcm91cDxUPihydWxlU2V0OiBSdWxlU2V0PFQ+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVTZXQgYXMgUnVsZTxUPjtcclxuICAgICAgICByZXR1cm4gIXJ1bGUuZnVuYyAmJiAhcnVsZS5hc3luY0Z1bmM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21UZXN0PFQ+KHRlc3Q6IFRlc3Q8VD4pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tEZXBzID0gdGhpcy5nZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21SdWxlU2V0PFQ+KHRlc3QuY2hlY2spO1xyXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbkRlcHMgPSB0aGlzLmdldERlcGVuZGVuY3lQcm9wZXJ0aWVzRnJvbVJ1bGVTZXQ8VD4odGVzdC5jb25kaXRpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1vblN2Yy51bmlxdWUoY2hlY2tEZXBzLmNvbmNhdChjb25kaXRpb25EZXBzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21SdWxlU2V0PFQ+KHJ1bGVTZXQ6IFJ1bGVTZXQ8VD4pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgaWYgKCFydWxlU2V0KSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNSdWxlR3JvdXAocnVsZVNldCkpIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZUdyb3VwID0gcnVsZVNldCBhcyBSdWxlR3JvdXA8VD47XHJcbiAgICAgICAgICAgIHJ1bGVHcm91cC5ydWxlcy5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy5jb21tb25TdmMudW5pcXVlKHRoaXMuZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tUnVsZVNldCh4KSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlU2V0IGFzIFJ1bGU8VD47XHJcbiAgICAgICAgaWYgKHJ1bGUub3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHJ1bGUub3B0aW9ucy5kZXBlbmRlbmN5UHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy5jb21tb25TdmMudW5pcXVlKHJ1bGUub3B0aW9ucy5kZXBlbmRlbmN5UHJvcGVydGllcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbW9uU3ZjLnVuaXF1ZShyZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0UHJvcGVydHlNZXRhZGF0YShwcm9wZXJ0aWVzOiBQcm9wZXJ0eUJhc2U8YW55PltdLCBtb2RlbFNldHRpbmdzTmFtZTogc3RyaW5nLCBjdXJyZW50QWJzb2x1dGVQYXRoOiBzdHJpbmcgPSAnJyk6IHZvaWQge1xyXG4gICAgICAgIGlmICghcHJvcGVydGllcykgcmV0dXJuO1xyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0Fic29sdXRlUGF0aCA9IHRoaXMuc2V0UHJvcGVydHlBYnNvbHV0ZVBhdGgocHJvcCwgY3VycmVudEFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbEluRW1wdHlUZXN0TmFtZXMocHJvcCk7XHJcbiAgICAgICAgICAgIHByb3Auc2V0T3duZXJNb2RlbFNldHRpbmdzTmFtZShtb2RlbFNldHRpbmdzTmFtZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcC5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5TWV0YWRhdGEocHJvcC5wcm9wZXJ0aWVzLCBtb2RlbFNldHRpbmdzTmFtZSwgbmV3QWJzb2x1dGVQYXRoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wLmFycmF5SXRlbVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5TWV0YWRhdGEoW3Byb3AuYXJyYXlJdGVtUHJvcGVydHldLCBtb2RlbFNldHRpbmdzTmFtZSwgbmV3QWJzb2x1dGVQYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0UHJvcGVydHlBYnNvbHV0ZVBhdGgocHJvcGVydHk6IFByb3BlcnR5QmFzZTxhbnk+LCBjdXJyZW50QWJzb2x1dGVQYXRoOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgaXNBcnJheUl0ZW1Qcm9wZXJ0eSA9IFByb3BlcnR5QmFzZS5pc0FycmF5SXRlbVByb3BlcnR5KHByb3BlcnR5KTtcclxuICAgICAgICBjb25zdCBuZXdBYnNvbHV0ZVBhdGhTZWdtZW50ID0gaXNBcnJheUl0ZW1Qcm9wZXJ0eSA/ICdbXScgOiAocHJvcGVydHkgYXMgUHJvcGVydHk8YW55PikubmFtZTtcclxuICAgICAgICBjb25zdCBpc0F0Um9vdCA9ICFjdXJyZW50QWJzb2x1dGVQYXRoO1xyXG4gICAgICAgIGNvbnN0IG5ld0Fic29sdXRlUGF0aCA9IGAke2N1cnJlbnRBYnNvbHV0ZVBhdGh9JHtpc0F0Um9vdCA/ICcnIDogJy4nfSR7bmV3QWJzb2x1dGVQYXRoU2VnbWVudH1gO1xyXG5cclxuICAgICAgICAvLyBzZXQgYWJzb2x1dGUgcGF0aCBmb3IgcHJvcGVydHlcclxuICAgICAgICBwcm9wZXJ0eS5zZXRBYnNvbHV0ZVBhdGgobmV3QWJzb2x1dGVQYXRoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld0Fic29sdXRlUGF0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZpbGxJbkVtcHR5VGVzdE5hbWVzKHByb3BlcnR5OiBQcm9wZXJ0eUJhc2U8YW55Pikge1xyXG4gICAgICAgIHByb3BlcnR5LnZhbGlkXHJcbiAgICAgICAgICAgIC5maWx0ZXIodGVzdCA9PiAhdGVzdC5uYW1lKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgodGVzdCwgaSkgPT4gdGVzdC5uYW1lID0gYHZhbGlkVGVzdCR7aX1gKTtcclxuXHJcbiAgICAgICAgcHJvcGVydHkuZWRpdFxyXG4gICAgICAgICAgICAuZmlsdGVyKHRlc3QgPT4gIXRlc3QubmFtZSlcclxuICAgICAgICAgICAgLmZvckVhY2goKHRlc3QsIGkpID0+IHRlc3QubmFtZSA9IGBlZGl0VGVzdCR7aX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldENvbmZpZ3VyZWRGdW5jVHlwZXM8VD4ocnVsZVNldDogUnVsZVNldDxUPik6IENvbmZpZ3VyZWRGdW5jVHlwZXMge1xyXG4gICAgICAgIGlmICghcnVsZVNldCkgcmV0dXJuIHsgc3luYzogZmFsc2UsIGFzeW5jOiBmYWxzZSB9O1xyXG5cclxuICAgICAgICBjb25zdCBpc1J1bGVHcm91cCA9IHRoaXMuaXNSdWxlR3JvdXAocnVsZVNldCk7XHJcblxyXG4gICAgICAgIGlmIChpc1J1bGVHcm91cCkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlR3JvdXAgPSBydWxlU2V0IGFzIFJ1bGVHcm91cDxUPjtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHJ1bGVHcm91cC5ydWxlc1xyXG4gICAgICAgICAgICAgICAgLm1hcChycyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlndXJlZEZ1bmNUeXBlcyhycyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jOiByZXN1bHRzLmZpbmRJbmRleCh4ID0+ICEheC5zeW5jKSA+PSAwLFxyXG4gICAgICAgICAgICAgICAgYXN5bmM6IHJlc3VsdHMuZmluZEluZGV4KHggPT4gISF4LmFzeW5jKSA+PSAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlU2V0IGFzIFJ1bGU8VD47XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jOiAhIXJ1bGUuZnVuYyxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXJ1bGUuYXN5bmNGdW5jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29uZmlndXJlZEZ1bmNUeXBlcyB7XHJcbiAgICBzeW5jOiBib29sZWFuO1xyXG4gICAgYXN5bmM6IGJvb2xlYW47XHJcbn1cclxuIiwiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XHJcblxyXG4vKipcclxuICogU3RhdGUgb2YgYW4gQW5ndWxhciBBYnN0cmFjdENvbnRyb2wgYXQgdGhlIHRpbWUgb2YgcnVubmluZyBhIHRlc3RcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250cm9sU3RhdGUge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfcHJpc3RpbmU6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF91bnRvdWNoZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gZ2V0IHByaXN0aW5lKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcHJpc3RpbmU7IH1cclxuICAgIC8vIGdldCB1bnRvdWNoZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl91bnRvdWNoZWQ7IH1cclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkge1xyXG4gICAgICAgIHRoaXMuX3ByaXN0aW5lID0gY29udHJvbC5wcmlzdGluZTtcclxuICAgICAgICB0aGlzLl91bnRvdWNoZWQgPSBjb250cm9sLnVudG91Y2hlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBDb250cm9sU3RhdGUgb2JqZWN0IGJhc2VkIG9uIGFuIEFuZ3VsYXIgY29udHJvbFxyXG4gICAgICogQHBhcmFtIGNvbnRyb2wgQW5ndWxhciBjb250cm9sIHRvIGdlbmVyYXRlIHN0YXRlIGZyb21cclxuICAgICAqIEByZXR1cm5zIENvbnRyb2wgc3RhdGUgYmFzZSBvbiBBbmd1bGFyIGNvbnRyb2xcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBDb250cm9sU3RhdGUge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbFN0YXRlKGNvbnRyb2wpO1xyXG4gICAgfVxyXG59IiwiLy8gdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoXHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXAsIEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdG9yRm4sIEZvcm1CdWlsZGVyLCBGb3JtQ29udHJvbCwgRm9ybUFycmF5LCBWYWxpZGF0aW9uRXJyb3JzLCBBc3luY1ZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBSdWxlc0VuZ2luZVNlcnZpY2UgfSBmcm9tIFwiLi4vcnVsZXMtZW5naW5lL3J1bGVzLWVuZ2luZS5zZXJ2aWNlXCI7XHJcbmltcG9ydCB7IFByb3BlcnR5IH0gZnJvbSBcIi4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Byb3BlcnR5XCI7XHJcbmltcG9ydCB7IEFycmF5SXRlbVByb3BlcnR5IH0gZnJvbSBcIi4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL2FycmF5LWl0ZW0tcHJvcGVydHlcIjtcclxuaW1wb3J0IHsgUHJvcGVydHlCYXNlIH0gZnJvbSBcIi4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Byb3BlcnR5LWJhc2VcIjtcclxuaW1wb3J0IHsgVHJhY2VTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3RyYWNlL3RyYWNlLnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgQmVoYXZpb3JTdWJqZWN0LCBvZiwgT3BlcmF0b3JGdW5jdGlvbiwgdGltZXIsIGVtcHR5LCBFTVBUWSB9IGZyb20gXCJyeGpzXCI7XHJcbmltcG9ydCB7IG1hcCwgdGFwLCBzd2l0Y2hNYXAsIHRha2UsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBkZWJvdW5jZSB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xyXG5pbXBvcnQgeyBUZXN0UmVzdWx0c0Jhc2UgfSBmcm9tIFwiLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1yZXN1bHRzLWJhc2VcIjtcclxuaW1wb3J0IHsgUmVhY3RpdmVGb3Jtc1ZhbGlkYXRpb25FcnJvcnMgfSBmcm9tIFwiLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcmVhY3RpdmUtZm9ybXMtdmFsaWRhdGlvbi1lcnJvcnNcIjtcclxuaW1wb3J0IHsgUmVhY3RpdmVGb3Jtc0ZhaWxlZFZhbGRhdGlvbiB9IGZyb20gXCIuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9yZWFjdGl2ZS1mb3Jtcy1mYWlsZWQtdmFsaWRhdGlvblwiO1xyXG5pbXBvcnQgeyBSZWFjdGl2ZUZvcm1zVmFsaWRhdGlvbkVycm9yc0RhdGEgfSBmcm9tIFwiLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcmVhY3RpdmUtZm9ybXMtdmFsaWRhdGlvbi1lcnJvcnMtZGF0YVwiO1xyXG5pbXBvcnQgeyBDb250cm9sU3RhdGUgfSBmcm9tIFwiLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvY29udHJvbC1zdGF0ZVwiO1xyXG5pbXBvcnQgeyBDb21tb25TZXJ2aWNlIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL2NvbW1vbi9jb21tb24uc2VydmljZVwiO1xyXG5pbXBvcnQgeyBBYnN0cmFjdE1vZGVsU2V0dGluZ3MgfSBmcm9tIFwiLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvYWJzdHJhY3QtbW9kZWwtc2V0dGluZ3NcIjtcclxuaW1wb3J0IHsgVmFsdWVDaGFuZ2VPcHRpb25zIH0gZnJvbSBcIi4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3ZhbHVlLWNoYW5nZS1vcHRpb25zXCI7XHJcbmltcG9ydCB7IEFkZEFycmF5SXRlbVByb3BlcnR5T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9hZGQtYXJyYXktaXRlbS1wcm9wZXJ0eS1vcHRpb25zXCI7XHJcbmltcG9ydCB7IFVwZGF0ZU9uIH0gZnJvbSBcIi4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3VwZGF0ZS1vblwiO1xyXG4vLyB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aFxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyByZWFjdGl2ZSBmb3JtcyB1c2luZyBjb25maWd1cmVkIG1vZGVsIHNldHRpbmdzXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBSZWFjdGl2ZUZvcm1zUnVsZVNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRk9STV9NT0RFTF9TRVRUSU5HU19QUk9QRVJUWV9OQU1FID0gJ25nRm9ybVJ1bGVzTW9kZWxTZXR0aW5nJztcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEZPUkNFX0FTWU5DX1ZBTElEX1RFU1RfUlVOX1BST1BFUlRZX05BTUUgPSAnbmdGb3JtUnVsZXNGb3JjZUFzeW5jVmFsaWRUZXN0UnVuJztcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPTlRST0xfTEFTVF9FUlJPUiA9ICduZ0Zvcm1SdWxlc0NvbnRyb2xMYXN0RXJyb3InO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgcnVsZXNFbmdpbmVTdmM6IFJ1bGVzRW5naW5lU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIGZvcm1CdWlsZGVyOiBGb3JtQnVpbGRlcixcclxuICAgICAgICBwcml2YXRlIHRyYWNlU3ZjOiBUcmFjZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBjb21tb25TdmM6IENvbW1vblNlcnZpY2VcclxuICAgICkge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBtb2RlbCBzZXR0aW5ncyB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIG1vZGVsIHNldHRpbmdcclxuICAgICAqIEByZXR1cm5zIE1vZGVsIHNldHRpbmdzIHdpdGggdGhlIHByb3ZpZGVkIG5hbWVcclxuICAgICAqL1xyXG4gICAgZ2V0TW9kZWxTZXR0aW5nczxUPihuYW1lOiBzdHJpbmcpOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8VD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzRW5naW5lU3ZjLmdldE1vZGVsU2V0dGluZ3MobmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZm9ybSBncm91cCB1c2luZyBhbiBpbnN0YW5jZSBvZiBtb2RlbCBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIG1vZGVsU2V0dGluZ3MgTmFtZSBvZiB0aGUgbW9kZWwgc2V0dGluZyBvciBhbiBpbnN0YW5jZSBvZiBtb2RlbCBzZXR0aW5ncyB0byB1c2VcclxuICAgICAqIEBwYXJhbSBpbml0aWFsVmFsdWUgSW5pdGlhbCBkYXRhIHRvIHNldCB0aGUgZm9ybSB2YWx1ZXMgdG9cclxuICAgICAqIEByZXR1cm5zIEZvcm0gZ3JvdXAgY3JlYXRlZCBhY2NvcmRpbmcgdG8gZGVmaW5lZCBtb2RlbCBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBjcmVhdGVGb3JtR3JvdXA8VD4oXHJcbiAgICAgICAgbW9kZWxTZXR0aW5nczogc3RyaW5nIHwgQWJzdHJhY3RNb2RlbFNldHRpbmdzPFQ+LFxyXG4gICAgICAgIGluaXRpYWxWYWx1ZT86IGFueVxyXG4gICAgKTogRm9ybUdyb3VwIHtcclxuICAgICAgICBsZXQgc2V0dGluZ3M6IEFic3RyYWN0TW9kZWxTZXR0aW5nczxUPjtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlbFNldHRpbmdzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5ydWxlc0VuZ2luZVN2Yy5nZXRNb2RlbFNldHRpbmdzKG1vZGVsU2V0dGluZ3MgYXMgc3RyaW5nKTtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncykgdGhyb3cgbmV3IEVycm9yKGBObyBtb2RlbCBzZXR0aW5nIGZvdW5kIHdpdGggdGhlIG5hbWUgXCIke21vZGVsU2V0dGluZ3N9XCJgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIW1vZGVsU2V0dGluZ3MpIHRocm93IG5ldyBFcnJvcihgQWRob2MgbW9kZWwgc2V0dGluZyBwcm92aWRlZCBpcyBpbnZhbGlkYCk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzID0gbW9kZWxTZXR0aW5ncyBhcyBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8VD47XHJcbiAgICAgICAgICAgIHRoaXMucnVsZXNFbmdpbmVTdmMuaW5pdGlhbGl6ZU1vZGVsU2V0dGluZyhzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyYWNlU3ZjLnRyYWNlKGBDcmVhdGluZyBmb3JtIGdyb3VwIHVzaW5nIG1vZGVsIHNldHRpbmdzIFwiJHtzZXR0aW5ncy5uYW1lfVwiYCk7XHJcbiAgICAgICAgY29uc3QgZm9ybUdyb3VwID0gdGhpcy5idWlsZEdyb3VwKHNldHRpbmdzLnByb3BlcnRpZXMsIGluaXRpYWxWYWx1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMudHJhY2VTdmMudHJhY2UoYFNldHRpbmcgdXAgZGVwZW5kZW5jeSBzdWJzY3JpcHRpb25zYCk7XHJcbiAgICAgICAgdGhpcy5yZXNldERlcGVuZGVuY3lTdWJzY3JpcHRpb25zKGZvcm1Hcm91cCwgc2V0dGluZ3MucHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgIHRoaXMudHJhY2VTdmMudHJhY2UoYFBhdGNoaW5nIGZvcm0gZ3JvdXAgd2l0aCBpbml0aWFsIHZhbHVlYCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyVmFsdWVDaGFuZ2UoZm9ybUdyb3VwKTtcclxuXHJcbiAgICAgICAgdGhpcy50cmFjZVN2Yy50cmFjZShgQXR0YWNoaW5nIG1vZGVsIHNldHRpbmdzIHRvIGZvcm1gKTtcclxuICAgICAgICB0aGlzLmF0dGFjaE1vZGVsU2V0dGluZ3NUb0Zvcm0oZm9ybUdyb3VwLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtR3JvdXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGFycmF5IGl0ZW0gcHJvcGVydHkgdG8gYW4gZXhpc3RpbmcgZm9ybSBhcnJheVxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IEFycmF5SXRlbVByb3BlcnR5IHRvIGZvciB0aGUgYXJyYXkgaXRlbSB0byBiZSBhZGRlZFxyXG4gICAgICogQHBhcmFtIHBhcmVudEZvcm1BcnJheSBUaGUgcGFyZW50IEZvcm1BcnJheVxyXG4gICAgICogQHBhcmFtIGluaXRpYWxWYWx1ZSBJbml0aWFsIHZhbHVlIG9mIHRoZSBmb3JtIGFycmF5IGl0ZW1cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGFkZGluZyBuZXcgYXJyYXkgaXRlbSBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBhZGRBcnJheUl0ZW1Qcm9wZXJ0eUNvbnRyb2w8VD4oXHJcbiAgICAgICAgcHJvcGVydHk6IEFycmF5SXRlbVByb3BlcnR5PFQ+LFxyXG4gICAgICAgIHBhcmVudEZvcm1BcnJheTogRm9ybUFycmF5LFxyXG4gICAgICAgIGluaXRpYWxWYWx1ZT86IGFueSxcclxuICAgICAgICBvcHRpb25zPzogQWRkQXJyYXlJdGVtUHJvcGVydHlPcHRpb25zXHJcbiAgICApOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjb250cm9sID0gdGhpcy5idWlsZEFic3RyYWN0Q29udHJvbChwcm9wZXJ0eSwgaW5pdGlhbFZhbHVlKTtcclxuICAgICAgICBjb25zdCB3aWxsQmVMYXN0SXRlbSA9ICFvcHRpb25zIHx8ICF0aGlzLmNvbW1vblN2Yy5pc1plcm9PckdyZWF0ZXIob3B0aW9ucy5pbmRleCkgfHwgb3B0aW9ucy5pbmRleCA+PSBwYXJlbnRGb3JtQXJyYXkubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAod2lsbEJlTGFzdEl0ZW0pXHJcbiAgICAgICAgICAgIHBhcmVudEZvcm1BcnJheS5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcGFyZW50Rm9ybUFycmF5Lmluc2VydChvcHRpb25zLmluZGV4LCBjb250cm9sKTtcclxuXHJcbiAgICAgICAgY29uc3QgbW9kZWxTZXR0aW5ncyA9IHRoaXMuZ2V0TW9kZWxTZXR0aW5nc0Zyb21Gb3JtKHBhcmVudEZvcm1BcnJheS5yb290IGFzIEZvcm1Hcm91cCk7XHJcbiAgICAgICAgdGhpcy5yZXNldERlcGVuZGVuY3lTdWJzY3JpcHRpb25zKHBhcmVudEZvcm1BcnJheS5yb290LCBtb2RlbFNldHRpbmdzLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSB0aGUgaXRlbSBjb3VsZCBoYXZlIGJlZW4gYWRkZWQgYXQgYW55IGluZGV4IGluIHRoZSBhcnJheSwgYW5kIHdlIG5lZWRcclxuICAgICAgICAvLyB0cmlnZ2VyIGEgdmFsdWUgY2hhbmdlIHRvIHRyaWdnZXIgYW55IGRlcGVuZGVuY3kgcHJvcGVydGl5IHZhbGRpZGF0aW9uc1xyXG4gICAgICAgIHRoaXMudHJpZ2dlclZhbHVlQ2hhbmdlKHBhcmVudEZvcm1BcnJheSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmRzIHZhbGlkYXRvcnMgZ2VuZXJhdGVkIGJ5IG5nLWZvcm0tcnVsZXMgd2l0aCB5b3VyIG93biB2YWxpZGF0b3JzXHJcbiAgICAgKiBAcGFyYW0gY29udHJvbCBDb250cm9sIHRvIGV4dGVuZHMgdGhlIHZhbGlkYXRvcnMgZm9yXHJcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yIFZhbGlkYXRvciB0byBhZGRcclxuICAgICAqL1xyXG4gICAgZXh0ZW5kVmFsaWRhdG9yKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCwgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbiB8IFZhbGlkYXRvckZuW10pOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXZhbGlkYXRvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB2YWxpZGF0b3JBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsaWRhdG9yKSA/IHZhbGlkYXRvciA6IFt2YWxpZGF0b3JdO1xyXG4gICAgICAgIGNvbnRyb2wuc2V0VmFsaWRhdG9ycyhbY29udHJvbC52YWxpZGF0b3IsIC4uLnZhbGlkYXRvckFycmF5XVxyXG4gICAgICAgICAgICAuZmlsdGVyKHZhbGlkYXRvckZuID0+ICEhdmFsaWRhdG9yRm4pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYXN5bmMgdmFsaWRhdG9ycyBnZW5lcmF0ZWQgYnkgbmctZm9ybS1ydWxlcyB3aXRoIHlvdXIgb3duIGFzeW5jIHZhbGlkYXRvcnNcclxuICAgICAqIEBwYXJhbSBjb250cm9sIENvbnRyb2wgdG8gZXh0ZW5kcyB0aGUgYXN5bmMgdmFsaWRhdG9ycyBmb3JcclxuICAgICAqIEBwYXJhbSBhc3luY1ZhbGlkYXRvciBBc3luYyB2YWxpZGF0b3IgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGV4dGVuZEFzeW5jVmFsaWRhdG9yKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCwgYXN5bmNWYWxpZGF0b3I6IEFzeW5jVmFsaWRhdG9yRm4gfCBBc3luY1ZhbGlkYXRvckZuW10pOiB2b2lkIHtcclxuICAgICAgICBpZiAoIWFzeW5jVmFsaWRhdG9yKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGFzeW5jVmFsaWRhdG9yQXJyYXkgPSBBcnJheS5pc0FycmF5KGFzeW5jVmFsaWRhdG9yKSA/IGFzeW5jVmFsaWRhdG9yIDogW2FzeW5jVmFsaWRhdG9yXTtcclxuICAgICAgICBjb250cm9sLnNldEFzeW5jVmFsaWRhdG9ycyhbY29udHJvbC5hc3luY1ZhbGlkYXRvciwgLi4uYXN5bmNWYWxpZGF0b3JBcnJheV1cclxuICAgICAgICAgICAgLmZpbHRlcihhc3luY1ZhbGlkYXRvckZuID0+ICEhYXN5bmNWYWxpZGF0b3JGbikpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRBYnN0cmFjdENvbnRyb2w8VD4ocHJvcGVydHk6IFByb3BlcnR5QmFzZTxUPiwgaW5pdGlhbFZhbHVlPzogYW55KTogQWJzdHJhY3RDb250cm9sIHtcclxuICAgICAgICBsZXQgY29udHJvbDogQWJzdHJhY3RDb250cm9sO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydHkuYXJyYXlJdGVtUHJvcGVydHkpIGNvbnRyb2wgPSB0aGlzLmJ1aWxkQXJyYXkocHJvcGVydHkuYXJyYXlJdGVtUHJvcGVydHksIGluaXRpYWxWYWx1ZSwgcHJvcGVydHkudXBkYXRlT24pO1xyXG4gICAgICAgIGVsc2UgaWYgKHByb3BlcnR5LnByb3BlcnRpZXMpIGNvbnRyb2wgPSB0aGlzLmJ1aWxkR3JvdXAocHJvcGVydHkucHJvcGVydGllcywgaW5pdGlhbFZhbHVlLCBwcm9wZXJ0eS51cGRhdGVPbik7XHJcbiAgICAgICAgZWxzZSBjb250cm9sID0gdGhpcy5idWlsZENvbnRyb2woaW5pdGlhbFZhbHVlLCBwcm9wZXJ0eS51cGRhdGVPbik7XHJcblxyXG4gICAgICAgIC8vIHNldHVwIHZhbGlkYXRpb24gdGVzdHMgb24gdmFsdWUgY2hhbmdlXHJcbiAgICAgICAgY29udHJvbC5zZXRWYWxpZGF0b3JzKHRoaXMuYnVpbGRWYWxpZGF0b3JGdW5jdGlvbihwcm9wZXJ0eSkpO1xyXG4gICAgICAgIGNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHRoaXMuYnVpbGRBc3luY1ZhbGlkYXRvckZ1bmN0aW9uKHByb3BlcnR5KSk7XHJcblxyXG4gICAgICAgIC8vIHNldHVwIGVkaXQgdGVzdHMgb24gdmFsdWUgY2hhbmdlXHJcbiAgICAgICAgY29udHJvbC52YWx1ZUNoYW5nZXNcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VmFsdWVDaGFuZ2VPcHRpb25zKHByb3BlcnR5LnZhbHVlQ2hhbmdlT3B0aW9ucy5zZWxmLmVkaXQpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlcnNpc3RFZGl0VGVzdHMoY29udHJvbCwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2w7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZENvbnRyb2w8VD4oaW5pdGlhbFZhbHVlOiBhbnksIHVwZGF0ZU9uPzogVXBkYXRlT24pOiBGb3JtQ29udHJvbCB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbChpbml0aWFsVmFsdWUsIHsgdXBkYXRlT246IHVwZGF0ZU9uIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRHcm91cDxUPihwcm9wZXJ0aWVzOiBQcm9wZXJ0eTxUPltdLCBpbml0aWFsVmFsdWU6IGFueSwgdXBkYXRlT24/OiBVcGRhdGVPbik6IEZvcm1Hcm91cCB7XHJcbiAgICAgICAgY29uc3QgZm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSwgeyB1cGRhdGVPbjogdXBkYXRlT24gfSk7XHJcblxyXG4gICAgICAgIChwcm9wZXJ0aWVzIHx8IFtdKS5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gaW5pdGlhbFZhbHVlID8gaW5pdGlhbFZhbHVlW3AubmFtZV0gOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5idWlsZEFic3RyYWN0Q29udHJvbChwLCBwcm9wZXJ0eVZhbHVlKTtcclxuICAgICAgICAgICAgZm9ybUdyb3VwLmFkZENvbnRyb2wocC5uYW1lLCBjdHJsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1Hcm91cDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkQXJyYXk8VD4ocHJvcGVydHk6IEFycmF5SXRlbVByb3BlcnR5PFQ+LCBpbml0aWFsVmFsdWU6IGFueVtdLCB1cGRhdGVPbj86IFVwZGF0ZU9uKTogRm9ybUFycmF5IHtcclxuICAgICAgICBpbml0aWFsVmFsdWUgPSBBcnJheS5pc0FycmF5KGluaXRpYWxWYWx1ZSkgPyBpbml0aWFsVmFsdWUgOiBbXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtQXJyYXkoXHJcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZS5tYXAodiA9PiB0aGlzLmJ1aWxkQWJzdHJhY3RDb250cm9sKHByb3BlcnR5LCB2KSksXHJcbiAgICAgICAgICAgIHsgdXBkYXRlT246IHVwZGF0ZU9uIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRWYWxpZGF0b3JGdW5jdGlvbjxUPihwcm9wZXJ0eTogUHJvcGVydHlCYXNlPFQ+KTogVmFsaWRhdG9yRm4ge1xyXG4gICAgICAgIGNvbnN0IHN5bmNHcm91cHMgPSB0aGlzLnJ1bGVzRW5naW5lU3ZjLmdyb3VwVGVzdHNCeVN5bmNUeXBlKHByb3BlcnR5LnZhbGlkKTtcclxuICAgICAgICBpZiAoIXN5bmNHcm91cHMuc3luYy5sZW5ndGgpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250cm9sQ29udGV4dFZhbHVlcyA9IHRoaXMuZ2V0Q29udHJvbENvbnRleHRWYWx1ZXMoY29udHJvbCwgcHJvcGVydHkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdHMgPSB0aGlzLnJ1bGVzRW5naW5lU3ZjXHJcbiAgICAgICAgICAgICAgICAucnVuVGVzdHMoY29udHJvbENvbnRleHRWYWx1ZXMucmVsYXRpdmUsIHN5bmNHcm91cHMuc3luYywge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3REYXRhOiBjb250cm9sQ29udGV4dFZhbHVlcy5yb290LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xTdGF0ZTogQ29udHJvbFN0YXRlLmNyZWF0ZShjb250cm9sKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGVzdFJlc3VsdHMucmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VTdmMudHJhY2UoYFZhbGlkYXRlZCBwcm9wZXJ0eSBcIiR7cHJvcGVydHkuYWJzb2x1dGVQYXRofVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVGVzdFJlc3VsdFN0YXRzU3RyaW5nKHRlc3RSZXN1bHRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcFRvUmVhY3RpdmVGb3Jtc1ZhbGlkYXRpb25FcnJvcnModGVzdFJlc3VsdHMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZEFzeW5jVmFsaWRhdG9yRnVuY3Rpb248VD4ocHJvcGVydHk6IFByb3BlcnR5QmFzZTxUPik6IEFzeW5jVmFsaWRhdG9yRm4ge1xyXG4gICAgICAgIGNvbnN0IHJhd0FzeW5jRnVuYyA9IHRoaXMuYnVpbGRBc3luY1ZhbGlkYXRvckZ1bmN0aW9uUmF3KHByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgaWYgKCFyYXdBc3luY0Z1bmMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEFic3RyYWN0Q29udHJvbD4obnVsbCk7XHJcbiAgICAgICAgY29uc3QgdmFsaWQkID0gdmFsdWVzLnBpcGUoXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlBc3luY1ZhbGlkVmFsdWVDaGFuZ2VPcHRpb25zKHByb3BlcnR5LnZhbHVlQ2hhbmdlT3B0aW9ucy5zZWxmLmFzeW5jVmFsaWQpLFxyXG4gICAgICAgICAgICBzd2l0Y2hNYXAoeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRocm91Z2ggbWVhbnMgd2UgZGlkIG5vdCBleGVjdXRlIHRoZSBuZy1mb3JtLXJ1bGVzIGFzeW5jIHRlc3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoeC5wYXNzdGhyb3VnaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFcnJvcnMgPSB4LmNvbnRyb2wuZXJyb3JzIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3ROZ0Zvcm1SdWxlc0Vycm9ycyA9IHRoaXMuZ2V0TGFzdEVycm9yRm9yQ29udHJvbCh4LmNvbnRyb2wpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGxhc3QgbmctZm9ybS1ydWxlcyBlcnJvcnMgKGlmIGFueSkgYWxvbmdzaWRlIG5vbiBuZy1mb3JtLXJ1bGVzIGVycm9ycy5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGhhbmRsZXMgc2NlbmFyaW8gd2hlcmUgZGVib3VuY2UgYW5kIGRpc3RpbmN0IGFyZSB1c2VkIGFuZCBzdGF0ZSBnb2VzIGZyb206XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgaW52YWxpZCAtPiBtYWtlIGNoYW5nZXMgYW5kIGJhY2sgdGhlbSBvdXQgLT4gdmFsaWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YoT2JqZWN0LmFzc2lnbihjdXJyZW50RXJyb3JzLCB7IG5nRm9ybVJ1bGVzOiBsYXN0TmdGb3JtUnVsZXNFcnJvcnMgfSBhcyBSZWFjdGl2ZUZvcm1zVmFsaWRhdGlvbkVycm9ycykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF3QXN5bmNGdW5jKHguY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB0YWtlKDEpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBQcm9taXNlPFZhbGlkYXRpb25FcnJvcnM+IHwgT2JzZXJ2YWJsZTxWYWxpZGF0aW9uRXJyb3JzPiA9PiB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5uZXh0KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWQkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZEFzeW5jVmFsaWRhdG9yRnVuY3Rpb25SYXc8VD4ocHJvcGVydHk6IFByb3BlcnR5QmFzZTxUPik6IEFzeW5jVmFsaWRhdG9yRm4ge1xyXG4gICAgICAgIGNvbnN0IHN5bmNHcm91cHMgPSB0aGlzLnJ1bGVzRW5naW5lU3ZjLmdyb3VwVGVzdHNCeVN5bmNUeXBlKHByb3BlcnR5LnZhbGlkKTtcclxuICAgICAgICBpZiAoIXN5bmNHcm91cHMuYXN5bmMubGVuZ3RoKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udHJvbENvbnRleHRWYWx1ZXMgPSB0aGlzLmdldENvbnRyb2xDb250ZXh0VmFsdWVzKGNvbnRyb2wsIHByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVzRW5naW5lU3ZjLnJ1blRlc3RzQXN5bmMoY29udHJvbENvbnRleHRWYWx1ZXMucmVsYXRpdmUsIHN5bmNHcm91cHMuYXN5bmMsIHtcclxuICAgICAgICAgICAgICAgIHJvb3REYXRhOiBjb250cm9sQ29udGV4dFZhbHVlcy5yb290LFxyXG4gICAgICAgICAgICAgICAgY29udHJvbFN0YXRlOiBDb250cm9sU3RhdGUuY3JlYXRlKGNvbnRyb2wpXHJcbiAgICAgICAgICAgIH0pLnBpcGUoXHJcbiAgICAgICAgICAgICAgICB0YXAodGVzdFJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0UmVzdWx0cy5yZXN1bHRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlU3ZjLnRyYWNlKGBWYWxpZGF0ZWQgKGFzeW5jKSBwcm9wZXJ0eSBcIiR7cHJvcGVydHkuYWJzb2x1dGVQYXRofVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRUZXN0UmVzdWx0U3RhdHNTdHJpbmcodGVzdFJlc3VsdHMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIG1hcCh0aGlzLm1hcFRvUmVhY3RpdmVGb3Jtc1ZhbGlkYXRpb25FcnJvcnMpLFxyXG4gICAgICAgICAgICAgICAgdGFwKHggPT4gdGhpcy5zZXRMYXN0RXJyb3JGb3JDb250cm9sKGNvbnRyb2wsICh4IHx8IHt9KS5uZ0Zvcm1SdWxlcykpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0RGVwZW5kZW5jeVN1YnNjcmlwdGlvbnM8VD4oXHJcbiAgICAgICAgcGFyZW50Q29udHJvbDogQWJzdHJhY3RDb250cm9sLFxyXG4gICAgICAgIHByb3BlcnRpZXM6IFByb3BlcnR5QmFzZTxUPltdLFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVEZXBlbmRlbmN5U3Vic2NyaXB0aW9ucyhwcm9wZXJ0aWVzKTtcclxuICAgICAgICB0aGlzLmFkZERlcGVuZGVuY3lTdWJzY3JpcHRpb25zKHBhcmVudENvbnRyb2wsIHByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVtb3ZlRGVwZW5kZW5jeVN1YnNjcmlwdGlvbnM8VD4oXHJcbiAgICAgICAgcHJvcGVydGllczogUHJvcGVydHlCYXNlPFQ+W11cclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIChwcm9wZXJ0aWVzIHx8IFtdKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcclxuICAgICAgICAgICAgcHJvcGVydHkuY2xlYXJEZXBlbmRlbmN5UHJvcGVydHlTdWJzY3JpcHRpb25zKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydHkucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZXBlbmRlbmN5U3Vic2NyaXB0aW9ucyhwcm9wZXJ0eS5wcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5LmFycmF5SXRlbVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlcGVuZGVuY3lTdWJzY3JpcHRpb25zKFtwcm9wZXJ0eS5hcnJheUl0ZW1Qcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhZGREZXBlbmRlbmN5U3Vic2NyaXB0aW9uczxUPihcclxuICAgICAgICBwYXJlbnRDb250cm9sOiBBYnN0cmFjdENvbnRyb2wsXHJcbiAgICAgICAgcHJvcGVydGllczogUHJvcGVydHlCYXNlPFQ+W10sXHJcbiAgICAgICAgYXJyYXlJbmRleD86IG51bWJlclxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgKHByb3BlcnRpZXMgfHwgW10pLmZvckVhY2gocHJvcGVydHkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUNvbnRyb2wgPSB0aGlzLmdldFByb3BlcnR5RnJvbVBhcmVudChwYXJlbnRDb250cm9sLCBwcm9wZXJ0eSwgYXJyYXlJbmRleCk7XHJcbiAgICAgICAgICAgIGlmICghcHJvcGVydHlDb250cm9sKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldHVwRWRpdGFiaWxpdHlEZXBlbmRlbmN5U3Vic2NyaXB0aW9ucyhwcm9wZXJ0eUNvbnRyb2wsIHBhcmVudENvbnRyb2wsIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgdGhpcy5zZXR1cFZhbGlkYXRpb25EZXBlbmRlbmN5U3Vic2NyaXB0aW9ucyhwcm9wZXJ0eUNvbnRyb2wsIHBhcmVudENvbnRyb2wsIHByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERlcGVuZGVuY3lTdWJzY3JpcHRpb25zKHByb3BlcnR5Q29udHJvbCwgcHJvcGVydHkucHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5hcnJheUl0ZW1Qcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYXJyYXlJdGVtUHJvcGVydHkgd2Uga25vdyB0aGF0IHdlIGFyZSB3b3JraW5nIHdpdGggYSBGb3JtQXJyYXkgY29udHJvbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybUFycmF5Q29udHJvbCA9IChwcm9wZXJ0eUNvbnRyb2wgYXMgRm9ybUFycmF5KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybUFycmF5Q29udHJvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRGVwZW5kZW5jeVN1YnNjcmlwdGlvbnMoZm9ybUFycmF5Q29udHJvbCwgW3Byb3BlcnR5LmFycmF5SXRlbVByb3BlcnR5XSwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldHVwVmFsaWRhdGlvbkRlcGVuZGVuY3lTdWJzY3JpcHRpb25zPFQ+KFxyXG4gICAgICAgIHByb3BlcnR5Q29udHJvbDogQWJzdHJhY3RDb250cm9sLCBwYXJlbnRDb250cm9sOiBBYnN0cmFjdENvbnRyb2wsIHByb3BlcnR5OiBQcm9wZXJ0eUJhc2U8VD5cclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lQcm9wTmFtZXMgPSB0aGlzLnJ1bGVzRW5naW5lU3ZjLmdldERlcGVuZGVuY3lQcm9wZXJ0aWVzKHByb3BlcnR5LnZhbGlkKTtcclxuXHJcbiAgICAgICAgZGVwZW5kZW5jeVByb3BOYW1lcy5mb3JFYWNoKGQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5Q29udHJvbCA9IHRoaXMuZmluZENvbnRyb2xSZWxhdGl2ZWx5KHBhcmVudENvbnRyb2wsIGQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkZXBlbmRlbmN5Q29udHJvbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc3ViJCA9IGRlcGVuZGVuY3lDb250cm9sLnZhbHVlQ2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVZhbHVlQ2hhbmdlT3B0aW9ucyhwcm9wZXJ0eS52YWx1ZUNoYW5nZU9wdGlvbnMuZGVwZW5kZW5jeVByb3BlcnRpZXMudmFsaWQpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZvcmNlQXN5bmNWYWxpZGF0aW9uVGVzdEZvckNvbnRyb2wocHJvcGVydHlDb250cm9sLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBwcm9wZXJ0eS5hZGREZXBlbmRlbmN5UHJvcGVydHlTdWJzY3JpcHRpb24oc3ViJCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZXR1cEVkaXRhYmlsaXR5RGVwZW5kZW5jeVN1YnNjcmlwdGlvbnM8VD4oXHJcbiAgICAgICAgcHJvcGVydHlDb250cm9sOiBBYnN0cmFjdENvbnRyb2wsXHJcbiAgICAgICAgcGFyZW50Q29udHJvbDogQWJzdHJhY3RDb250cm9sLFxyXG4gICAgICAgIHByb3BlcnR5OiBQcm9wZXJ0eUJhc2U8VD5cclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lQcm9wTmFtZXMgPSB0aGlzLnJ1bGVzRW5naW5lU3ZjLmdldERlcGVuZGVuY3lQcm9wZXJ0aWVzKHByb3BlcnR5LmVkaXQpO1xyXG5cclxuICAgICAgICBkZXBlbmRlbmN5UHJvcE5hbWVzLmZvckVhY2goZHBuID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGVwZW5kZW5jeUNvbnRyb2wgPSB0aGlzLmZpbmRDb250cm9sUmVsYXRpdmVseShwYXJlbnRDb250cm9sLCBkcG4pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkZXBlbmRlbmN5Q29udHJvbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0dXAgY29udHJvbCB0byBwZXJmb3JtIGVkaXQgdGVzdHMgd2hlbiBkZXBlbmRlbmN5IHByb3BlcnR5IGNoYW5nZXNcclxuICAgICAgICAgICAgY29uc3Qgc3ViJCA9IGRlcGVuZGVuY3lDb250cm9sLnZhbHVlQ2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVZhbHVlQ2hhbmdlT3B0aW9ucyhwcm9wZXJ0eS52YWx1ZUNoYW5nZU9wdGlvbnMuZGVwZW5kZW5jeVByb3BlcnRpZXMuZWRpdClcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyc2lzdEVkaXRUZXN0cyhwcm9wZXJ0eUNvbnRyb2wsIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcHJvcGVydHkuYWRkRGVwZW5kZW5jeVByb3BlcnR5U3Vic2NyaXB0aW9uKHN1YiQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcGVyc2lzdEVkaXRUZXN0czxUPihwcm9wZXJ0eUNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCwgcHJvcGVydHk6IFByb3BlcnR5QmFzZTxUPik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xDb250ZXh0VmFsdWVzID0gdGhpcy5nZXRDb250cm9sQ29udGV4dFZhbHVlcyhwcm9wZXJ0eUNvbnRyb2wsIHByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgdGhpcy5ydWxlc0VuZ2luZVN2Yy5lZGl0YWJsZShjb250cm9sQ29udGV4dFZhbHVlcy5yZWxhdGl2ZSwgcHJvcGVydHksIHtcclxuICAgICAgICAgICAgcm9vdERhdGE6IGNvbnRyb2xDb250ZXh0VmFsdWVzLnJvb3QsXHJcbiAgICAgICAgICAgIGNvbnRyb2xTdGF0ZTogQ29udHJvbFN0YXRlLmNyZWF0ZShwcm9wZXJ0eUNvbnRyb2wpXHJcbiAgICAgICAgfSkuc3Vic2NyaWJlKHRlc3RSZXN1bHRzID0+IHtcclxuICAgICAgICAgICAgaWYgKHRlc3RSZXN1bHRzLnJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlU3ZjLnRyYWNlKGBFZGl0YWJsZSBwcm9wZXJ0eSBcIiR7cHJvcGVydHkuYWJzb2x1dGVQYXRofVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVGVzdFJlc3VsdFN0YXRzU3RyaW5nKHRlc3RSZXN1bHRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0ZXN0UmVzdWx0cy5wYXNzZWQgJiYgcHJvcGVydHlDb250cm9sLmRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlDb250cm9sLmVuYWJsZSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0ZXN0UmVzdWx0cy5wYXNzZWQgJiYgcHJvcGVydHlDb250cm9sLmVuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvbnRyb2wuZGlzYWJsZSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhcHBseUFzeW5jVmFsaWRWYWx1ZUNoYW5nZU9wdGlvbnMoXHJcbiAgICAgICAgdmFsdWVDaGFuZ2VPcHRpb25zOiBWYWx1ZUNoYW5nZU9wdGlvbnNcclxuICAgICk6IE9wZXJhdG9yRnVuY3Rpb248QWJzdHJhY3RDb250cm9sLCBBc3luY1ZhbGlkYXRpb25QYXNzdGhyb3VnaGFibGU+IHtcclxuICAgICAgICByZXR1cm4gKHNvdXJjZSQ6IE9ic2VydmFibGU8QWJzdHJhY3RDb250cm9sPik6IE9ic2VydmFibGU8QXN5bmNWYWxpZGF0aW9uUGFzc3Rocm91Z2hhYmxlPiA9PiB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0VmFsdWU6IGFueTtcclxuICAgICAgICAgICAgbGV0IGlzRm9yY2U6IGJvb2xlYW47XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlJC5waXBlKFxyXG4gICAgICAgICAgICAgICAgdGFwKGNvbnRyb2wgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yY2UgPSB0aGlzLmRvZXNDb250cm9sSGF2ZUZvcmNlZEFzeW5jVmFsaWRhdGlvbihjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZvcmNlQXN5bmNWYWxpZGF0aW9uVGVzdEZvckNvbnRyb2woY29udHJvbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBkZWJvdW5jZSh4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGb3JjZSB8fCB2YWx1ZUNoYW5nZU9wdGlvbnMuZGVib3VuY2VNaWxsaXNlY29uZHMgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGltZXIodmFsdWVDaGFuZ2VPcHRpb25zLmRlYm91bmNlTWlsbGlzZWNvbmRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEVNUFRZO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBtYXAoY29udHJvbCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3Rocm91Z2g6ICEoY29udHJvbC52YWx1ZSAhPT0gbGFzdFZhbHVlIHx8ICF2YWx1ZUNoYW5nZU9wdGlvbnMuZGlzdGluY3RVbnRpbENoYW5nZWQgfHwgaXNGb3JjZSlcclxuICAgICAgICAgICAgICAgICAgICB9IGFzIEFzeW5jVmFsaWRhdGlvblBhc3N0aHJvdWdoYWJsZTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgdGFwKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgheC5wYXNzdGhyb3VnaCkgbGFzdFZhbHVlID0geC5jb250cm9sLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXBwbHlWYWx1ZUNoYW5nZU9wdGlvbnModmFsdWVDaGFuZ2VPcHRpb25zOiBWYWx1ZUNoYW5nZU9wdGlvbnMpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgYW55PiB7XHJcbiAgICAgICAgcmV0dXJuIChzb3VyY2UkOiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlJC5waXBlKFxyXG4gICAgICAgICAgICAgICAgZGVib3VuY2UoeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlQ2hhbmdlT3B0aW9ucy5kZWJvdW5jZU1pbGxpc2Vjb25kcyA+IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aW1lcih2YWx1ZUNoYW5nZU9wdGlvbnMuZGVib3VuY2VNaWxsaXNlY29uZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogRU1QVFk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlT3B0aW9ucy5kaXN0aW5jdFVudGlsQ2hhbmdlZCA/IGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkgOiB0YXAoKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRDb250cm9sQ29udGV4dFZhbHVlczxUPihjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsIHByb3BlcnR5OiBQcm9wZXJ0eTxUPiB8IEFycmF5SXRlbVByb3BlcnR5PFQ+KTogQ29udHJvbENvbnRleHRWYWx1ZXMge1xyXG4gICAgICAgIGNvbnN0IHJvb3RWYWx1ZSA9IChjb250cm9sLnJvb3QgYXMgRm9ybUdyb3VwKS5nZXRSYXdWYWx1ZSgpO1xyXG5cclxuICAgICAgICAvLyB1c2UgdGhlIGNvbnRyb2wgdmFsdWUgaWYgYW4gYXJyYXkgaXRlbSwgb3RoZXJ3aXNlIHVzZSB0aGUgcGFyZW50IGNvbnRyb2xcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVZhbHVlID0gUHJvcGVydHlCYXNlLmlzQXJyYXlJdGVtUHJvcGVydHkocHJvcGVydHkpXHJcbiAgICAgICAgICAgID8gY29udHJvbC52YWx1ZVxyXG4gICAgICAgICAgICA6IGNvbnRyb2wucGFyZW50LmdldFJhd1ZhbHVlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvb3Q6IHJvb3RWYWx1ZSxcclxuICAgICAgICAgICAgcmVsYXRpdmU6IHJlbGF0aXZlVmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0UHJvcGVydHlGcm9tUGFyZW50PFQ+KFxyXG4gICAgICAgIHBhcmVudENvbnRyb2w6IEFic3RyYWN0Q29udHJvbCxcclxuICAgICAgICBwcm9wZXJ0eTogUHJvcGVydHlCYXNlPFQ+LFxyXG4gICAgICAgIGFycmF5SW5kZXg/OiBudW1iZXJcclxuICAgICkge1xyXG4gICAgICAgIHJldHVybiBQcm9wZXJ0eUJhc2UuaXNBcnJheUl0ZW1Qcm9wZXJ0eShwcm9wZXJ0eSlcclxuICAgICAgICAgICAgPyAocGFyZW50Q29udHJvbCBhcyBGb3JtQXJyYXkpLmF0KGFycmF5SW5kZXgpXHJcbiAgICAgICAgICAgIDogcGFyZW50Q29udHJvbC5nZXQoKHByb3BlcnR5IGFzIFByb3BlcnR5PFQ+KS5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1hcFRvUmVhY3RpdmVGb3Jtc1ZhbGlkYXRpb25FcnJvcnM8VD4odGVzdFJlc3VsdHM6IFRlc3RSZXN1bHRzQmFzZTxUPik6IFJlYWN0aXZlRm9ybXNWYWxpZGF0aW9uRXJyb3JzIHtcclxuICAgICAgICAvLyBpZiBwYXNzZWQsIEFuZ3VsYXIgcmVhY3RpdmUgZm9ybXMgd2FudHMgdXMgdG8gcmV0dXJuIG51bGwsIG90aGVyd2lzZSByZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHZhbGlkYXRpb24gaW5mb1xyXG4gICAgICAgIGlmICghdGVzdFJlc3VsdHMgfHwgdGVzdFJlc3VsdHMucGFzc2VkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgZmFpbGVkOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0aXZlRm9ybXNGYWlsZWRWYWxkYXRpb24gfSA9IHt9O1xyXG5cclxuICAgICAgICB0ZXN0UmVzdWx0cy5mYWlsZWRSZXN1bHRzLmZvckVhY2godGVzdCA9PiB7XHJcbiAgICAgICAgICAgIGZhaWxlZFt0ZXN0Lm5hbWVdID0geyBtZXNzYWdlOiB0ZXN0Lm1lc3NhZ2UgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmdGb3JtUnVsZXM6IHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRlc3RSZXN1bHRzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICBmYWlsZWQ6IGZhaWxlZFxyXG4gICAgICAgICAgICB9IGFzIFJlYWN0aXZlRm9ybXNWYWxpZGF0aW9uRXJyb3JzRGF0YVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBmaW5kQ29udHJvbFJlbGF0aXZlbHkoY29udHJvbDogQWJzdHJhY3RDb250cm9sLCBwYXRoOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGhzID0gdGhpcy5idWlsZENvbnRyb2xSZWxhdGl2ZVBhdGhBcnJheShwYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZWxhdGl2ZVBhdGhzLmxlbmd0aCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQ6IEFic3RyYWN0Q29udHJvbDtcclxuICAgICAgICByZWxhdGl2ZVBhdGhzLmZvckVhY2gocGF0aFNlZ21lbnQgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldENvbnRyb2xCeVBhdGhTZWdtZW50KHJlc3VsdCB8fCBjb250cm9sLCBwYXRoU2VnbWVudCk7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZENvbnRyb2xSZWxhdGl2ZVBhdGhBcnJheShyZWxhdGl2ZVBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICAgICAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgIGlmICghcmVsYXRpdmVQYXRoIHx8IHR5cGVvZiByZWxhdGl2ZVBhdGggIT09IFwic3RyaW5nXCIpIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIC8vIHRha2VzIGNhcmUgb2YgJy4vJywgJy4uLycsIGFuZCAnLydcclxuICAgICAgICBjb25zdCBzbGFzaFNlcGFyYXRlZCA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XHJcblxyXG4gICAgICAgIHNsYXNoU2VwYXJhdGVkLmZvckVhY2goc2xhc2hJdGVtID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG90U2VwYXJhdGVkID0gc2xhc2hJdGVtLnNwbGl0KFwiLlwiKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihkb3RJdGVtID0+ICEhZG90SXRlbSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZG90U2VwYXJhdGVkLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmRvdFNlcGFyYXRlZCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsYXNoSXRlbSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRDb250cm9sQnlQYXRoU2VnbWVudChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsIHBhdGhTZWdtZW50OiBzdHJpbmcpOiBBYnN0cmFjdENvbnRyb2wge1xyXG4gICAgICAgIHN3aXRjaCAocGF0aFNlZ21lbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wucm9vdDtcclxuICAgICAgICAgICAgY2FzZSBcIi4uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGNhc2UgXCIuXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sLmdldChwYXRoU2VnbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRUZXN0UmVzdWx0U3RhdHNTdHJpbmc8VD4odGVzdFJlc3VsdHM6IFRlc3RSZXN1bHRzQmFzZTxUPikge1xyXG4gICAgICAgIHJldHVybiBgRXhlY3V0ZWQgJHt0ZXN0UmVzdWx0cy5yZXN1bHRzLmxlbmd0aH0gdGVzdHMgYCArXHJcbiAgICAgICAgICAgIGAoJHt0ZXN0UmVzdWx0cy5wYXNzZWRSZXN1bHRzLmxlbmd0aH0gUEFTUyB8IGAgK1xyXG4gICAgICAgICAgICBgJHt0ZXN0UmVzdWx0cy5mYWlsZWRSZXN1bHRzLmxlbmd0aH0gRkFJTCB8IGBcclxuICAgICAgICAgICAgKyBgJHt0ZXN0UmVzdWx0cy5za2lwcGVkUmVzdWx0cy5sZW5ndGh9IFNLSVApYDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGF0dGFjaE1vZGVsU2V0dGluZ3NUb0Zvcm08VD4oZm9ybUdyb3VwOiBGb3JtR3JvdXAsIG1vZGVsU2V0dGluZ3M6IEFic3RyYWN0TW9kZWxTZXR0aW5nczxUPik6IHZvaWQge1xyXG4gICAgICAgIGZvcm1Hcm91cFtSZWFjdGl2ZUZvcm1zUnVsZVNlcnZpY2UuRk9STV9NT0RFTF9TRVRUSU5HU19QUk9QRVJUWV9OQU1FXSA9IG1vZGVsU2V0dGluZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRNb2RlbFNldHRpbmdzRnJvbUZvcm08VD4oZm9ybUdyb3VwOiBGb3JtR3JvdXApOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8VD4ge1xyXG4gICAgICAgIHJldHVybiBmb3JtR3JvdXBbUmVhY3RpdmVGb3Jtc1J1bGVTZXJ2aWNlLkZPUk1fTU9ERUxfU0VUVElOR1NfUFJPUEVSVFlfTkFNRV0gYXMgQWJzdHJhY3RNb2RlbFNldHRpbmdzPFQ+O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0Rm9yY2VBc3luY1ZhbGlkYXRpb25UZXN0Rm9yQ29udHJvbChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsIGZvcmNlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgY29udHJvbFtSZWFjdGl2ZUZvcm1zUnVsZVNlcnZpY2UuRk9SQ0VfQVNZTkNfVkFMSURfVEVTVF9SVU5fUFJPUEVSVFlfTkFNRV0gPSBmb3JjZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldExhc3RFcnJvckZvckNvbnRyb2woY29udHJvbDogQWJzdHJhY3RDb250cm9sLCBlcnJvcnM6IFJlYWN0aXZlRm9ybXNWYWxpZGF0aW9uRXJyb3JzRGF0YSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnRyb2xbUmVhY3RpdmVGb3Jtc1J1bGVTZXJ2aWNlLkNPTlRST0xfTEFTVF9FUlJPUl0gPSBlcnJvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRMYXN0RXJyb3JGb3JDb250cm9sKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFJlYWN0aXZlRm9ybXNWYWxpZGF0aW9uRXJyb3JzRGF0YSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xbUmVhY3RpdmVGb3Jtc1J1bGVTZXJ2aWNlLkNPTlRST0xfTEFTVF9FUlJPUl07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkb2VzQ29udHJvbEhhdmVGb3JjZWRBc3luY1ZhbGlkYXRpb24oY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEhKGNvbnRyb2xbUmVhY3RpdmVGb3Jtc1J1bGVTZXJ2aWNlLkZPUkNFX0FTWU5DX1ZBTElEX1RFU1RfUlVOX1BST1BFUlRZX05BTUVdKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRyaWdnZXJWYWx1ZUNoYW5nZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiB2b2lkIHtcclxuICAgICAgICBjb250cm9sLnBhdGNoVmFsdWUoY29udHJvbC52YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb250cm9sQ29udGV4dFZhbHVlcyB7XHJcbiAgICByb290OiBhbnk7XHJcbiAgICByZWxhdGl2ZTogYW55O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXN5bmNWYWxpZGF0aW9uUGFzc3Rocm91Z2hhYmxlIHtcclxuICAgIGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbDtcclxuICAgIHBhc3N0aHJvdWdoOiBib29sZWFuO1xyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRyYWNlU2VydmljZSB9IGZyb20gJy4vdHJhY2UvdHJhY2Uuc2VydmljZSc7XHJcbmltcG9ydCB7IENvbW1vblNlcnZpY2UgfSBmcm9tICcuL2NvbW1vbi9jb21tb24uc2VydmljZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtdLFxyXG4gIGRlY2xhcmF0aW9uczogW10sXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICAgIFRyYWNlU2VydmljZSxcclxuICAgICAgQ29tbW9uU2VydmljZVxyXG4gIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIFV0aWxzTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBSdWxlc0VuZ2luZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL3J1bGVzLWVuZ2luZS9ydWxlcy1lbmdpbmUuc2VydmljZSc7XHJcbmltcG9ydCB7IFJlYWN0aXZlRm9ybXNSdWxlU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvcmVhY3RpdmUtZm9ybXMtcnVsZS9yZWFjdGl2ZS1mb3Jtcy1ydWxlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBSZWFjdGl2ZUZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBVdGlsc01vZHVsZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLm1vZHVsZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICBVdGlsc01vZHVsZVxyXG4gICAgXSxcclxuICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIFJ1bGVzRW5naW5lU2VydmljZSxcclxuICAgICAgICBSZWFjdGl2ZUZvcm1zUnVsZVNlcnZpY2VcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBSdWxlc0VuZ2luZU1vZHVsZSB7IH1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgUnVsZXNFbmdpbmVNb2R1bGUgfSBmcm9tICcuLi9ydWxlcy1lbmdpbmUvcnVsZXMtZW5naW5lLm1vZHVsZSc7XHJcblxyXG4vKipcclxuICogTWFpbiBtb2R1bGUgZm9yIG5nLWZvcm0tcnVsZXNcclxuICovXHJcbkBOZ01vZHVsZSh7XHJcbiAgaW1wb3J0czogW1xyXG4gICAgQ29tbW9uTW9kdWxlLFxyXG4gICAgUnVsZXNFbmdpbmVNb2R1bGUsXHJcbiAgXSxcclxuICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gIGV4cG9ydHM6IFtcclxuICAgICAgUnVsZXNFbmdpbmVNb2R1bGUsXHJcbiAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRm9ybVJ1bGVzTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBQcm9wZXJ0eUJhc2UgfSBmcm9tIFwiLi9wcm9wZXJ0eS1iYXNlXCI7XHJcblxyXG4vKipcclxuICogTm9uLWFycmF5IGl0ZW0gcHJvcGVydHlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eTxUPiBleHRlbmRzIFByb3BlcnR5QmFzZTxUPiB7XHJcbiAgICBwcml2YXRlIF9uYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBnZXQgbmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBQcm9wZXJ0eUJhc2UgfSBmcm9tIFwiLi9wcm9wZXJ0eS1iYXNlXCI7XHJcblxyXG4vKipcclxuICogQSBwcm9wZXJ0eSByZXByZXNlbnRpbmcgYW4gYXJyYXkgaXRlbSAoZS5nLiBhbiBhcnJheSBvZiBBZGRyZXNzIG9iamVjdHMpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXJyYXlJdGVtUHJvcGVydHk8VD4gZXh0ZW5kcyBQcm9wZXJ0eUJhc2U8VD4ge30iLCJpbXBvcnQgeyBQcm9wZXJ0eSB9IGZyb20gJy4uL21vZGVscy9wcm9wZXJ0eSc7XHJcbmltcG9ydCB7IFJ1bGVHcm91cCB9IGZyb20gJy4uL21vZGVscy9ydWxlLWdyb3VwJztcclxuaW1wb3J0IHsgUnVsZSB9IGZyb20gJy4uL21vZGVscy9ydWxlJztcclxuaW1wb3J0IHsgVGVzdCB9IGZyb20gJy4uL21vZGVscy90ZXN0JztcclxuaW1wb3J0IHsgQXJyYXlJdGVtUHJvcGVydHkgfSBmcm9tICcuLi9tb2RlbHMvYXJyYXktaXRlbS1wcm9wZXJ0eSc7XHJcbmltcG9ydCB7IFJ1bGVTZXQgfSBmcm9tICcuLi9tb2RlbHMvcnVsZS1zZXQnO1xyXG5pbXBvcnQgeyBSdWxlRnVuYyB9IGZyb20gJy4uL21vZGVscy9ydWxlLWZ1bmMnO1xyXG5pbXBvcnQgeyBSdWxlT3B0aW9ucyB9IGZyb20gJy4uL21vZGVscy9ydWxlLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBBc3luY1J1bGVGdW5jIH0gZnJvbSAnLi4vbW9kZWxzL2FzeW5jLXJ1bGUtZnVuYyc7XHJcbmltcG9ydCB7IFJ1bGVHcm91cE9wdGlvbnMgfSBmcm9tICcuLi9tb2RlbHMvcnVsZS1ncm91cC1vcHRpb25zJztcclxuaW1wb3J0IHsgUmVzdWx0c1Bhc3NSZXF1aXJlbWVudCB9IGZyb20gJy4uL21vZGVscy9yZXN1bHRzLXBhc3MtcmVxdWlyZW1lbnQnO1xyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIGJ1aWxkaW5nIG1vZGVsIHNldHRpbmdzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTW9kZWxTZXR0aW5nc0J1aWxkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZVxyXG4gICAgICogQHBhcmFtIGV4dGVuZCBGdW5jdGlvbiB0byBleHRlbmQgdGhlIHByb3BlcnR5XHJcbiAgICAgKiBAcmV0dXJucyBDcmVhdGVkIHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHByb3BlcnR5PFQ+KHByb3BlcnR5TmFtZToga2V5b2YgVCwgZXh0ZW5kPzogKHByb3A6IFByb3BlcnR5PFQ+KSA9PiB2b2lkKTogUHJvcGVydHk8VD4ge1xyXG4gICAgICAgIGlmICghcHJvcGVydHlOYW1lIHx8IHR5cGVvZiBwcm9wZXJ0eU5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSBuYW1lJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gbmV3IFByb3BlcnR5PFQ+KHByb3BlcnR5TmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChleHRlbmQpIGV4dGVuZChwcm9wZXJ0eSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgaXRlbSBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGV4dGVuZCBGdW5jdGlvbiB0byBleHRlbmQgdGhlIGFycmF5IGl0ZW0gcHJvcGVydHlcclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgYXJyYXkgaXRlbSBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBhcnJheUl0ZW1Qcm9wZXJ0eTxUPihleHRlbmQ/OiAocHJvcDogQXJyYXlJdGVtUHJvcGVydHk8VD4pID0+IHZvaWQpOiBBcnJheUl0ZW1Qcm9wZXJ0eTxUPiB7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBuZXcgQXJyYXlJdGVtUHJvcGVydHk8VD4oKTtcclxuXHJcbiAgICAgICAgaWYgKGV4dGVuZCkgZXh0ZW5kKHByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHZhbGlkYXRpb24gdGVzdFxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSB3aGVuIHRoZSB0ZXN0IGZhaWxzXHJcbiAgICAgKiBAcGFyYW0gY2hlY2sgQ2hlY2sgcnVsZSBzZXQgZm9yIHRoZSB0ZXN0XHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uIENvbmRpdGlvbiBydWxlIHNldCBmb3IgdGhlIHRlc3RcclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgdmFsaWRhdGlvbiB0ZXN0XHJcbiAgICAgKi9cclxuICAgIHZhbGlkVGVzdDxUPihtZXNzYWdlOiBzdHJpbmcsIGNoZWNrOiBSdWxlU2V0PFQ+LCBjb25kaXRpb24/OiBSdWxlU2V0PFQ+KTogVGVzdDxUPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWROYW1lZFRlc3QobnVsbCwgbWVzc2FnZSwgY2hlY2ssIGNvbmRpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmFtZWQgdmFsaWRhdGlvbiB0ZXN0XHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB0ZXN0XHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIHdoZW4gdGhlIHRlc3QgZmFpbHNcclxuICAgICAqIEBwYXJhbSBjaGVjayBDaGVjayBydWxlIHNldCBmb3IgdGhlIHRlc3RcclxuICAgICAqIEBwYXJhbSBjb25kaXRpb24gQ29uZGl0aW9uIHJ1bGUgc2V0IGZvciB0aGUgdGVzdFxyXG4gICAgICogQHJldHVybnMgQ3JlYXRlZCBuYW1lZCB2YWxpZGF0aW9uIHRlc3RcclxuICAgICAqL1xyXG4gICAgdmFsaWROYW1lZFRlc3Q8VD4obmFtZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGNoZWNrOiBSdWxlU2V0PFQ+LCBjb25kaXRpb24/OiBSdWxlU2V0PFQ+KTogVGVzdDxUPiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcclxuICAgICAgICAgICAgY2hlY2s6IGNoZWNrLFxyXG4gICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvblxyXG4gICAgICAgIH0gYXMgVGVzdDxUPjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZWRpdCB0ZXN0XHJcbiAgICAgKiBAcGFyYW0gY2hlY2sgQ2hlY2sgcnVsZSBzZXQgZm9yIHRoZSB0ZXN0XHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uIENvbmRpdGlvbiBydWxlIHNldCBmb3IgdGhlIHRlc3RcclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgZWRpdCB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGVkaXRUZXN0PFQ+KGNoZWNrOiBSdWxlU2V0PFQ+LCBjb25kaXRpb24/OiBSdWxlU2V0PFQ+KTogVGVzdDxUPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdE5hbWVkVGVzdChudWxsLCBjaGVjaywgY29uZGl0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuYW1lZCBlZGl0IHRlc3RcclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHRlc3RcclxuICAgICAqIEBwYXJhbSBjaGVjayBDaGVjayBydWxlIHNldCBmb3IgdGhlIHRlc3RcclxuICAgICAqIEBwYXJhbSBjb25kaXRpb24gQ29uZGl0aW9uIHJ1bGUgc2V0IGZvciB0aGUgdGVzdFxyXG4gICAgICogQHJldHVybnMgQ3JlYXRlZCBuYW1lZCBlZGl0IHRlc3RcclxuICAgICAqL1xyXG4gICAgZWRpdE5hbWVkVGVzdDxUPihuYW1lOiBzdHJpbmcsIGNoZWNrOiBSdWxlU2V0PFQ+LCBjb25kaXRpb24/OiBSdWxlU2V0PFQ+KTogVGVzdDxUPiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgY2hlY2s6IGNoZWNrLFxyXG4gICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvblxyXG4gICAgICAgIH0gYXMgVGVzdDxUPjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBydWxlXHJcbiAgICAgKiBAcGFyYW0gZnVuYyBGdW5jdGlvbiBmb3IgdGhlIHJ1bGVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgcnVsZSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyBDcmVhdGVkIHJ1bGVcclxuICAgICAqL1xyXG4gICAgcnVsZTxULCBSPihmdW5jOiBSdWxlRnVuYzxULCBSPiwgb3B0aW9ucz86IFJ1bGVPcHRpb25zKTogUnVsZTxUPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZUNvbWJvKGZ1bmMsIG51bGwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhc3luYyBydWxlXHJcbiAgICAgKiBAcGFyYW0gYXN5bmNGdW5jIEFzeW5jIGZ1bmN0aW9uIGZvciB0aGUgcnVsZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBydWxlIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgcnVsZVxyXG4gICAgICovXHJcbiAgICBydWxlQXN5bmM8VCwgUj4oYXN5bmNGdW5jOiBBc3luY1J1bGVGdW5jPFQsIFI+LCBvcHRpb25zPzogUnVsZU9wdGlvbnMpOiBSdWxlPFQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlQ29tYm8obnVsbCwgYXN5bmNGdW5jLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb21ibyBydWxlIHRoYXQgaGFzIGJvdGggc3luY3Jvbm91cyBhbmQgYXN5bmMgZnVuY3Rpb25zXHJcbiAgICAgKiBAcGFyYW0gZnVuYyBGdW5jdGlvbiBmb3IgdGhlIHJ1bGVcclxuICAgICAqIEBwYXJhbSBhc3luY0Z1bmMgQXN5bmMgZnVuY3Rpb24gZm9yIHRoZSBydWxlXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIHJ1bGUgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgQ3JlYXRlZCBydWxlXHJcbiAgICAgKi9cclxuICAgIHJ1bGVDb21ibzxULCBSPihmdW5jOiBSdWxlRnVuYzxULCBSPiwgYXN5bmNGdW5jOiBBc3luY1J1bGVGdW5jPFQsIFI+LCBvcHRpb25zPzogUnVsZU9wdGlvbnMpOiBSdWxlPFQ+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmdW5jOiBmdW5jLFxyXG4gICAgICAgICAgICBhc3luY0Z1bmM6IGFzeW5jRnVuYyxcclxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xyXG4gICAgICAgIH0gYXMgUnVsZTxUPjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBydWxlIGdyb3VwXHJcbiAgICAgKiBAcGFyYW0gcnVsZVNldHMgUnVsZSBzZXRzIGZvciB0aGUgcnVsZSBncm91cFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBydWxlIGdyb3VwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgcnVsZSBncm91cFxyXG4gICAgICovXHJcbiAgICBydWxlR3JvdXA8VD4ocnVsZVNldHM6IFJ1bGVTZXQ8VD5bXSwgb3B0aW9ucz86IFJ1bGVHcm91cE9wdGlvbnMpOiBSdWxlR3JvdXA8VD4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJ1bGVzOiBydWxlU2V0cyxcclxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7IHJlc3VsdFJlcXVpcmVtZW50czogUmVzdWx0c1Bhc3NSZXF1aXJlbWVudC5BbGxQYXNzIH1cclxuICAgICAgICB9IGFzIFJ1bGVHcm91cDxUPjtcclxuICAgIH1cclxufSIsImltcG9ydCB7IE1vZGVsU2V0dGluZ3NCdWlsZGVyIH0gZnJvbSBcIi4uL2hlbHBlci9tb2RlbC1zZXR0aW5ncy1idWlsZGVyXCI7XHJcbmltcG9ydCB7IFByb3BlcnR5IH0gZnJvbSBcIi4vcHJvcGVydHlcIjtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBtb2RlbCBzZXR0aW5nc1xyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0TW9kZWxTZXR0aW5nczxUPiB7XHJcbiAgICBwcml2YXRlIF9uYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBtb2RlbCBzZXR0aW5nXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZm9yIGJ1aWxkaW5nIHByb3BlcnRpZXMsIHRlc3RzLCBhbmQgcnVsZXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGJ1aWxkZXI6IE1vZGVsU2V0dGluZ3NCdWlsZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBjb25maWd1cmVkIGZvciB0aGUgbW9kZWwgc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgcHJvcGVydGllczogUHJvcGVydHk8VD5bXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbW9kZWwgc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIG1vZGVsIHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBNb2RlbFNldHRpbmdzQnVpbGRlcigpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHRoaXMuYnVpbGRQcm9wZXJ0aWVzKCkgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgdGhlIHByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGJ1aWxkUHJvcGVydGllcygpOiBQcm9wZXJ0eTxUPltdO1xyXG59IiwiaW1wb3J0IHsgVGVzdFJlc3VsdHNCYXNlIH0gZnJvbSBcIi4vdGVzdC1yZXN1bHRzLWJhc2VcIjtcclxuaW1wb3J0IHsgVGVzdFJlc3VsdCB9IGZyb20gXCIuL3Rlc3QtcmVzdWx0XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvcGVydHlUZXN0UmVzdWx0czxUPiBleHRlbmRzIFRlc3RSZXN1bHRzQmFzZTxUPiB7XHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcHJvcGVydHlOYW1lOiBzdHJpbmcsIHJlc3VsdHM6IFRlc3RSZXN1bHQ8VD5bXSkge1xyXG4gICAgICAgIHN1cGVyKHJlc3VsdHMpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgQWJzdHJhY3RNb2RlbFNldHRpbmdzIH0gZnJvbSBcIi4vYWJzdHJhY3QtbW9kZWwtc2V0dGluZ3NcIjtcclxuaW1wb3J0IHsgTW9kZWxTZXR0aW5nc0J1aWxkZXIgfSBmcm9tIFwiLi4vaGVscGVyL21vZGVsLXNldHRpbmdzLWJ1aWxkZXJcIjtcclxuaW1wb3J0IHsgUHJvcGVydHkgfSBmcm9tIFwiLi9wcm9wZXJ0eVwiO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBjcmVhdGluZyBhZGhvYyAobm9uLXJlZ2lzdGVyZWQpIG1vZGVsIHNldHRpbmdzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWRob2NNb2RlbFNldHRpbmdzPFQ+IGV4dGVuZHMgQWJzdHJhY3RNb2RlbFNldHRpbmdzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBtb2RlbCBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtIHByb3BlcnR5QnVpbGRlckZ1bmMgRnVuY3Rpb24gdGhhdCB0YWtlcyBhIE1vZGVsU2V0dGluZ3NCdWlsZGVyIGFuZCB1c2VzIGl0IHRvIHJldHVybiBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyBNb2RlbCBzZXR0aW5ncyBjb25maWd1cmVkIHdpdGggcHJvcGVydGllcyByZXR1cm5lZCBmcm9tIHRoZSAncHJvcGVydHlCdWlsZGVyRnVuYycgZnVuY3Rpb24gcGFyYW1ldGVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGU8VD4ocHJvcGVydHlCdWlsZGVyRnVuYzogKGJ1aWxkZXI6IE1vZGVsU2V0dGluZ3NCdWlsZGVyKSA9PiBQcm9wZXJ0eTxUPltdKTogQWJzdHJhY3RNb2RlbFNldHRpbmdzPFQ+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBBZGhvY01vZGVsU2V0dGluZ3MoKTtcclxuICAgICAgICBpbnN0YW5jZS5wcm9wZXJ0aWVzID0gISFwcm9wZXJ0eUJ1aWxkZXJGdW5jID8gcHJvcGVydHlCdWlsZGVyRnVuYyhpbnN0YW5jZS5idWlsZGVyKSB8fCBbXSA6IFtdO1xyXG5cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBzaW5jZSB0aGVzZSBzZXR0aW5ncyBhcmUgbm90IHJlZ2lzdGVyZWQsIGp1c3QgdXNlIGEgc3RhdGljIG5hbWVcclxuICAgICAgICBzdXBlcignYWRob2MnKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYnVpbGRQcm9wZXJ0aWVzKCk6IFByb3BlcnR5PFQ+W10ge1xyXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBuZWVkZWQgdG8gc2F0aXNmeSB0aGUgQWJzdHJhY3RNb2RlbFNldHRpbmdzPFQ+IGNvbnRyYWN0XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59IiwiLyoqXHJcbiAqIE9wdGlvbnMgZm9yIGhvdyBhbmQgd2hlbiB0byBwcm9jZXNzIHZhbHVlIGNoYW5nZXMgaW4gYSBmb3JtIGNvbnRyb2xcclxuICovXHJcbmV4cG9ydCBjbGFzcyBWYWx1ZUNoYW5nZU9wdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zaWRlciB2YWx1ZSBjaGFuZ2VkIG9ubHkgaWYgaXQgaXMgZGlmZmVyZW50XHJcbiAgICAgKi9cclxuICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbGxpc2Vjb25kcyB0byBkZWJvdW5jZSB2YWx1ZSBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIGRlYm91bmNlTWlsbGlzZWNvbmRzPzogbnVtYmVyO1xyXG59Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0FBS0EscUJBQVcsb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQVMscUJBQXFCLENBQUM7Ozs7OztBQ0xuRjs7O0FBS0EscUJBQVcsb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQVMscUJBQXFCLENBQUM7Ozs7OztBQ0xuRjs7OztJQUtJLFlBQ3NELFVBQW1CLEtBQUs7UUFBeEIsWUFBTyxHQUFQLE9BQU87S0FFNUQ7Ozs7O0lBRUQsS0FBSyxDQUFDLEdBQVc7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU87WUFBRSxPQUFPO1FBRTFCLHVCQUFNLE9BQU8sR0FBRyxXQUFXLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUN6RCxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3hCOzs7O0lBRU8sWUFBWTtRQUNoQixPQUFPLENBQUMsSUFBSSxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQzs7OztZQWY5QyxVQUFVOzs7OzRDQUdGLFFBQVEsWUFBSSxNQUFNLFNBQUMsb0JBQW9COzs7Ozs7O0FDTmhEOzs7Ozs7SUFTSSxNQUFNLENBQUMsTUFBYTtRQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUV0QyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUN0Qzs7Ozs7O0lBTUQsZUFBZSxDQUFDLEtBQWE7UUFDekIsSUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLEtBQUssQ0FBQztZQUFFLE9BQU8sSUFBSSxDQUFDO1FBRXZDLElBQUksQ0FBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUTtZQUFFLE9BQU8sS0FBSyxDQUFDO1FBRXRELE9BQU8sS0FBSyxHQUFHLENBQUMsQ0FBQztLQUNwQjs7O1lBdkJKLFVBQVU7Ozs7Ozs7Ozs7O0FDR1g7Ozs7SUFDSSxZQUFtQixPQUF3QjtRQUF4QixZQUFPLEdBQVAsT0FBTyxDQUFpQjtRQUN2QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0tBQ3JDOzs7OztJQUtELElBQUksTUFBTTtRQUNOLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQztLQUNyQzs7Ozs7SUFLRCxJQUFJLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUM3RDs7Ozs7SUFLRCxJQUFJLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUM5Qzs7Ozs7SUFLRCxJQUFJLGNBQWM7UUFDZCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ2hEOzs7OztJQUtELElBQUksT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMzQjs7Ozs7SUFLRCxJQUFJLFFBQVE7UUFDUix1QkFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN4RCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztLQUN4QztDQUNKOzs7Ozs7Ozs7OztBQzFDRDs7Z0RBRStELEVBQUU7Ozs7cUJBTTFDLEVBQUU7Ozs7b0JBS0gsRUFBRTs7Ozt3QkFvQkUsUUFBUTs7OztrQ0FtQzFCO1lBQ0Esb0JBQW9CLEVBQUU7Z0JBQ2xCLEtBQUssRUFBRSxFQUFFLG9CQUFvQixFQUFFLEtBQUssRUFBRSxvQkFBb0IsRUFBRSxDQUFDLEVBQUU7Z0JBQy9ELElBQUksRUFBRSxFQUFFLG9CQUFvQixFQUFFLEtBQUssRUFBRSxvQkFBb0IsRUFBRSxDQUFDLEVBQUU7YUFDakU7WUFDRCxJQUFJLEVBQUU7Z0JBQ0YsVUFBVSxFQUFFLEVBQUUsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLG9CQUFvQixFQUFFLENBQUMsRUFBRTtnQkFDcEUsSUFBSSxFQUFFLEVBQUUsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLG9CQUFvQixFQUFFLENBQUMsRUFBRTthQUNqRTtTQUNKOzs7Ozs7SUF2Q0QsSUFBSSxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0tBQzdCOzs7OztJQUtELElBQUksK0JBQStCO1FBQy9CLE9BQU8sSUFBSSxDQUFDLGdDQUFnQyxDQUFDO0tBQ2hEOzs7OztJQUtELElBQUksc0JBQXNCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLHVCQUF1QixDQUFDO0tBQ3ZDOzs7Ozs7O0lBOEJELE9BQU8sbUJBQW1CLENBQUksUUFBeUI7UUFDbkQsT0FBTyxDQUFDLG1CQUFDLFFBQXVCLEdBQUUsSUFBSSxDQUFDO0tBQzFDOzs7Ozs7SUFNRCxlQUFlLENBQUMsWUFBb0I7UUFDaEMsSUFBSSxDQUFDLGFBQWEsR0FBRyxZQUFZLENBQUM7S0FDckM7Ozs7OztJQU1ELGlDQUFpQyxDQUFDLFlBQTBCO1FBQ3hELElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDNUQ7Ozs7O0lBS0Qsb0NBQW9DO1FBQ2hDLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxFQUFFLENBQUM7S0FDOUM7Ozs7OztJQU1ELHlCQUF5QixDQUFDLElBQVk7UUFDbEMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksQ0FBQztLQUN2QztDQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pJRDs7O0FBeUJBOzs7Ozs7SUFHSSxZQUM4QyxVQUNsQyxVQUNBO1FBREEsYUFBUSxHQUFSLFFBQVE7UUFDUixjQUFTLEdBQVQsU0FBUztRQUVqQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxDQUFDO1FBRTdCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUFFLE9BQU87UUFFckMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPO1lBQ3BCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQztTQUNuRCxDQUFDLENBQUM7S0FDTjs7Ozs7O0lBTUQsc0JBQXNCLENBQUMsT0FBbUM7UUFDdEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5RDs7Ozs7OztJQU9ELGdCQUFnQixDQUFJLElBQVk7UUFDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsOEJBQThCLElBQUksR0FBRyxDQUFDLENBQUM7UUFFM0QsdUJBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7UUFHL0MsT0FBTyxRQUFRO2NBQ1QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO2NBQ2hELElBQUksQ0FBQztLQUNkOzs7Ozs7O0lBT0QsdUJBQXVCLENBQUksS0FBZ0I7UUFDdkMsSUFBSSxDQUFDLEtBQUs7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUV0Qix1QkFBTSxJQUFJLEdBQUcsS0FBSzthQUNiLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLCtCQUErQixDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pELE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxPQUFPLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV6RCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3RDOzs7Ozs7O0lBT0Qsb0JBQW9CLENBQUksS0FBZ0I7UUFDcEMsdUJBQU0sVUFBVSxxQkFBRztZQUNmLElBQUksRUFBRSxFQUFFO1lBQ1IsS0FBSyxFQUFFLEVBQUU7U0FDUyxDQUFBLENBQUM7UUFFdkIsSUFBSSxDQUFDLEtBQUs7WUFBRSxPQUFPLFVBQVUsQ0FBQztRQUU5QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUk7WUFDZCx1QkFBTSxhQUFhLHFCQUFHO2dCQUNsQixJQUFJLEVBQUUsS0FBSztnQkFDWCxLQUFLLEVBQUUsS0FBSzthQUNRLENBQUEsQ0FBQztZQUV6Qix1QkFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JFLHVCQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRTdELGFBQWEsQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUM7WUFDaEUsYUFBYSxDQUFDLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQzs7WUFHbkUsSUFBSSxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUs7Z0JBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0UsSUFBSSxhQUFhLENBQUMsS0FBSztnQkFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4RCxDQUFDLENBQUM7UUFFSCxPQUFPLFVBQVUsQ0FBQztLQUNyQjs7Ozs7Ozs7O0lBUUQsUUFBUSxDQUFJLElBQU8sRUFBRSxRQUFxQixFQUFFLEtBQW9CO1FBQzVELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7YUFDL0MsSUFBSSxDQUNELEdBQUcsQ0FBQyxDQUFDLE9BQStCO1lBQ2hDLE9BQU8sQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztZQUM3Qyx5QkFBTyxPQUFpQyxFQUFDO1NBQzVDLENBQUMsQ0FDTCxDQUFDO0tBQ1Q7Ozs7Ozs7Ozs7SUFRRCxRQUFRLENBQUksSUFBTyxFQUFFLFFBQXlCLEVBQUUsS0FBb0I7UUFDaEUsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQzthQUM5QyxJQUFJLENBQ0QsR0FBRyxDQUFDLENBQUMsT0FBK0I7WUFDaEMsT0FBTyxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDO1lBQzdDLHlCQUFPLE9BQWlDLEVBQUM7U0FDNUMsQ0FBQyxDQUNMLENBQUM7S0FDVDs7Ozs7Ozs7O0lBd0JELFFBQVEsQ0FBSSxJQUFPLEVBQUUsS0FBZ0IsRUFBRSxLQUFvQjtRQUN2RCxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07WUFBRSxPQUFPLElBQUksZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTVELHVCQUFNLFdBQVcsR0FBRyxLQUFLO2FBQ3BCLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3RDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRCLE9BQU8sSUFBSSxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDM0M7Ozs7Ozs7OztJQVFELGFBQWEsQ0FBSSxJQUFPLEVBQUUsS0FBZ0IsRUFBRSxLQUFvQjtRQUM1RCxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07WUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRWhFLHVCQUFNLFFBQVEsR0FBRyxLQUFLO2FBQ2pCLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFdkQsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDO2FBQ3BCLElBQUksQ0FDRCxHQUFHLENBQUMsV0FBVyxJQUFJLElBQUksZUFBZSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3hFLENBQUM7S0FDVDs7Ozs7Ozs7O0lBUUQsV0FBVyxDQUFJLElBQU8sRUFBRSxLQUFnQixFQUFFLEtBQW9CO1FBQzFELElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTTtZQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFaEUsdUJBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwRCx1QkFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUV4RSxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQ3ZCLFFBQVEsQ0FBQyxNQUFNO1lBQ1gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNO2dCQUFFLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXRDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztTQUM1RCxDQUFDLEVBQ0YsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNWLENBQUM7S0FDTDs7Ozs7Ozs7O0lBUUQsT0FBTyxDQUFJLElBQU8sRUFBRSxJQUFhLEVBQUUsS0FBb0I7UUFDbkQsSUFBSSxDQUFDLElBQUk7WUFBRSxPQUFPLElBQUksQ0FBQztRQUV2Qix1QkFBTSxnQkFBZ0IsR0FBa0IsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUN6Rix1QkFBTSxnQkFBZ0IsR0FBa0IsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbEcsdUJBQU0saUJBQWlCLEdBQWtCLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUV6Ryx1QkFBTSx1QkFBdUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2pGLElBQUksdUJBQXVCLEtBQUssaUJBQWlCLENBQUMsTUFBTTtZQUFFLE9BQU8saUJBQWlCLENBQUM7UUFFbkYsdUJBQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN4RSxRQUFRLGtCQUFrQjtZQUN0QixLQUFLLGlCQUFpQixDQUFDLE1BQU07Z0JBQ3pCLE9BQU8sZ0JBQWdCLENBQUM7WUFDNUIsS0FBSyxpQkFBaUIsQ0FBQyxNQUFNO2dCQUN6QixPQUFPLGdCQUFnQixDQUFDO1lBQzVCLEtBQUssaUJBQWlCLENBQUMsT0FBTyxDQUFDO1lBQy9CO2dCQUNJLE9BQU8saUJBQWlCLENBQUM7U0FDaEM7S0FDSjs7Ozs7Ozs7O0lBUUQsWUFBWSxDQUFJLElBQU8sRUFBRSxJQUFhLEVBQUUsS0FBb0I7UUFDeEQsSUFBSSxDQUFDLElBQUk7WUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUzQix1QkFBTSxnQkFBZ0IsR0FBa0IsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUN6Rix1QkFBTSxnQkFBZ0IsR0FBa0IsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbEcsdUJBQU0saUJBQWlCLEdBQWtCLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUV6Ryx1QkFBTSx3QkFBd0IsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkYsdUJBQU0sbUJBQW1CLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTlFLE9BQU8sd0JBQXdCO2FBQzFCLElBQUksQ0FDRCxPQUFPLENBQUMsdUJBQXVCO1lBQzNCLElBQUksdUJBQXVCLEtBQUssaUJBQWlCLENBQUMsTUFBTTtnQkFBRSxPQUFPLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBRXZGLE9BQU8sbUJBQW1CO2lCQUNyQixJQUFJLENBQ0QsR0FBRyxDQUFDLGtCQUFrQjtnQkFDbEIsUUFBUSxrQkFBa0I7b0JBQ3RCLEtBQUssaUJBQWlCLENBQUMsTUFBTTt3QkFDekIsT0FBTyxnQkFBZ0IsQ0FBQztvQkFDNUIsS0FBSyxpQkFBaUIsQ0FBQyxNQUFNO3dCQUN6QixPQUFPLGdCQUFnQixDQUFDO29CQUM1QixLQUFLLGlCQUFpQixDQUFDLE9BQU8sQ0FBQztvQkFDL0I7d0JBQ0ksT0FBTyxpQkFBaUIsQ0FBQztpQkFDaEM7YUFDSixDQUFDLENBQ0wsQ0FBQztTQUNULENBQUMsQ0FDTCxDQUFDO0tBQ1Q7Ozs7Ozs7OztJQVFELGNBQWMsQ0FBSSxJQUFPLEVBQUUsT0FBbUIsRUFBRSxLQUFvQjtRQUNoRSxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8saUJBQWlCLENBQUMsT0FBTyxDQUFDO1FBRS9DLHVCQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLE9BQU8sV0FBVztjQUNaLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLG9CQUFFLE9BQXVCLEdBQUUsS0FBSyxDQUFDO2NBQzNELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxvQkFBRSxPQUFrQixHQUFFLEtBQUssQ0FBQyxDQUFDO0tBQzNEOzs7Ozs7Ozs7SUFRRCxtQkFBbUIsQ0FBSSxJQUFPLEVBQUUsT0FBbUIsRUFBRSxLQUFvQjtRQUNyRSxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRW5ELHVCQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLE9BQU8sV0FBVztjQUNaLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLG9CQUFFLE9BQXVCLEdBQUUsS0FBSyxDQUFDO2NBQ2hFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLG9CQUFFLE9BQWtCLEdBQUUsS0FBSyxDQUFDLENBQUM7S0FDaEU7Ozs7Ozs7O0lBRU8sZ0JBQWdCLENBQUksSUFBTyxFQUFFLFNBQXVCLEVBQUUsS0FBb0I7UUFDOUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLO1lBQUUsT0FBTyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7UUFFdkQscUJBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztRQUNwQixxQkFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBRXJCLEtBQUsscUJBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDN0MsdUJBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsdUJBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztZQUU3RCxJQUFJLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxhQUFhLEVBQUUsU0FBUyxDQUFDO2dCQUFFLE9BQU8sYUFBYSxDQUFDO1lBRWxGLElBQUksYUFBYSxJQUFJLGlCQUFpQixDQUFDLE1BQU07Z0JBQUUsV0FBVyxFQUFFLENBQUM7aUJBQ3hELElBQUksYUFBYSxJQUFJLGlCQUFpQixDQUFDLE9BQU87Z0JBQUUsWUFBWSxFQUFFLENBQUM7U0FDdkU7O1FBR0QsSUFBSSxZQUFZLEtBQUssU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNO1lBQUUsT0FBTyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7O1FBRzlFLE9BQU8sV0FBVyxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUM7Ozs7Ozs7OztJQUdoRyxxQkFBcUIsQ0FBSSxJQUFPLEVBQUUsU0FBdUIsRUFBRSxLQUFvQjtRQUNuRixJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUs7WUFBRSxPQUFPLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzRCx1QkFBTSxvQkFBb0IsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUVoRyxPQUFPLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLElBQUksQ0FDdEMsR0FBRyxDQUFDLGNBQWM7WUFDZCx1QkFBTSxNQUFNLEdBQUc7Z0JBQ1gsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNO2dCQUN6RSxNQUFNLEVBQUUsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU07Z0JBQ3pFLE9BQU8sRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTTthQUM5RSxDQUFDO1lBRUYsdUJBQU0sZ0JBQWdCLEdBQUcsU0FBUyxDQUFDLE9BQU8sSUFBSSxFQUFFLGtCQUFrQixFQUFFLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRXJHLElBQUksZ0JBQWdCLENBQUMsa0JBQWtCLElBQUksc0JBQXNCLENBQUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFDMUYsT0FBTyxpQkFBaUIsQ0FBQyxNQUFNLENBQUM7WUFDcEMsSUFBSSxnQkFBZ0IsQ0FBQyxrQkFBa0IsSUFBSSxzQkFBc0IsQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxjQUFjLENBQUMsTUFBTTtnQkFDaEgsT0FBTyxpQkFBaUIsQ0FBQyxNQUFNLENBQUM7WUFDcEMsSUFBSSxNQUFNLENBQUMsT0FBTyxLQUFLLGNBQWMsQ0FBQyxNQUFNO2dCQUFFLE9BQU8saUJBQWlCLENBQUMsT0FBTyxDQUFDO1lBRS9FLE9BQU8saUJBQWlCLENBQUMsTUFBTSxDQUFDO1NBQ25DLENBQUMsQ0FDTCxDQUFDOzs7Ozs7Ozs7SUFHRSxXQUFXLENBQUksSUFBTyxFQUFFLElBQWEsRUFBRSxLQUFvQjtRQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUk7WUFBRSxPQUFPLGlCQUFpQixDQUFDLE9BQU8sQ0FBQztRQUVqRCx1QkFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQy9DLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQzs7Ozs7Ozs7O0lBR25GLGdCQUFnQixDQUFJLElBQU8sRUFBRSxJQUFhLEVBQUUsS0FBb0I7UUFDcEUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUztZQUFFLE9BQU8sRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXhFLHVCQUFNLFFBQVEsR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDL0MsdUJBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJO2NBQ3RCLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztjQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVyQyxPQUFPLFVBQVU7YUFDWixJQUFJLENBQ0QsR0FBRyxDQUFDLE1BQU0sSUFBSSxNQUFNLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUM5RSxDQUFDOzs7Ozs7OztJQWdCRix3QkFBd0IsQ0FBSSxhQUFnQyxFQUFFLFNBQXVCO1FBQ3pGLHVCQUFNLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxPQUFPLElBQUksRUFBRSxrQkFBa0IsRUFBRSxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVyRzs7UUFFSSxDQUFDLGFBQWEsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLElBQUksZ0JBQWdCLENBQUMsa0JBQWtCLElBQUksc0JBQXNCLENBQUMsT0FBTzs7O2lCQUdsSCxhQUFhLElBQUksaUJBQWlCLENBQUMsTUFBTSxJQUFJLGdCQUFnQixDQUFDLGtCQUFrQixJQUFJLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxFQUN0SDs7Ozs7OztJQUdFLFdBQVcsQ0FBSSxPQUFtQjtRQUN0Qyx1QkFBTSxJQUFJLHFCQUFHLE9BQWtCLENBQUEsQ0FBQztRQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7Ozs7Ozs7SUFHakMsK0JBQStCLENBQUksSUFBYTtRQUNwRCx1QkFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGtDQUFrQyxDQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6RSx1QkFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGtDQUFrQyxDQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzs7Ozs7OztJQUcxRCxrQ0FBa0MsQ0FBSSxPQUFtQjtRQUM3RCxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sRUFBRSxDQUFDO1FBRXhCLHVCQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFFNUIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzNCLHVCQUFNLFNBQVMscUJBQUcsT0FBdUIsQ0FBQSxDQUFDO1lBQzFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0NBQWtDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JGLENBQUMsQ0FBQztTQUNOO1FBRUQsdUJBQU0sSUFBSSxxQkFBRyxPQUFrQixDQUFBLENBQUM7UUFDaEMsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO1lBQ2xFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztTQUM1RTtRQUVELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7O0lBR2pDLG1CQUFtQixDQUFDLFVBQStCLEVBQUUsaUJBQXlCLEVBQUUsc0JBQThCLEVBQUU7UUFDcEgsSUFBSSxDQUFDLFVBQVU7WUFBRSxPQUFPO1FBRXhCLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSTtZQUNuQix1QkFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2hGLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMseUJBQXlCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUVsRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLGlCQUFpQixFQUFFLGVBQWUsQ0FBQyxDQUFDO2FBQ2pGO2lCQUFNLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUMvQixJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxlQUFlLENBQUMsQ0FBQzthQUMxRjtTQUNKLENBQUMsQ0FBQzs7Ozs7OztJQUdDLHVCQUF1QixDQUFDLFFBQTJCLEVBQUUsc0JBQThCLEVBQUU7UUFDekYsdUJBQU0sbUJBQW1CLEdBQUcsWUFBWSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZFLHVCQUFNLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLElBQUksR0FBRyxtQkFBQyxRQUF5QixHQUFFLElBQUksQ0FBQztRQUM3Rix1QkFBTSxRQUFRLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQztRQUN0Qyx1QkFBTSxlQUFlLEdBQUcsR0FBRyxtQkFBbUIsR0FBRyxRQUFRLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxzQkFBc0IsRUFBRSxDQUFDOztRQUdoRyxRQUFRLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRTFDLE9BQU8sZUFBZSxDQUFDOzs7Ozs7SUFHbkIsb0JBQW9CLENBQUMsUUFBMkI7UUFDcEQsUUFBUSxDQUFDLEtBQUs7YUFDVCxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzthQUMxQixPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXZELFFBQVEsQ0FBQyxJQUFJO2FBQ1IsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDMUIsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Ozs7OztJQUdsRCxzQkFBc0IsQ0FBSSxPQUFtQjtRQUNqRCxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQztRQUVuRCx1QkFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU5QyxJQUFJLFdBQVcsRUFBRTtZQUNiLHVCQUFNLFNBQVMscUJBQUcsT0FBdUIsQ0FBQSxDQUFDO1lBQzFDLHVCQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsS0FBSztpQkFDMUIsR0FBRyxDQUFDLEVBQUU7Z0JBQ0gsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDMUMsQ0FBQyxDQUFDO1lBRVAsT0FBTztnQkFDSCxJQUFJLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUMzQyxLQUFLLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQ2hELENBQUM7U0FDTDthQUFNO1lBQ0gsdUJBQU0sSUFBSSxxQkFBRyxPQUFrQixDQUFBLENBQUM7WUFDaEMsT0FBTztnQkFDSCxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJO2dCQUNqQixLQUFLLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTO2FBQzFCLENBQUM7U0FDTDs7OztZQTlkUixVQUFVOzs7O3dDQUtGLFFBQVEsWUFBSSxNQUFNLFNBQUMsb0JBQW9CO1lBbkJ2QyxZQUFZO1lBQ1osYUFBYTs7Ozs7Ozs7OztBQ050Qjs7OztnQkFPd0IsT0FBd0I7UUFDeEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQzs7Ozs7OztJQVF4QyxPQUFPLE1BQU0sQ0FBQyxPQUF3QjtRQUNsQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3BDO0NBQ0o7Ozs7OztBQ3hCRDs7O0FBeUJBOzs7Ozs7O0lBS0ksWUFDWSxnQkFDQSxhQUNBLFVBQ0E7UUFIQSxtQkFBYyxHQUFkLGNBQWM7UUFDZCxnQkFBVyxHQUFYLFdBQVc7UUFDWCxhQUFRLEdBQVIsUUFBUTtRQUNSLGNBQVMsR0FBVCxTQUFTO0tBRXBCOzs7Ozs7O0lBT0QsZ0JBQWdCLENBQUksSUFBWTtRQUM1QixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDckQ7Ozs7Ozs7O0lBUUQsZUFBZSxDQUNYLGFBQWdELEVBQ2hELFlBQWtCO1FBRWxCLHFCQUFJLFFBQWtDLENBQUM7UUFFdkMsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7WUFDbkMsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLG1CQUFDLGFBQXVCLEVBQUMsQ0FBQztZQUN6RSxJQUFJLENBQUMsUUFBUTtnQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxhQUFhLEdBQUcsQ0FBQyxDQUFDO1NBQzdGO2FBQU07WUFDSCxJQUFJLENBQUMsYUFBYTtnQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7WUFDL0UsUUFBUSxxQkFBRyxhQUF5QyxDQUFBLENBQUM7WUFDckQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN4RDtRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLDZDQUE2QyxRQUFRLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNuRix1QkFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRXJFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLDRCQUE0QixDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFbEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMseUJBQXlCLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRXBELE9BQU8sU0FBUyxDQUFDO0tBQ3BCOzs7Ozs7Ozs7O0lBU0QsMkJBQTJCLENBQ3ZCLFFBQThCLEVBQzlCLGVBQTBCLEVBQzFCLFlBQWtCLEVBQ2xCLE9BQXFDO1FBRXJDLHVCQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ2xFLHVCQUFNLGNBQWMsR0FBRyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUM7UUFFN0gsSUFBSSxjQUFjO1lBQ2QsZUFBZSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7WUFFOUIsZUFBZSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRW5ELHVCQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsd0JBQXdCLG1CQUFDLGVBQWUsQ0FBQyxJQUFpQixFQUFDLENBQUM7UUFDdkYsSUFBSSxDQUFDLDRCQUE0QixDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7UUFJbEYsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQzVDOzs7Ozs7O0lBT0QsZUFBZSxDQUFDLE9BQXdCLEVBQUUsU0FBc0M7UUFDNUUsSUFBSSxDQUFDLFNBQVM7WUFBRSxPQUFPO1FBRXZCLHVCQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzFFLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEdBQUcsY0FBYyxDQUFDO2FBQ3ZELE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7S0FDOUM7Ozs7Ozs7SUFPRCxvQkFBb0IsQ0FBQyxPQUF3QixFQUFFLGNBQXFEO1FBQ2hHLElBQUksQ0FBQyxjQUFjO1lBQUUsT0FBTztRQUU1Qix1QkFBTSxtQkFBbUIsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLGNBQWMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzlGLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsR0FBRyxtQkFBbUIsQ0FBQzthQUN0RSxNQUFNLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQztLQUN4RDs7Ozs7OztJQUVPLG9CQUFvQixDQUFJLFFBQXlCLEVBQUUsWUFBa0I7UUFDekUscUJBQUksT0FBd0IsQ0FBQztRQUU3QixJQUFJLFFBQVEsQ0FBQyxpQkFBaUI7WUFBRSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNsSCxJQUFJLFFBQVEsQ0FBQyxVQUFVO1lBQUUsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztZQUN6RyxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztRQUdsRSxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzdELE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzs7UUFHdkUsT0FBTyxDQUFDLFlBQVk7YUFDZixJQUFJLENBQ0QsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ3RFO2FBQ0EsU0FBUyxDQUFDLEtBQUs7WUFDWixJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzVDLENBQUMsQ0FBQztRQUVQLE9BQU8sT0FBTyxDQUFDOzs7Ozs7OztJQUdYLFlBQVksQ0FBSSxZQUFpQixFQUFFLFFBQW1CO1FBQzFELE9BQU8sSUFBSSxXQUFXLENBQUMsWUFBWSxFQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7OztJQUd6RCxVQUFVLENBQUksVUFBeUIsRUFBRSxZQUFpQixFQUFFLFFBQW1CO1FBQ25GLHVCQUFNLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUU1RCxDQUFDLFVBQVUsSUFBSSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDeEIsdUJBQU0sYUFBYSxHQUFHLFlBQVksR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztZQUNqRSx1QkFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUN6RCxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdEMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxTQUFTLENBQUM7Ozs7Ozs7OztJQUdiLFVBQVUsQ0FBSSxRQUE4QixFQUFFLFlBQW1CLEVBQUUsUUFBbUI7UUFDMUYsWUFBWSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUUvRCxPQUFPLElBQUksU0FBUyxDQUNoQixZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQzdELEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUN6QixDQUFDOzs7Ozs7O0lBR0Usc0JBQXNCLENBQUksUUFBeUI7UUFDdkQsdUJBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU07WUFBRSxPQUFPLElBQUksQ0FBQztRQUV6QyxPQUFPLENBQUMsT0FBd0I7WUFDNUIsdUJBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUU3RSx1QkFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWM7aUJBQ2xDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRTtnQkFDdEQsUUFBUSxFQUFFLG9CQUFvQixDQUFDLElBQUk7Z0JBQ25DLFlBQVksRUFBRSxZQUFZLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzthQUM3QyxDQUFDLENBQUM7WUFFUCxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO2dCQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsUUFBUSxDQUFDLFlBQVksS0FBSztvQkFDakUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7YUFDckQ7WUFFRCxPQUFPLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUMvRCxDQUFDOzs7Ozs7O0lBR0UsMkJBQTJCLENBQUksUUFBeUI7UUFDNUQsdUJBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVuRSxJQUFJLENBQUMsWUFBWTtZQUFFLE9BQU8sSUFBSSxDQUFDO1FBRS9CLHVCQUFNLE1BQU0sR0FBRyxJQUFJLGVBQWUsQ0FBa0IsSUFBSSxDQUFDLENBQUM7UUFDMUQsdUJBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQ3RCLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUNuRixTQUFTLENBQUMsQ0FBQzs7WUFFUCxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUU7Z0JBQ2YsdUJBQU0sYUFBYSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztnQkFDN0MsdUJBQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7OztnQkFLckUsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLG9CQUFFLEVBQUUsV0FBVyxFQUFFLHFCQUFxQixFQUFtQyxFQUFDLENBQUMsQ0FBQzthQUNwSDtpQkFBTTtnQkFDSCxPQUFPLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDbEM7U0FDSixDQUFDLEVBQ0YsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNWLENBQUM7UUFFRixPQUFPLENBQUMsT0FBd0I7WUFDNUIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNyQixPQUFPLE1BQU0sQ0FBQztTQUNqQixDQUFDOzs7Ozs7O0lBR0UsOEJBQThCLENBQUksUUFBeUI7UUFDL0QsdUJBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVFLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU07WUFBRSxPQUFPLElBQUksQ0FBQztRQUUxQyxPQUFPLENBQUMsT0FBd0I7WUFDNUIsdUJBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUU3RSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFO2dCQUN0RixRQUFRLEVBQUUsb0JBQW9CLENBQUMsSUFBSTtnQkFDbkMsWUFBWSxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO2FBQzdDLENBQUMsQ0FBQyxJQUFJLENBQ0gsR0FBRyxDQUFDLFdBQVc7Z0JBQ1gsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtvQkFDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsK0JBQStCLFFBQVEsQ0FBQyxZQUFZLEtBQUs7d0JBQ3pFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2lCQUNyRDthQUNKLENBQUMsRUFDRixHQUFHLENBQUMsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLEVBQzVDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLGlCQUFjLENBQUMsQ0FDeEUsQ0FBQztTQUNMLENBQUM7Ozs7Ozs7O0lBR0UsNEJBQTRCLENBQ2hDLGFBQThCLEVBQzlCLFVBQTZCO1FBRTdCLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsYUFBYSxFQUFFLFVBQVUsQ0FBQyxDQUFDOzs7Ozs7O0lBR3ZELDZCQUE2QixDQUNqQyxVQUE2QjtRQUU3QixDQUFDLFVBQVUsSUFBSSxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVE7WUFDL0IsUUFBUSxDQUFDLG9DQUFvQyxFQUFFLENBQUM7WUFFaEQsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO2dCQUNyQixJQUFJLENBQUMsNkJBQTZCLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzNEO1lBRUQsSUFBSSxRQUFRLENBQUMsaUJBQWlCLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7YUFDcEU7U0FDSixDQUFDLENBQUM7Ozs7Ozs7OztJQUdDLDBCQUEwQixDQUM5QixhQUE4QixFQUM5QixVQUE2QixFQUM3QixVQUFtQjtRQUVuQixDQUFDLFVBQVUsSUFBSSxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVE7WUFDL0IsdUJBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3hGLElBQUksQ0FBQyxlQUFlO2dCQUFFLE9BQU87WUFFN0IsSUFBSSxDQUFDLHVDQUF1QyxDQUFDLGVBQWUsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDdkYsSUFBSSxDQUFDLHNDQUFzQyxDQUFDLGVBQWUsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFdEYsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO2dCQUNyQixJQUFJLENBQUMsMEJBQTBCLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUN6RTtZQUVELElBQUksUUFBUSxDQUFDLGlCQUFpQixFQUFFOztnQkFFNUIsdUJBQU0sZ0JBQWdCLHNCQUFJLGVBQTRCLEVBQUMsQ0FBQztnQkFDeEQsS0FBSyxxQkFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQzlDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUN0RjthQUNKO1NBQ0osQ0FBQyxDQUFDOzs7Ozs7Ozs7SUFHQyxzQ0FBc0MsQ0FDMUMsZUFBZ0MsRUFBRSxhQUE4QixFQUFFLFFBQXlCO1FBRTNGLHVCQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXhGLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pCLHVCQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFdkUsSUFBSSxDQUFDLGlCQUFpQjtnQkFBRSxPQUFPO1lBRS9CLHVCQUFNLElBQUksR0FBRyxpQkFBaUIsQ0FBQyxZQUFZO2lCQUN0QyxJQUFJLENBQ0QsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FDdkY7aUJBQ0EsU0FBUyxDQUFDLEtBQUs7Z0JBQ1osSUFBSSxDQUFDLHFDQUFxQyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEUsZUFBZSxDQUFDLHNCQUFzQixDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQzthQUNoRixDQUFDLENBQUM7WUFFUCxRQUFRLENBQUMsaUNBQWlDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEQsQ0FBQyxDQUFDOzs7Ozs7Ozs7SUFHQyx1Q0FBdUMsQ0FDM0MsZUFBZ0MsRUFDaEMsYUFBOEIsRUFDOUIsUUFBeUI7UUFFekIsdUJBQU0sbUJBQW1CLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkYsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEdBQUc7WUFDM0IsdUJBQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUV6RSxJQUFJLENBQUMsaUJBQWlCO2dCQUFFLE9BQU87O1lBRy9CLHVCQUFNLElBQUksR0FBRyxpQkFBaUIsQ0FBQyxZQUFZO2lCQUN0QyxJQUFJLENBQ0QsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FDdEY7aUJBQ0EsU0FBUyxDQUFDLEtBQUs7Z0JBQ1osSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQzthQUNwRCxDQUFDLENBQUM7WUFFUCxRQUFRLENBQUMsaUNBQWlDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEQsQ0FBQyxDQUFDOzs7Ozs7OztJQUdDLGdCQUFnQixDQUFJLGVBQWdDLEVBQUUsUUFBeUI7UUFDbkYsdUJBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVyRixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFO1lBQ2xFLFFBQVEsRUFBRSxvQkFBb0IsQ0FBQyxJQUFJO1lBQ25DLFlBQVksRUFBRSxZQUFZLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztTQUNyRCxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVc7WUFDcEIsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtnQkFDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLFFBQVEsQ0FBQyxZQUFZLEtBQUs7b0JBQ2hFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2FBQ3JEO1lBRUQsSUFBSSxXQUFXLENBQUMsTUFBTSxJQUFJLGVBQWUsQ0FBQyxRQUFRO2dCQUM5QyxlQUFlLENBQUMsTUFBTSxDQUFDLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7aUJBQzVDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxJQUFJLGVBQWUsQ0FBQyxPQUFPO2dCQUNuRCxlQUFlLENBQUMsT0FBTyxDQUFDLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDckQsQ0FBQyxDQUFDOzs7Ozs7SUFHQyxpQ0FBaUMsQ0FDckMsa0JBQXNDO1FBRXRDLE9BQU8sQ0FBQyxPQUFvQztZQUN4QyxxQkFBSSxTQUFjLENBQUM7WUFDbkIscUJBQUksT0FBZ0IsQ0FBQztZQUVyQixPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQ2YsR0FBRyxDQUFDLE9BQU87Z0JBQ1AsT0FBTyxHQUFHLElBQUksQ0FBQyxvQ0FBb0MsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDN0QsSUFBSSxDQUFDLHFDQUFxQyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUM5RCxDQUFDLEVBQ0YsUUFBUSxDQUFDLENBQUM7Z0JBQ04sT0FBTyxPQUFPLElBQUksa0JBQWtCLENBQUMsb0JBQW9CLEdBQUcsQ0FBQztzQkFDdkQsS0FBSyxDQUFDLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDO3NCQUM5QyxLQUFLLENBQUM7YUFDZixDQUFDLEVBQ0YsR0FBRyxDQUFDLE9BQU87Z0JBQ1AseUJBQU87b0JBQ0gsT0FBTyxFQUFFLE9BQU87b0JBQ2hCLFdBQVcsRUFBRSxFQUFFLE9BQU8sQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLENBQUMsa0JBQWtCLENBQUMsb0JBQW9CLElBQUksT0FBTyxDQUFDO2lCQUNuRSxFQUFDO2FBQ3ZDLENBQUMsRUFDRixHQUFHLENBQUMsQ0FBQztnQkFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVc7b0JBQUUsU0FBUyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO2FBQ25ELENBQUMsQ0FDTCxDQUFDO1NBQ0wsQ0FBQzs7Ozs7O0lBR0UsdUJBQXVCLENBQUMsa0JBQXNDO1FBQ2xFLE9BQU8sQ0FBQyxPQUF3QjtZQUM1QixPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQ2YsUUFBUSxDQUFDLENBQUM7Z0JBQ04sT0FBTyxrQkFBa0IsQ0FBQyxvQkFBb0IsR0FBRyxDQUFDO3NCQUM1QyxLQUFLLENBQUMsa0JBQWtCLENBQUMsb0JBQW9CLENBQUM7c0JBQzlDLEtBQUssQ0FBQzthQUNmLENBQUMsRUFDRixrQkFBa0IsQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0IsRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUMzRSxDQUFDO1NBQ0wsQ0FBQzs7Ozs7Ozs7SUFHRSx1QkFBdUIsQ0FBSSxPQUF3QixFQUFFLFFBQTRDO1FBQ3JHLHVCQUFNLFNBQVMsR0FBRyxtQkFBQyxPQUFPLENBQUMsSUFBaUIsR0FBRSxXQUFXLEVBQUUsQ0FBQzs7UUFHNUQsdUJBQU0sYUFBYSxHQUFHLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUM7Y0FDMUQsT0FBTyxDQUFDLEtBQUs7Y0FDYixPQUFPLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRW5DLE9BQU87WUFDSCxJQUFJLEVBQUUsU0FBUztZQUNmLFFBQVEsRUFBRSxhQUFhO1NBQzFCLENBQUM7Ozs7Ozs7OztJQUdFLHFCQUFxQixDQUN6QixhQUE4QixFQUM5QixRQUF5QixFQUN6QixVQUFtQjtRQUVuQixPQUFPLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUM7Y0FDM0MsbUJBQUMsYUFBMEIsR0FBRSxFQUFFLENBQUMsVUFBVSxDQUFDO2NBQzNDLGFBQWEsQ0FBQyxHQUFHLENBQUMsbUJBQUMsUUFBdUIsR0FBRSxJQUFJLENBQUMsQ0FBQzs7Ozs7OztJQUdwRCxrQ0FBa0MsQ0FBSSxXQUErQjs7UUFFekUsSUFBSSxDQUFDLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBTTtZQUFFLE9BQU8sSUFBSSxDQUFDO1FBRXBELHVCQUFNLE1BQU0sR0FBb0QsRUFBRSxDQUFDO1FBRW5FLFdBQVcsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUk7WUFDbEMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDakQsQ0FBQyxDQUFDO1FBRUgsT0FBTztZQUNILFdBQVcsb0JBQUU7Z0JBQ1QsT0FBTyxFQUFFLFdBQVcsQ0FBQyxPQUFPO2dCQUM1QixNQUFNLEVBQUUsTUFBTTthQUNvQixDQUFBO1NBQ3pDLENBQUM7Ozs7Ozs7SUFHRSxxQkFBcUIsQ0FBQyxPQUF3QixFQUFFLElBQVk7UUFDaEUsdUJBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUvRCxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU07WUFBRSxPQUFPLElBQUksQ0FBQztRQUV2QyxxQkFBSSxNQUF1QixDQUFDO1FBQzVCLGFBQWEsQ0FBQyxPQUFPLENBQUMsV0FBVztZQUM3QixNQUFNLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sSUFBSSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLE1BQU07Z0JBQUUsT0FBTztTQUN2QixDQUFDLENBQUM7UUFFSCxPQUFPLE1BQU0sQ0FBQzs7Ozs7O0lBR1YsNkJBQTZCLENBQUMsWUFBb0I7UUFDdEQsdUJBQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztRQUU1QixJQUFJLENBQUMsWUFBWSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVE7WUFBRSxPQUFPLE1BQU0sQ0FBQzs7UUFHckUsdUJBQU0sY0FBYyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFL0MsY0FBYyxDQUFDLE9BQU8sQ0FBQyxTQUFTO1lBQzVCLHVCQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztpQkFDcEMsTUFBTSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFbEMsSUFBSSxZQUFZLENBQUMsTUFBTTtnQkFDbkIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDOztnQkFFN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM5QixDQUFDLENBQUM7UUFFSCxPQUFPLE1BQU0sQ0FBQzs7Ozs7OztJQUdWLHVCQUF1QixDQUFDLE9BQXdCLEVBQUUsV0FBbUI7UUFDekUsUUFBUSxXQUFXO1lBQ2YsS0FBSyxFQUFFO2dCQUNILE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQztZQUN4QixLQUFLLElBQUk7Z0JBQ0wsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQzFCLEtBQUssR0FBRztnQkFDSixPQUFPLE9BQU8sQ0FBQztZQUNuQjtnQkFDSSxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDdkM7Ozs7Ozs7SUFHRywwQkFBMEIsQ0FBSSxXQUErQjtRQUNqRSxPQUFPLFlBQVksV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLFNBQVM7WUFDbEQsSUFBSSxXQUFXLENBQUMsYUFBYSxDQUFDLE1BQU0sVUFBVTtZQUM5QyxHQUFHLFdBQVcsQ0FBQyxhQUFhLENBQUMsTUFBTSxVQUFVO2NBQzNDLEdBQUcsV0FBVyxDQUFDLGNBQWMsQ0FBQyxNQUFNLFFBQVEsQ0FBQzs7Ozs7Ozs7SUFHL0MseUJBQXlCLENBQUksU0FBb0IsRUFBRSxhQUF1QztRQUM5RixTQUFTLENBQUMsd0JBQXdCLENBQUMsaUNBQWlDLENBQUMsR0FBRyxhQUFhLENBQUM7Ozs7Ozs7SUFHbEYsd0JBQXdCLENBQUksU0FBb0I7UUFDcEQseUJBQU8sU0FBUyxDQUFDLHdCQUF3QixDQUFDLGlDQUFpQyxDQUE2QixFQUFDOzs7Ozs7O0lBR3JHLHFDQUFxQyxDQUFDLE9BQXdCLEVBQUUsS0FBYztRQUNsRixPQUFPLENBQUMsd0JBQXdCLENBQUMsd0NBQXdDLENBQUMsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7SUFHL0Usc0JBQXNCLENBQUMsT0FBd0IsRUFBRSxNQUF5QztRQUM5RixPQUFPLENBQUMsd0JBQXdCLENBQUMsa0JBQWtCLENBQUMsR0FBRyxNQUFNLENBQUM7Ozs7OztJQUcxRCxzQkFBc0IsQ0FBQyxPQUF3QjtRQUNuRCxPQUFPLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7Ozs7SUFHeEQsb0NBQW9DLENBQUMsT0FBd0I7UUFDakUsT0FBTyxDQUFDLEVBQUUsT0FBTyxDQUFDLHdCQUF3QixDQUFDLHdDQUF3QyxDQUFDLENBQUMsQ0FBQzs7Ozs7O0lBR2xGLGtCQUFrQixDQUFDLE9BQXdCO1FBQy9DLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7NkRBdGdCc0IseUJBQXlCO29FQUNsQixtQ0FBbUM7OENBQ3pELDZCQUE2Qjs7WUFKN0UsVUFBVTs7OztZQXRCRixrQkFBa0I7WUFEdUIsV0FBVztZQUtwRCxZQUFZO1lBUVosYUFBYTs7Ozs7OztBQ2Z0Qjs7O1lBSUMsUUFBUSxTQUFDO2dCQUNSLE9BQU8sRUFBRSxFQUFFO2dCQUNYLFlBQVksRUFBRSxFQUFFO2dCQUNoQixTQUFTLEVBQUU7b0JBQ1AsWUFBWTtvQkFDWixhQUFhO2lCQUNoQjthQUNGOzs7Ozs7O0FDWEQ7OztZQU9DLFFBQVEsU0FBQztnQkFDTixPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixXQUFXO2lCQUNkO2dCQUNELFNBQVMsRUFBRTtvQkFDUCxrQkFBa0I7b0JBQ2xCLHdCQUF3QjtpQkFDM0I7Z0JBQ0QsWUFBWSxFQUFFLEVBQUU7YUFDbkI7Ozs7Ozs7QUNqQkQ7OztBQWlCQTs7O1lBVkMsUUFBUSxTQUFDO2dCQUNSLE9BQU8sRUFBRTtvQkFDUCxZQUFZO29CQUNaLGlCQUFpQjtpQkFDbEI7Z0JBQ0QsWUFBWSxFQUFFLEVBQUU7Z0JBQ2hCLE9BQU8sRUFBRTtvQkFDTCxpQkFBaUI7aUJBQ3BCO2FBQ0Y7Ozs7Ozs7QUNoQkQ7Ozs7QUFLQSxjQUF5QixTQUFRLFlBQWU7Ozs7SUFVNUMsWUFBWSxJQUFZO1FBQ3BCLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7S0FDckI7Ozs7O0lBUEQsSUFBSSxJQUFJO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQ3JCO0NBTUo7Ozs7OztBQ25CRDs7OztBQUtBLHVCQUFrQyxTQUFRLFlBQWU7Q0FBRzs7Ozs7O0FDTDVEOzs7QUFlQTs7Ozs7Ozs7SUFPSSxRQUFRLENBQUksWUFBcUIsRUFBRSxNQUFvQztRQUNuRSxJQUFJLENBQUMsWUFBWSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVE7WUFBRSxNQUFNLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBRTVGLHVCQUFNLFFBQVEsR0FBRyxJQUFJLFFBQVEsQ0FBSSxZQUFZLENBQUMsQ0FBQztRQUUvQyxJQUFJLE1BQU07WUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFN0IsT0FBTyxRQUFRLENBQUM7S0FDbkI7Ozs7Ozs7SUFPRCxpQkFBaUIsQ0FBSSxNQUE2QztRQUM5RCx1QkFBTSxRQUFRLEdBQUcsSUFBSSxpQkFBaUIsRUFBSyxDQUFDO1FBRTVDLElBQUksTUFBTTtZQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU3QixPQUFPLFFBQVEsQ0FBQztLQUNuQjs7Ozs7Ozs7O0lBU0QsU0FBUyxDQUFJLE9BQWUsRUFBRSxLQUFpQixFQUFFLFNBQXNCO1FBQ25FLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztLQUMvRDs7Ozs7Ozs7OztJQVVELGNBQWMsQ0FBSSxJQUFZLEVBQUUsT0FBZSxFQUFFLEtBQWlCLEVBQUUsU0FBc0I7UUFDdEYseUJBQU87WUFDSCxJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxPQUFPO1lBQ2hCLEtBQUssRUFBRSxLQUFLO1lBQ1osU0FBUyxFQUFFLFNBQVM7U0FDWixFQUFDO0tBQ2hCOzs7Ozs7OztJQVFELFFBQVEsQ0FBSSxLQUFpQixFQUFFLFNBQXNCO1FBQ2pELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQ3JEOzs7Ozs7Ozs7SUFTRCxhQUFhLENBQUksSUFBWSxFQUFFLEtBQWlCLEVBQUUsU0FBc0I7UUFDcEUseUJBQU87WUFDSCxJQUFJLEVBQUUsSUFBSTtZQUNWLEtBQUssRUFBRSxLQUFLO1lBQ1osU0FBUyxFQUFFLFNBQVM7U0FDWixFQUFDO0tBQ2hCOzs7Ozs7OztJQVFELElBQUksQ0FBTyxJQUFvQixFQUFFLE9BQXFCO1FBQ2xELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzlDOzs7Ozs7OztJQVFELFNBQVMsQ0FBTyxTQUE4QixFQUFFLE9BQXFCO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQ25EOzs7Ozs7Ozs7SUFTRCxTQUFTLENBQU8sSUFBb0IsRUFBRSxTQUE4QixFQUFFLE9BQXFCO1FBQ3ZGLHlCQUFPO1lBQ0gsSUFBSSxFQUFFLElBQUk7WUFDVixTQUFTLEVBQUUsU0FBUztZQUNwQixPQUFPLEVBQUUsT0FBTztTQUNSLEVBQUM7S0FDaEI7Ozs7Ozs7O0lBUUQsU0FBUyxDQUFJLFFBQXNCLEVBQUUsT0FBMEI7UUFDM0QseUJBQU87WUFDSCxLQUFLLEVBQUUsUUFBUTtZQUNmLE9BQU8sRUFBRSxPQUFPLElBQUksRUFBRSxrQkFBa0IsRUFBRSxzQkFBc0IsQ0FBQyxPQUFPLEVBQUU7U0FDN0QsRUFBQztLQUNyQjtDQUNKOzs7Ozs7QUNqSkQ7Ozs7O0FBTUE7Ozs7O0lBd0JJLFlBQVksSUFBWTtRQUNwQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksb0JBQW9CLEVBQUUsQ0FBQztRQUMxQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxFQUFFLENBQUM7S0FDbEQ7Ozs7O0lBdEJELElBQUksSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztLQUNyQjtDQTBCSjs7Ozs7O0FDeENEOzs7QUFHQSx5QkFBb0MsU0FBUSxlQUFrQjs7Ozs7SUFDMUQsWUFBbUIsWUFBb0IsRUFBRSxPQUF3QjtRQUM3RCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFEQSxpQkFBWSxHQUFaLFlBQVksQ0FBUTtLQUV0QztDQUNKOzs7Ozs7QUNQRDs7OztBQU9BLHdCQUFtQyxTQUFRLHFCQUF3Qjs7O1FBZTNELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQzs7Ozs7Ozs7SUFUbkIsT0FBTyxNQUFNLENBQUksbUJBQXFFO1FBQ2xGLHVCQUFNLFFBQVEsR0FBRyxJQUFJLGtCQUFrQixFQUFFLENBQUM7UUFDMUMsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsbUJBQW1CLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFFL0YsT0FBTyxRQUFRLENBQUM7S0FDbkI7Ozs7SUFPUyxlQUFlOztRQUVyQixPQUFPLEVBQUUsQ0FBQztLQUNiO0NBQ0o7Ozs7Ozs7OztBQzFCRDtDQVVDOzs7Ozs7Ozs7Ozs7OzsifQ==