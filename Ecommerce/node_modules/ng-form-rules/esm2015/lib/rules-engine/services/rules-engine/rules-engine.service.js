/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, Inject, Optional } from '@angular/core';
import { MODEL_SETTINGS_TOKEN } from '../../../form-rules/injection-tokens/model-settings.token';
import { TraceService } from '../../../utils/trace/trace.service';
import { CommonService } from '../../../utils/common/common.service';
import { forkJoin, of } from 'rxjs';
import { map, flatMap, mergeMap, take } from 'rxjs/operators';
import { TestResultsBase } from '../../../form-rules/models/test-results-base';
import { PropertyBase } from '../../../form-rules/models/property-base';
import { ProcessResultType } from '../../../form-rules/models/proccess-result-type';
import { ResultsPassRequirement } from '../../../form-rules/models/results-pass-requirement';
/**
 * Engine that digests model settings and applies their rules appropriately
 */
export class RulesEngineService {
    /**
     * @param {?} settings
     * @param {?} traceSvc
     * @param {?} commonSvc
     */
    constructor(settings, traceSvc, commonSvc) {
        this.traceSvc = traceSvc;
        this.commonSvc = commonSvc;
        this.registeredSettings = {};
        if (!Array.isArray(settings))
            return;
        settings.forEach(setting => {
            this.initializeModelSetting(setting);
            this.registeredSettings[setting.name] = setting;
        });
    }
    /**
     * Initializes model settings and prepares them to be used in a form group
     * @param {?} setting Model setting to initialize
     * @return {?}
     */
    initializeModelSetting(setting) {
        this.traceSvc.trace(`Initializing model settings "${setting.name}"`);
        this.setPropertyMetadata(setting.properties, setting.name);
    }
    /**
     * Gets model settings with the provided name
     * @template T
     * @param {?} name Name of model setting
     * @return {?} Model settings with the provided name
     */
    getModelSettings(name) {
        this.traceSvc.trace(`Retrieving model settings "${name}"`);
        const /** @type {?} */ settings = this.registeredSettings[name];
        // create new object
        return settings
            ? Object.assign({}, this.registeredSettings[name])
            : null;
    }
    /**
     * Gets the dependency properties for an array of tests
     * @template T
     * @param {?} tests Tests to get the dependency properties for
     * @return {?} Dependency properties
     */
    getDependencyProperties(tests) {
        if (!tests)
            return [];
        const /** @type {?} */ deps = tests
            .map(t => this.getDependencyPropertiesFromTest(t))
            .reduce((prev, current) => prev.concat(current), []);
        return this.commonSvc.unique(deps);
    }
    /**
     * Gets tests grouped by their sync type (e.g. sync vs. async)
     * @template T
     * @param {?} tests Test to groups
     * @return {?} Tests grouped by sync type
     */
    groupTestsBySyncType(tests) {
        const /** @type {?} */ testGroups = /** @type {?} */ ({
            sync: [],
            async: []
        });
        if (!tests)
            return testGroups;
        tests.forEach(test => {
            const /** @type {?} */ testFuncTypes = /** @type {?} */ ({
                sync: false,
                async: false
            });
            const /** @type {?} */ conditionResults = this.getConfiguredFuncTypes(test.condition);
            const /** @type {?} */ checkResults = this.getConfiguredFuncTypes(test.check);
            testFuncTypes.sync = conditionResults.sync || checkResults.sync;
            testFuncTypes.async = conditionResults.async || checkResults.async;
            // if there is an async func anywhere in the test's rule sets, then it is considered an async test
            if (testFuncTypes.sync && !testFuncTypes.async)
                testGroups.sync.push(test);
            if (testFuncTypes.async)
                testGroups.async.push(test);
        });
        return testGroups;
    }
    /**
     * Runs validation tests
     * @template T
     * @param {?} data Data to run validation tests against
     * @param {?} property Property to run validation tests for
     * @param {?=} state
     * @return {?} Results of validation tests
     */
    validate(data, property, state) {
        return this.runAllTests(data, property.valid, state)
            .pipe(map((results) => {
            results.propertyName = property.absolutePath;
            return /** @type {?} */ (results);
        }));
    }
    /**
     * Runs editability tests
     * @template T
     * @param {?} data Data to run editability tests against
     * @param {?} property Property to run editability tests for
     * * \@returns Results of editability tests
     * @param {?=} state
     * @return {?}
     */
    editable(data, property, state) {
        return this.runAllTests(data, property.edit, state)
            .pipe(map((results) => {
            results.propertyName = property.absolutePath;
            return /** @type {?} */ (results);
        }));
    }
    /**
     * Runs an array of sync tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    runTests(data, tests, state) {
        if (!tests || !tests.length)
            return new TestResultsBase([]);
        const /** @type {?} */ testResults = tests
            .map(t => this.runTest(data, t, state))
            .filter(x => !!x);
        return new TestResultsBase(testResults);
    }
    /**
     * Runs an array of async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    runTestsAsync(data, tests, state) {
        if (!tests || !tests.length)
            return of(new TestResultsBase([]));
        const /** @type {?} */ runTest$ = tests
            .map(test => this.runTestAsync(data, test, state));
        return forkJoin(runTest$)
            .pipe(map(testResults => new TestResultsBase(testResults.filter(x => !!x))));
    }
    /**
     * Runs an array of sync and async tests
     * @template T
     * @param {?} data Data to perform tests against
     * @param {?} tests Tests to run
     * @param {?=} state
     * @return {?} Result of tests
     */
    runAllTests(data, tests, state) {
        if (!tests || !tests.length)
            return of(new TestResultsBase([]));
        const /** @type {?} */ syncGroups = this.groupTestsBySyncType(tests);
        const /** @type {?} */ syncTestResults = of(this.runTests(data, syncGroups.sync, state));
        return syncTestResults.pipe(mergeMap(result => {
            if (!result.passed)
                return of(result);
            return this.runTestsAsync(data, syncGroups.async, state);
        }), take(1));
    }
    /**
     * Performs sync test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    runTest(data, test, state) {
        if (!test)
            return null;
        const /** @type {?} */ passedTestResult = { passed: true, name: test.name, message: null };
        const /** @type {?} */ failedTestResult = { passed: false, name: test.name, message: test.message };
        const /** @type {?} */ skippedTestResult = { passed: true, skipped: true, name: test.name, message: null };
        const /** @type {?} */ conditionsRuleSetResult = this.processRuleSet(data, test.condition, state);
        if (conditionsRuleSetResult === ProcessResultType.Failed)
            return skippedTestResult;
        const /** @type {?} */ checkRuleSetResult = this.processRuleSet(data, test.check, state);
        switch (checkRuleSetResult) {
            case ProcessResultType.Passed:
                return passedTestResult;
            case ProcessResultType.Failed:
                return failedTestResult;
            case ProcessResultType.Skipped:
            default:
                return skippedTestResult;
        }
    }
    /**
     * Performs async test on a set of data
     * @template T
     * @param {?} data Data to perform test against
     * @param {?} test Test to run
     * @param {?=} state
     * @return {?} Result of test
     */
    runTestAsync(data, test, state) {
        if (!test)
            return of(null);
        const /** @type {?} */ passedTestResult = { passed: true, name: test.name, message: null };
        const /** @type {?} */ failedTestResult = { passed: false, name: test.name, message: test.message };
        const /** @type {?} */ skippedTestResult = { passed: true, skipped: true, name: test.name, message: null };
        const /** @type {?} */ conditionsRuleSetResult$ = this.processRuleSetAsync(data, test.condition, state);
        const /** @type {?} */ checkRuleSetResult$ = this.processRuleSetAsync(data, test.check, state);
        return conditionsRuleSetResult$
            .pipe(flatMap(conditionsRuleSetResult => {
            if (conditionsRuleSetResult === ProcessResultType.Failed)
                return of(skippedTestResult);
            return checkRuleSetResult$
                .pipe(map(checkRuleSetResult => {
                switch (checkRuleSetResult) {
                    case ProcessResultType.Passed:
                        return passedTestResult;
                    case ProcessResultType.Failed:
                        return failedTestResult;
                    case ProcessResultType.Skipped:
                    default:
                        return skippedTestResult;
                }
            }));
        }));
    }
    /**
     * Processes a sync rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    processRuleSet(data, ruleSet, state) {
        if (!ruleSet)
            return ProcessResultType.Skipped;
        const /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        return isRuleGroup
            ? this.processRuleGroup(data, /** @type {?} */ (ruleSet), state)
            : this.processRule(data, /** @type {?} */ (ruleSet), state);
    }
    /**
     * Processes an async rule set
     * @template T
     * @param {?} data Data to process rule set against
     * @param {?} ruleSet Rule set to process
     * @param {?=} state
     * @return {?} Result of rule set processing
     */
    processRuleSetAsync(data, ruleSet, state) {
        if (!ruleSet)
            return of(ProcessResultType.Skipped);
        const /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        return isRuleGroup
            ? this.processRuleGroupAsync(data, /** @type {?} */ (ruleSet), state)
            : this.processRuleAsync(data, /** @type {?} */ (ruleSet), state);
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    processRuleGroup(data, ruleGroup, state) {
        if (!ruleGroup.rules)
            return ProcessResultType.Skipped;
        let /** @type {?} */ passedCount = 0;
        let /** @type {?} */ skippedCount = 0;
        for (let /** @type {?} */ i = 0; i < ruleGroup.rules.length; i++) {
            const /** @type {?} */ rule = ruleGroup.rules[i];
            const /** @type {?} */ ruleSetResult = this.processRuleSet(data, rule, state);
            if (this.canShortCircuitRuleGroup(ruleSetResult, ruleGroup))
                return ruleSetResult;
            if (ruleSetResult == ProcessResultType.Passed)
                passedCount++;
            else if (ruleSetResult == ProcessResultType.Skipped)
                skippedCount++;
        }
        // if we skipped them all, then return skipped
        if (skippedCount === ruleGroup.rules.length)
            return ProcessResultType.Skipped;
        // if we got this far, make sure all tests were passed
        return passedCount === ruleGroup.rules.length ? ProcessResultType.Passed : ProcessResultType.Failed;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} ruleGroup
     * @param {?=} state
     * @return {?}
     */
    processRuleGroupAsync(data, ruleGroup, state) {
        if (!ruleGroup.rules)
            return of(ProcessResultType.Skipped);
        const /** @type {?} */ asyncRuleSetResults$ = ruleGroup.rules.map(x => this.processRuleSetAsync(data, x, state));
        return forkJoin(asyncRuleSetResults$).pipe(map(ruleSetResults => {
            const /** @type {?} */ counts = {
                passed: ruleSetResults.filter(x => x === ProcessResultType.Passed).length,
                failed: ruleSetResults.filter(x => x === ProcessResultType.Failed).length,
                skipped: ruleSetResults.filter(x => x === ProcessResultType.Skipped).length,
            };
            const /** @type {?} */ ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };
            if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass && counts.passed > 0)
                return ProcessResultType.Passed;
            if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass && counts.passed === ruleSetResults.length)
                return ProcessResultType.Passed;
            if (counts.skipped === ruleSetResults.length)
                return ProcessResultType.Skipped;
            return ProcessResultType.Failed;
        }));
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    processRule(data, rule, state) {
        if (!rule.func)
            return ProcessResultType.Skipped;
        const /** @type {?} */ rootData = state ? state.rootData : null;
        return rule.func(data, rootData) ? ProcessResultType.Passed : ProcessResultType.Failed;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} rule
     * @param {?=} state
     * @return {?}
     */
    processRuleAsync(data, rule, state) {
        if (!rule.func && !rule.asyncFunc)
            return of(ProcessResultType.Skipped);
        const /** @type {?} */ rootData = state ? state.rootData : null;
        const /** @type {?} */ funcResult = rule.func
            ? of(rule.func(data, rootData))
            : rule.asyncFunc(data, rootData);
        return funcResult
            .pipe(map(passed => passed ? ProcessResultType.Passed : ProcessResultType.Failed));
    }
    /**
     * @template T
     * @param {?} ruleSetResult
     * @param {?} ruleGroup
     * @return {?}
     */
    canShortCircuitRuleGroup(ruleSetResult, ruleGroup) {
        const /** @type {?} */ ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };
        return (
        // it passed, and we only need one to pass
        (ruleSetResult == ProcessResultType.Passed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass)
            ||
                // if failed, and we need all to pass
                (ruleSetResult == ProcessResultType.Failed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass));
    }
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    isRuleGroup(ruleSet) {
        const /** @type {?} */ rule = /** @type {?} */ (ruleSet);
        return !rule.func && !rule.asyncFunc;
    }
    /**
     * @template T
     * @param {?} test
     * @return {?}
     */
    getDependencyPropertiesFromTest(test) {
        const /** @type {?} */ checkDeps = this.getDependencyPropertiesFromRuleSet(test.check);
        const /** @type {?} */ conditionDeps = this.getDependencyPropertiesFromRuleSet(test.condition);
        return this.commonSvc.unique(checkDeps.concat(conditionDeps));
    }
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    getDependencyPropertiesFromRuleSet(ruleSet) {
        if (!ruleSet)
            return [];
        const /** @type {?} */ result = [];
        if (this.isRuleGroup(ruleSet)) {
            const /** @type {?} */ ruleGroup = /** @type {?} */ (ruleSet);
            ruleGroup.rules.forEach(x => {
                result.push(...this.commonSvc.unique(this.getDependencyPropertiesFromRuleSet(x)));
            });
        }
        const /** @type {?} */ rule = /** @type {?} */ (ruleSet);
        if (rule.options && Array.isArray(rule.options.dependencyProperties)) {
            result.push(...this.commonSvc.unique(rule.options.dependencyProperties));
        }
        return this.commonSvc.unique(result);
    }
    /**
     * @param {?} properties
     * @param {?} modelSettingsName
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    setPropertyMetadata(properties, modelSettingsName, currentAbsolutePath = '') {
        if (!properties)
            return;
        properties.forEach(prop => {
            const /** @type {?} */ newAbsolutePath = this.setPropertyAbsolutePath(prop, currentAbsolutePath);
            this.fillInEmptyTestNames(prop);
            prop.setOwnerModelSettingsName(modelSettingsName);
            if (prop.properties) {
                this.setPropertyMetadata(prop.properties, modelSettingsName, newAbsolutePath);
            }
            else if (prop.arrayItemProperty) {
                this.setPropertyMetadata([prop.arrayItemProperty], modelSettingsName, newAbsolutePath);
            }
        });
    }
    /**
     * @param {?} property
     * @param {?=} currentAbsolutePath
     * @return {?}
     */
    setPropertyAbsolutePath(property, currentAbsolutePath = '') {
        const /** @type {?} */ isArrayItemProperty = PropertyBase.isArrayItemProperty(property);
        const /** @type {?} */ newAbsolutePathSegment = isArrayItemProperty ? '[]' : (/** @type {?} */ (property)).name;
        const /** @type {?} */ isAtRoot = !currentAbsolutePath;
        const /** @type {?} */ newAbsolutePath = `${currentAbsolutePath}${isAtRoot ? '' : '.'}${newAbsolutePathSegment}`;
        // set absolute path for property
        property.setAbsolutePath(newAbsolutePath);
        return newAbsolutePath;
    }
    /**
     * @param {?} property
     * @return {?}
     */
    fillInEmptyTestNames(property) {
        property.valid
            .filter(test => !test.name)
            .forEach((test, i) => test.name = `validTest${i}`);
        property.edit
            .filter(test => !test.name)
            .forEach((test, i) => test.name = `editTest${i}`);
    }
    /**
     * @template T
     * @param {?} ruleSet
     * @return {?}
     */
    getConfiguredFuncTypes(ruleSet) {
        if (!ruleSet)
            return { sync: false, async: false };
        const /** @type {?} */ isRuleGroup = this.isRuleGroup(ruleSet);
        if (isRuleGroup) {
            const /** @type {?} */ ruleGroup = /** @type {?} */ (ruleSet);
            const /** @type {?} */ results = ruleGroup.rules
                .map(rs => {
                return this.getConfiguredFuncTypes(rs);
            });
            return {
                sync: results.findIndex(x => !!x.sync) >= 0,
                async: results.findIndex(x => !!x.async) >= 0,
            };
        }
        else {
            const /** @type {?} */ rule = /** @type {?} */ (ruleSet);
            return {
                sync: !!rule.func,
                async: !!rule.asyncFunc
            };
        }
    }
}
RulesEngineService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RulesEngineService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [MODEL_SETTINGS_TOKEN,] },] },
    { type: TraceService, },
    { type: CommonService, },
];
function RulesEngineService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    RulesEngineService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    RulesEngineService.ctorParameters;
    /** @type {?} */
    RulesEngineService.prototype.registeredSettings;
    /** @type {?} */
    RulesEngineService.prototype.traceSvc;
    /** @type {?} */
    RulesEngineService.prototype.commonSvc;
}
/**
 * @record
 */
function ConfiguredFuncTypes() { }
function ConfiguredFuncTypes_tsickle_Closure_declarations() {
    /** @type {?} */
    ConfiguredFuncTypes.prototype.sync;
    /** @type {?} */
    ConfiguredFuncTypes.prototype.async;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVsZXMtZW5naW5lLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1mb3JtLXJ1bGVzLyIsInNvdXJjZXMiOlsibGliL3J1bGVzLWVuZ2luZS9zZXJ2aWNlcy9ydWxlcy1lbmdpbmUvcnVsZXMtZW5naW5lLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwyREFBMkQsQ0FBQztBQVNqRyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDbEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3JFLE9BQU8sRUFBYyxRQUFRLEVBQUUsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2hELE9BQU8sRUFBRyxHQUFHLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQU8sTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sOENBQThDLENBQUM7QUFFL0UsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlEQUFpRCxDQUFDO0FBRXBGLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHFEQUFxRCxDQUFDOzs7O0FBTTdGLE1BQU07Ozs7OztJQUdGLFlBQzhDLFVBQ2xDLFVBQ0E7UUFEQSxhQUFRLEdBQVIsUUFBUTtRQUNSLGNBQVMsR0FBVCxTQUFTO1FBRWpCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLENBQUM7UUFFN0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQUMsTUFBTSxDQUFDO1FBRXJDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FB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dWxhci9jb3JlJztcclxuaW1wb3J0IHsgTU9ERUxfU0VUVElOR1NfVE9LRU4gfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL2luamVjdGlvbi10b2tlbnMvbW9kZWwtc2V0dGluZ3MudG9rZW4nO1xyXG5pbXBvcnQgeyBBYnN0cmFjdE1vZGVsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9hYnN0cmFjdC1tb2RlbC1zZXR0aW5ncyc7XHJcbmltcG9ydCB7IFByb3BlcnR5IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcHJvcGVydHknO1xyXG5pbXBvcnQgeyBSdWxlR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9ydWxlLWdyb3VwJztcclxuaW1wb3J0IHsgUnVsZSB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3J1bGUnO1xyXG5pbXBvcnQgeyBUZXN0IH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdCc7XHJcbmltcG9ydCB7IFRlc3RSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy90ZXN0LXJlc3VsdCc7XHJcbmltcG9ydCB7IFJ1bGVTZXQgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9ydWxlLXNldCc7XHJcbmltcG9ydCB7IFRlc3RSdW5TdGF0ZSB9IGZyb20gJy4uLy4uLy4uL2Zvcm0tcnVsZXMvbW9kZWxzL3Rlc3QtcnVuLXN0YXRlJztcclxuaW1wb3J0IHsgVHJhY2VTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvdHJhY2UvdHJhY2Uuc2VydmljZSc7XHJcbmltcG9ydCB7IENvbW1vblNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb21tb24vY29tbW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmb3JrSm9pbiwgb2YgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgIG1hcCwgZmxhdE1hcCwgbWVyZ2VNYXAsIHRha2UsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgVGVzdFJlc3VsdHNCYXNlIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1yZXN1bHRzLWJhc2UnO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eVRlc3RSZXN1bHRzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvcHJvcGVydHktdGVzdC1yZXN1bHQnO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eUJhc2UgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9wcm9wZXJ0eS1iYXNlJztcclxuaW1wb3J0IHsgUHJvY2Vzc1Jlc3VsdFR5cGUgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9wcm9jY2Vzcy1yZXN1bHQtdHlwZSc7XHJcbmltcG9ydCB7IFRlc3RTeW5jR3JvdXBzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybS1ydWxlcy9tb2RlbHMvdGVzdC1zeW5jLWdyb3Vwcyc7XHJcbmltcG9ydCB7IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQgfSBmcm9tICcuLi8uLi8uLi9mb3JtLXJ1bGVzL21vZGVscy9yZXN1bHRzLXBhc3MtcmVxdWlyZW1lbnQnO1xyXG5cclxuLyoqXHJcbiAqIEVuZ2luZSB0aGF0IGRpZ2VzdHMgbW9kZWwgc2V0dGluZ3MgYW5kIGFwcGxpZXMgdGhlaXIgcnVsZXMgYXBwcm9wcmlhdGVseVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgUnVsZXNFbmdpbmVTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgcmVnaXN0ZXJlZFNldHRpbmdzOiB7IFtrZXk6IHN0cmluZ106IEFic3RyYWN0TW9kZWxTZXR0aW5nczxhbnk+OyB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTU9ERUxfU0VUVElOR1NfVE9LRU4pIHNldHRpbmdzOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8YW55PltdLFxyXG4gICAgICAgIHByaXZhdGUgdHJhY2VTdmM6IFRyYWNlU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIGNvbW1vblN2YzogQ29tbW9uU2VydmljZVxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2V0dGluZ3MgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNldHRpbmdzKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBzZXR0aW5ncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVNb2RlbFNldHRpbmcoc2V0dGluZyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZFNldHRpbmdzW3NldHRpbmcubmFtZV0gPSBzZXR0aW5nO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgbW9kZWwgc2V0dGluZ3MgYW5kIHByZXBhcmVzIHRoZW0gdG8gYmUgdXNlZCBpbiBhIGZvcm0gZ3JvdXBcclxuICAgICAqIEBwYXJhbSBzZXR0aW5nIE1vZGVsIHNldHRpbmcgdG8gaW5pdGlhbGl6ZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplTW9kZWxTZXR0aW5nKHNldHRpbmc6IEFic3RyYWN0TW9kZWxTZXR0aW5nczxhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50cmFjZVN2Yy50cmFjZShgSW5pdGlhbGl6aW5nIG1vZGVsIHNldHRpbmdzIFwiJHtzZXR0aW5nLm5hbWV9XCJgKTtcclxuICAgICAgICB0aGlzLnNldFByb3BlcnR5TWV0YWRhdGEoc2V0dGluZy5wcm9wZXJ0aWVzLCBzZXR0aW5nLm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBtb2RlbCBzZXR0aW5ncyB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIG1vZGVsIHNldHRpbmdcclxuICAgICAqIEByZXR1cm5zIE1vZGVsIHNldHRpbmdzIHdpdGggdGhlIHByb3ZpZGVkIG5hbWVcclxuICAgICAqL1xyXG4gICAgZ2V0TW9kZWxTZXR0aW5nczxUPihuYW1lOiBzdHJpbmcpOiBBYnN0cmFjdE1vZGVsU2V0dGluZ3M8VD4ge1xyXG4gICAgICAgIHRoaXMudHJhY2VTdmMudHJhY2UoYFJldHJpZXZpbmcgbW9kZWwgc2V0dGluZ3MgXCIke25hbWV9XCJgKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnJlZ2lzdGVyZWRTZXR0aW5nc1tuYW1lXTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYmplY3RcclxuICAgICAgICByZXR1cm4gc2V0dGluZ3NcclxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlZ2lzdGVyZWRTZXR0aW5nc1tuYW1lXSlcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGVwZW5kZW5jeSBwcm9wZXJ0aWVzIGZvciBhbiBhcnJheSBvZiB0ZXN0c1xyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIGdldCB0aGUgZGVwZW5kZW5jeSBwcm9wZXJ0aWVzIGZvclxyXG4gICAgICogQHJldHVybnMgRGVwZW5kZW5jeSBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIGdldERlcGVuZGVuY3lQcm9wZXJ0aWVzPFQ+KHRlc3RzOiBUZXN0PFQ+W10pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgaWYgKCF0ZXN0cykgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICBjb25zdCBkZXBzID0gdGVzdHNcclxuICAgICAgICAgICAgLm1hcCh0ID0+IHRoaXMuZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tVGVzdCh0KSlcclxuICAgICAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4gcHJldi5jb25jYXQoY3VycmVudCksIFtdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbW9uU3ZjLnVuaXF1ZShkZXBzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGVzdHMgZ3JvdXBlZCBieSB0aGVpciBzeW5jIHR5cGUgKGUuZy4gc3luYyB2cy4gYXN5bmMpXHJcbiAgICAgKiBAcGFyYW0gdGVzdHMgVGVzdCB0byBncm91cHNcclxuICAgICAqIEByZXR1cm5zIFRlc3RzIGdyb3VwZWQgYnkgc3luYyB0eXBlXHJcbiAgICAgKi9cclxuICAgIGdyb3VwVGVzdHNCeVN5bmNUeXBlPFQ+KHRlc3RzOiBUZXN0PFQ+W10pOiBUZXN0U3luY0dyb3VwczxUPiB7XHJcbiAgICAgICAgY29uc3QgdGVzdEdyb3VwcyA9IHtcclxuICAgICAgICAgICAgc3luYzogW10sXHJcbiAgICAgICAgICAgIGFzeW5jOiBbXVxyXG4gICAgICAgIH0gYXMgVGVzdFN5bmNHcm91cHM8VD47XHJcblxyXG4gICAgICAgIGlmICghdGVzdHMpIHJldHVybiB0ZXN0R3JvdXBzO1xyXG5cclxuICAgICAgICB0ZXN0cy5mb3JFYWNoKHRlc3QgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0RnVuY1R5cGVzID0ge1xyXG4gICAgICAgICAgICAgICAgc3luYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuICAgICAgICAgICAgfSBhcyBDb25maWd1cmVkRnVuY1R5cGVzO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uUmVzdWx0cyA9IHRoaXMuZ2V0Q29uZmlndXJlZEZ1bmNUeXBlcyh0ZXN0LmNvbmRpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0cyA9IHRoaXMuZ2V0Q29uZmlndXJlZEZ1bmNUeXBlcyh0ZXN0LmNoZWNrKTtcclxuXHJcbiAgICAgICAgICAgIHRlc3RGdW5jVHlwZXMuc3luYyA9IGNvbmRpdGlvblJlc3VsdHMuc3luYyB8fCBjaGVja1Jlc3VsdHMuc3luYztcclxuICAgICAgICAgICAgdGVzdEZ1bmNUeXBlcy5hc3luYyA9IGNvbmRpdGlvblJlc3VsdHMuYXN5bmMgfHwgY2hlY2tSZXN1bHRzLmFzeW5jO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYXN5bmMgZnVuYyBhbnl3aGVyZSBpbiB0aGUgdGVzdCdzIHJ1bGUgc2V0cywgdGhlbiBpdCBpcyBjb25zaWRlcmVkIGFuIGFzeW5jIHRlc3RcclxuICAgICAgICAgICAgaWYgKHRlc3RGdW5jVHlwZXMuc3luYyAmJiAhdGVzdEZ1bmNUeXBlcy5hc3luYykgdGVzdEdyb3Vwcy5zeW5jLnB1c2godGVzdCk7XHJcbiAgICAgICAgICAgIGlmICh0ZXN0RnVuY1R5cGVzLmFzeW5jKSB0ZXN0R3JvdXBzLmFzeW5jLnB1c2godGVzdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXN0R3JvdXBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyB2YWxpZGF0aW9uIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHJ1biB2YWxpZGF0aW9uIHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBydW4gdmFsaWRhdGlvbiB0ZXN0cyBmb3JcclxuICAgICAqIEByZXR1cm5zIFJlc3VsdHMgb2YgdmFsaWRhdGlvbiB0ZXN0c1xyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZTxUPihkYXRhOiBULCBwcm9wZXJ0eTogUHJvcGVydHk8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxQcm9wZXJ0eVRlc3RSZXN1bHRzPFQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuQWxsVGVzdHMoZGF0YSwgcHJvcGVydHkudmFsaWQsIHN0YXRlKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgocmVzdWx0czogUHJvcGVydHlUZXN0UmVzdWx0czxUPikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHJvcGVydHlOYW1lID0gcHJvcGVydHkuYWJzb2x1dGVQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzIGFzIFByb3BlcnR5VGVzdFJlc3VsdHM8VD47XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBlZGl0YWJpbGl0eSB0ZXN0c1xyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBydW4gZWRpdGFiaWxpdHkgdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFByb3BlcnR5IHRvIHJ1biBlZGl0YWJpbGl0eSB0ZXN0cyBmb3JcclxuICAgICAqICogQHJldHVybnMgUmVzdWx0cyBvZiBlZGl0YWJpbGl0eSB0ZXN0c1xyXG4gICAgICovXHJcbiAgICBlZGl0YWJsZTxUPihkYXRhOiBULCBwcm9wZXJ0eTogUHJvcGVydHlCYXNlPFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8UHJvcGVydHlUZXN0UmVzdWx0czxUPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bkFsbFRlc3RzKGRhdGEsIHByb3BlcnR5LmVkaXQsIHN0YXRlKVxyXG4gICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgocmVzdWx0czogUHJvcGVydHlUZXN0UmVzdWx0czxUPikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHJvcGVydHlOYW1lID0gcHJvcGVydHkuYWJzb2x1dGVQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzIGFzIFByb3BlcnR5VGVzdFJlc3VsdHM8VD47XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyB2aXNpYmlsaXR5IHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHJ1biB2aXNpYmlsaXR5IHRlc3RzIGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBydW4gdmlzaWJpbGl0eSB0ZXN0cyBmb3JcclxuICAgICAqICogQHJldHVybnMgUmVzdWx0cyBvZiB2aXNpYmlsaXR5IHRlc3RzXHJcbiAgICAgKi9cclxuICAgIC8vIHZpc2libGU8VD4oZGF0YTogVCwgcHJvcGVydHk6IFByb3BlcnR5PFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8UHJvcGVydHlUZXN0UmVzdWx0czxUPj4ge1xyXG4gICAgLy8gICAgIHJldHVybiB0aGlzLnJ1bkFsbFRlc3RzKGRhdGEsIHByb3BlcnR5LnZpZXcsIHN0YXRlKVxyXG4gICAgLy8gICAgICAgICAucGlwZShcclxuICAgIC8vICAgICAgICAgICAgIG1hcCgocmVzdWx0czogUHJvcGVydHlUZXN0UmVzdWx0czxUPikgPT4ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIHJlc3VsdHMucHJvcGVydHlOYW1lID0gcHJvcGVydHkuYWJzb2x1dGVQYXRoO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzIGFzIFByb3BlcnR5VGVzdFJlc3VsdHM8VD47XHJcbiAgICAvLyAgICAgICAgICAgICB9KVxyXG4gICAgLy8gICAgICAgICApO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBhbiBhcnJheSBvZiBzeW5jIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RzXHJcbiAgICAgKi9cclxuICAgIHJ1blRlc3RzPFQ+KGRhdGE6IFQsIHRlc3RzOiBUZXN0PFQ+W10sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogVGVzdFJlc3VsdHNCYXNlPFQ+IHtcclxuICAgICAgICBpZiAoIXRlc3RzIHx8ICF0ZXN0cy5sZW5ndGgpIHJldHVybiBuZXcgVGVzdFJlc3VsdHNCYXNlKFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGVzdFJlc3VsdHMgPSB0ZXN0c1xyXG4gICAgICAgICAgICAubWFwKHQgPT4gdGhpcy5ydW5UZXN0KGRhdGEsIHQsIHN0YXRlKSlcclxuICAgICAgICAgICAgLmZpbHRlcih4ID0+ICEheCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVGVzdFJlc3VsdHNCYXNlKHRlc3RSZXN1bHRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYW4gYXJyYXkgb2YgYXN5bmMgdGVzdHNcclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcGVyZm9ybSB0ZXN0cyBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gdGVzdHMgVGVzdHMgdG8gcnVuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHQgb2YgdGVzdHNcclxuICAgICAqL1xyXG4gICAgcnVuVGVzdHNBc3luYzxUPihkYXRhOiBULCB0ZXN0czogVGVzdDxUPltdLCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IE9ic2VydmFibGU8VGVzdFJlc3VsdHNCYXNlPFQ+PiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0cyB8fCAhdGVzdHMubGVuZ3RoKSByZXR1cm4gb2YobmV3IFRlc3RSZXN1bHRzQmFzZShbXSkpO1xyXG5cclxuICAgICAgICBjb25zdCBydW5UZXN0JCA9IHRlc3RzXHJcbiAgICAgICAgICAgIC5tYXAodGVzdCA9PiB0aGlzLnJ1blRlc3RBc3luYyhkYXRhLCB0ZXN0LCBzdGF0ZSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4ocnVuVGVzdCQpXHJcbiAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgbWFwKHRlc3RSZXN1bHRzID0+IG5ldyBUZXN0UmVzdWx0c0Jhc2UodGVzdFJlc3VsdHMuZmlsdGVyKHggPT4gISF4KSkpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGFuIGFycmF5IG9mIHN5bmMgYW5kIGFzeW5jIHRlc3RzXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdHMgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHRlc3RzIFRlc3RzIHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RzXHJcbiAgICAgKi9cclxuICAgIHJ1bkFsbFRlc3RzPFQ+KGRhdGE6IFQsIHRlc3RzOiBUZXN0PFQ+W10sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxUZXN0UmVzdWx0c0Jhc2U8VD4+IHtcclxuICAgICAgICBpZiAoIXRlc3RzIHx8ICF0ZXN0cy5sZW5ndGgpIHJldHVybiBvZihuZXcgVGVzdFJlc3VsdHNCYXNlKFtdKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN5bmNHcm91cHMgPSB0aGlzLmdyb3VwVGVzdHNCeVN5bmNUeXBlKHRlc3RzKTtcclxuICAgICAgICBjb25zdCBzeW5jVGVzdFJlc3VsdHMgPSBvZih0aGlzLnJ1blRlc3RzKGRhdGEsIHN5bmNHcm91cHMuc3luYywgc3RhdGUpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bmNUZXN0UmVzdWx0cy5waXBlKFxyXG4gICAgICAgICAgICBtZXJnZU1hcChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQucGFzc2VkKSByZXR1cm4gb2YocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UZXN0c0FzeW5jKGRhdGEsIHN5bmNHcm91cHMuYXN5bmMsIHN0YXRlKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRha2UoMSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgc3luYyB0ZXN0IG9uIGEgc2V0IG9mIGRhdGFcclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcGVyZm9ybSB0ZXN0IGFnYWluc3RcclxuICAgICAqIEBwYXJhbSB0ZXN0IFRlc3QgdG8gcnVuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHQgb2YgdGVzdFxyXG4gICAgICovXHJcbiAgICBydW5UZXN0PFQ+KGRhdGE6IFQsIHRlc3Q6IFRlc3Q8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogVGVzdFJlc3VsdDxUPiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgcGFzc2VkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiB0cnVlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IG51bGwgfTtcclxuICAgICAgICBjb25zdCBmYWlsZWRUZXN0UmVzdWx0OiBUZXN0UmVzdWx0PFQ+ID0geyBwYXNzZWQ6IGZhbHNlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IHRlc3QubWVzc2FnZSB9O1xyXG4gICAgICAgIGNvbnN0IHNraXBwZWRUZXN0UmVzdWx0OiBUZXN0UmVzdWx0PFQ+ID0geyBwYXNzZWQ6IHRydWUsIHNraXBwZWQ6IHRydWUsIG5hbWU6IHRlc3QubmFtZSwgbWVzc2FnZTogbnVsbCB9O1xyXG5cclxuICAgICAgICBjb25zdCBjb25kaXRpb25zUnVsZVNldFJlc3VsdCA9IHRoaXMucHJvY2Vzc1J1bGVTZXQoZGF0YSwgdGVzdC5jb25kaXRpb24sIHN0YXRlKTtcclxuICAgICAgICBpZiAoY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQgPT09IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZCkgcmV0dXJuIHNraXBwZWRUZXN0UmVzdWx0O1xyXG5cclxuICAgICAgICBjb25zdCBjaGVja1J1bGVTZXRSZXN1bHQgPSB0aGlzLnByb2Nlc3NSdWxlU2V0KGRhdGEsIHRlc3QuY2hlY2ssIHN0YXRlKTtcclxuICAgICAgICBzd2l0Y2ggKGNoZWNrUnVsZVNldFJlc3VsdCkge1xyXG4gICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXNzZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcHBlZFRlc3RSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYXN5bmMgdGVzdCBvbiBhIHNldCBvZiBkYXRhXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBlcmZvcm0gdGVzdCBhZ2FpbnN0XHJcbiAgICAgKiBAcGFyYW0gdGVzdCBUZXN0IHRvIHJ1blxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRlc3RcclxuICAgICAqL1xyXG4gICAgcnVuVGVzdEFzeW5jPFQ+KGRhdGE6IFQsIHRlc3Q6IFRlc3Q8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxUZXN0UmVzdWx0PFQ+PiB7XHJcbiAgICAgICAgaWYgKCF0ZXN0KSByZXR1cm4gb2YobnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhc3NlZFRlc3RSZXN1bHQ6IFRlc3RSZXN1bHQ8VD4gPSB7IHBhc3NlZDogdHJ1ZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiBudWxsIH07XHJcbiAgICAgICAgY29uc3QgZmFpbGVkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiBmYWxzZSwgbmFtZTogdGVzdC5uYW1lLCBtZXNzYWdlOiB0ZXN0Lm1lc3NhZ2UgfTtcclxuICAgICAgICBjb25zdCBza2lwcGVkVGVzdFJlc3VsdDogVGVzdFJlc3VsdDxUPiA9IHsgcGFzc2VkOiB0cnVlLCBza2lwcGVkOiB0cnVlLCBuYW1lOiB0ZXN0Lm5hbWUsIG1lc3NhZ2U6IG51bGwgfTtcclxuXHJcbiAgICAgICAgY29uc3QgY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQkID0gdGhpcy5wcm9jZXNzUnVsZVNldEFzeW5jKGRhdGEsIHRlc3QuY29uZGl0aW9uLCBzdGF0ZSk7XHJcbiAgICAgICAgY29uc3QgY2hlY2tSdWxlU2V0UmVzdWx0JCA9IHRoaXMucHJvY2Vzc1J1bGVTZXRBc3luYyhkYXRhLCB0ZXN0LmNoZWNrLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25kaXRpb25zUnVsZVNldFJlc3VsdCRcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBmbGF0TWFwKGNvbmRpdGlvbnNSdWxlU2V0UmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uc1J1bGVTZXRSZXN1bHQgPT09IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZCkgcmV0dXJuIG9mKHNraXBwZWRUZXN0UmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUnVsZVNldFJlc3VsdCRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAoY2hlY2tSdWxlU2V0UmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoZWNrUnVsZVNldFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXNzZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsZWRUZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2tpcHBlZFRlc3RSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzZXMgYSBzeW5jIHJ1bGUgc2V0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHByb2Nlc3MgcnVsZSBzZXQgYWdhaW5zdFxyXG4gICAgICogQHBhcmFtIHJ1bGVTZXQgUnVsZSBzZXQgdG8gcHJvY2Vzc1xyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHJ1bGUgc2V0IHByb2Nlc3NpbmdcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc1J1bGVTZXQ8VD4oZGF0YTogVCwgcnVsZVNldDogUnVsZVNldDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBQcm9jZXNzUmVzdWx0VHlwZSB7XHJcbiAgICAgICAgaWYgKCFydWxlU2V0KSByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZDtcclxuXHJcbiAgICAgICAgY29uc3QgaXNSdWxlR3JvdXAgPSB0aGlzLmlzUnVsZUdyb3VwKHJ1bGVTZXQpO1xyXG4gICAgICAgIHJldHVybiBpc1J1bGVHcm91cFxyXG4gICAgICAgICAgICA/IHRoaXMucHJvY2Vzc1J1bGVHcm91cChkYXRhLCBydWxlU2V0IGFzIFJ1bGVHcm91cDxUPiwgc3RhdGUpXHJcbiAgICAgICAgICAgIDogdGhpcy5wcm9jZXNzUnVsZShkYXRhLCBydWxlU2V0IGFzIFJ1bGU8VD4sIHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3NlcyBhbiBhc3luYyBydWxlIHNldFxyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBwcm9jZXNzIHJ1bGUgc2V0IGFnYWluc3RcclxuICAgICAqIEBwYXJhbSBydWxlU2V0IFJ1bGUgc2V0IHRvIHByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiBydWxlIHNldCBwcm9jZXNzaW5nXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NSdWxlU2V0QXN5bmM8VD4oZGF0YTogVCwgcnVsZVNldDogUnVsZVNldDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFByb2Nlc3NSZXN1bHRUeXBlPiB7XHJcbiAgICAgICAgaWYgKCFydWxlU2V0KSByZXR1cm4gb2YoUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUnVsZUdyb3VwID0gdGhpcy5pc1J1bGVHcm91cChydWxlU2V0KTtcclxuICAgICAgICByZXR1cm4gaXNSdWxlR3JvdXBcclxuICAgICAgICAgICAgPyB0aGlzLnByb2Nlc3NSdWxlR3JvdXBBc3luYyhkYXRhLCBydWxlU2V0IGFzIFJ1bGVHcm91cDxUPiwgc3RhdGUpXHJcbiAgICAgICAgICAgIDogdGhpcy5wcm9jZXNzUnVsZUFzeW5jKGRhdGEsIHJ1bGVTZXQgYXMgUnVsZTxUPiwgc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcHJvY2Vzc1J1bGVHcm91cDxUPihkYXRhOiBULCBydWxlR3JvdXA6IFJ1bGVHcm91cDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBQcm9jZXNzUmVzdWx0VHlwZSB7XHJcbiAgICAgICAgaWYgKCFydWxlR3JvdXAucnVsZXMpIHJldHVybiBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkO1xyXG5cclxuICAgICAgICBsZXQgcGFzc2VkQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBza2lwcGVkQ291bnQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVHcm91cC5ydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZUdyb3VwLnJ1bGVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBydWxlU2V0UmVzdWx0ID0gdGhpcy5wcm9jZXNzUnVsZVNldChkYXRhLCBydWxlLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5TaG9ydENpcmN1aXRSdWxlR3JvdXAocnVsZVNldFJlc3VsdCwgcnVsZUdyb3VwKSkgcmV0dXJuIHJ1bGVTZXRSZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocnVsZVNldFJlc3VsdCA9PSBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQpIHBhc3NlZENvdW50Kys7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGVTZXRSZXN1bHQgPT0gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZCkgc2tpcHBlZENvdW50Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB3ZSBza2lwcGVkIHRoZW0gYWxsLCB0aGVuIHJldHVybiBza2lwcGVkXHJcbiAgICAgICAgaWYgKHNraXBwZWRDb3VudCA9PT0gcnVsZUdyb3VwLnJ1bGVzLmxlbmd0aCkgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGdvdCB0aGlzIGZhciwgbWFrZSBzdXJlIGFsbCB0ZXN0cyB3ZXJlIHBhc3NlZFxyXG4gICAgICAgIHJldHVybiBwYXNzZWRDb3VudCA9PT0gcnVsZUdyb3VwLnJ1bGVzLmxlbmd0aCA/IFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZCA6IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHByb2Nlc3NSdWxlR3JvdXBBc3luYzxUPihkYXRhOiBULCBydWxlR3JvdXA6IFJ1bGVHcm91cDxUPiwgc3RhdGU/OiBUZXN0UnVuU3RhdGUpOiBPYnNlcnZhYmxlPFByb2Nlc3NSZXN1bHRUeXBlPiB7XHJcbiAgICAgICAgaWYgKCFydWxlR3JvdXAucnVsZXMpIHJldHVybiBvZihQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkKTtcclxuICAgICAgICBjb25zdCBhc3luY1J1bGVTZXRSZXN1bHRzJCA9IHJ1bGVHcm91cC5ydWxlcy5tYXAoeCA9PiB0aGlzLnByb2Nlc3NSdWxlU2V0QXN5bmMoZGF0YSwgeCwgc3RhdGUpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGFzeW5jUnVsZVNldFJlc3VsdHMkKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAocnVsZVNldFJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZDogcnVsZVNldFJlc3VsdHMuZmlsdGVyKHggPT4geCA9PT0gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkOiBydWxlU2V0UmVzdWx0cy5maWx0ZXIoeCA9PiB4ID09PSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQpLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkOiBydWxlU2V0UmVzdWx0cy5maWx0ZXIoeCA9PiB4ID09PSBQcm9jZXNzUmVzdWx0VHlwZS5Ta2lwcGVkKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVHcm91cE9wdGlvbnMgPSBydWxlR3JvdXAub3B0aW9ucyB8fCB7IHJlc3VsdFJlcXVpcmVtZW50czogUmVzdWx0c1Bhc3NSZXF1aXJlbWVudC5BbGxQYXNzIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQW55UGFzcyAmJiBjb3VudHMucGFzc2VkID4gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQWxsUGFzcyAmJiBjb3VudHMucGFzc2VkID09PSBydWxlU2V0UmVzdWx0cy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZDtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudHMuc2tpcHBlZCA9PT0gcnVsZVNldFJlc3VsdHMubGVuZ3RoKSByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuU2tpcHBlZDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvY2Vzc1Jlc3VsdFR5cGUuRmFpbGVkO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwcm9jZXNzUnVsZTxUPihkYXRhOiBULCBydWxlOiBSdWxlPFQ+LCBzdGF0ZT86IFRlc3RSdW5TdGF0ZSk6IFByb2Nlc3NSZXN1bHRUeXBlIHtcclxuICAgICAgICBpZiAoIXJ1bGUuZnVuYykgcmV0dXJuIFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvb3REYXRhID0gc3RhdGUgPyBzdGF0ZS5yb290RGF0YSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGUuZnVuYyhkYXRhLCByb290RGF0YSkgPyBQcm9jZXNzUmVzdWx0VHlwZS5QYXNzZWQgOiBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwcm9jZXNzUnVsZUFzeW5jPFQ+KGRhdGE6IFQsIHJ1bGU6IFJ1bGU8VD4sIHN0YXRlPzogVGVzdFJ1blN0YXRlKTogT2JzZXJ2YWJsZTxQcm9jZXNzUmVzdWx0VHlwZT4ge1xyXG4gICAgICAgIGlmICghcnVsZS5mdW5jICYmICFydWxlLmFzeW5jRnVuYykgcmV0dXJuIG9mKFByb2Nlc3NSZXN1bHRUeXBlLlNraXBwZWQpO1xyXG5cclxuICAgICAgICBjb25zdCByb290RGF0YSA9IHN0YXRlID8gc3RhdGUucm9vdERhdGEgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGZ1bmNSZXN1bHQgPSBydWxlLmZ1bmNcclxuICAgICAgICAgICAgPyBvZihydWxlLmZ1bmMoZGF0YSwgcm9vdERhdGEpKVxyXG4gICAgICAgICAgICA6IHJ1bGUuYXN5bmNGdW5jKGRhdGEsIHJvb3REYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmNSZXN1bHRcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBtYXAocGFzc2VkID0+IHBhc3NlZCA/IFByb2Nlc3NSZXN1bHRUeXBlLlBhc3NlZCA6IFByb2Nlc3NSZXN1bHRUeXBlLkZhaWxlZClcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcml2YXRlIGRvUHJvY2Vzc1J1bGU8VD4ocnVsZTogUnVsZTxUPiwgc3RhdGU6IFRlc3RSdW5TdGF0ZSwgaXNBc3luYzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgLy8gICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSBmdW5jIHRvIGNhbGxcclxuICAgIC8vICAgICBpZiAoKGlzQXN5bmMgJiYgIXJ1bGUuYXN5bmNGdW5jKSB8fCAoIWlzQXN5bmMgJiYgIXJ1bGUuZnVuYykpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyAgICAgLy8gLy8gaWYgdGhlcmUgaXMgbWlzc2luZyBkYXRhLCB0aGVuIGFzc3VtZSB3ZSBzaG91bGQgcHJvY2VzcyB0aGUgcnVsZVxyXG4gICAgLy8gICAgIC8vIGlmICghcnVsZS5vcHRpb25zIHx8ICFydWxlLm9wdGlvbnMuY29udHJvbFN0YXRlT3B0aW9ucyB8fCAhc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xTdGF0ZSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgLy8gICAgIC8vIGlmIChydWxlLm9wdGlvbnMuY29udHJvbFN0YXRlT3B0aW9ucy5za2lwUHJpc3RpbmUgJiYgc3RhdGUuY29udHJvbFN0YXRlLnByaXN0aW5lKSByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyAgICAgLy8gaWYgKHJ1bGUub3B0aW9ucy5jb250cm9sU3RhdGVPcHRpb25zLnNraXBVbnRvdWNoZWQgJiYgc3RhdGUuY29udHJvbFN0YXRlLnVudG91Y2hlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwcml2YXRlIGNhblNob3J0Q2lyY3VpdFJ1bGVHcm91cDxUPihydWxlU2V0UmVzdWx0OiBQcm9jZXNzUmVzdWx0VHlwZSwgcnVsZUdyb3VwOiBSdWxlR3JvdXA8VD4pOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBydWxlR3JvdXBPcHRpb25zID0gcnVsZUdyb3VwLm9wdGlvbnMgfHwgeyByZXN1bHRSZXF1aXJlbWVudHM6IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQWxsUGFzcyB9O1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAvLyBpdCBwYXNzZWQsIGFuZCB3ZSBvbmx5IG5lZWQgb25lIHRvIHBhc3NcclxuICAgICAgICAgICAgKHJ1bGVTZXRSZXN1bHQgPT0gUHJvY2Vzc1Jlc3VsdFR5cGUuUGFzc2VkICYmIHJ1bGVHcm91cE9wdGlvbnMucmVzdWx0UmVxdWlyZW1lbnRzID09IFJlc3VsdHNQYXNzUmVxdWlyZW1lbnQuQW55UGFzcylcclxuICAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgLy8gaWYgZmFpbGVkLCBhbmQgd2UgbmVlZCBhbGwgdG8gcGFzc1xyXG4gICAgICAgICAgICAocnVsZVNldFJlc3VsdCA9PSBQcm9jZXNzUmVzdWx0VHlwZS5GYWlsZWQgJiYgcnVsZUdyb3VwT3B0aW9ucy5yZXN1bHRSZXF1aXJlbWVudHMgPT0gUmVzdWx0c1Bhc3NSZXF1aXJlbWVudC5BbGxQYXNzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc1J1bGVHcm91cDxUPihydWxlU2V0OiBSdWxlU2V0PFQ+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVTZXQgYXMgUnVsZTxUPjtcclxuICAgICAgICByZXR1cm4gIXJ1bGUuZnVuYyAmJiAhcnVsZS5hc3luY0Z1bmM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21UZXN0PFQ+KHRlc3Q6IFRlc3Q8VD4pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tEZXBzID0gdGhpcy5nZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21SdWxlU2V0PFQ+KHRlc3QuY2hlY2spO1xyXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbkRlcHMgPSB0aGlzLmdldERlcGVuZGVuY3lQcm9wZXJ0aWVzRnJvbVJ1bGVTZXQ8VD4odGVzdC5jb25kaXRpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1vblN2Yy51bmlxdWUoY2hlY2tEZXBzLmNvbmNhdChjb25kaXRpb25EZXBzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXREZXBlbmRlbmN5UHJvcGVydGllc0Zyb21SdWxlU2V0PFQ+KHJ1bGVTZXQ6IFJ1bGVTZXQ8VD4pOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgaWYgKCFydWxlU2V0KSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNSdWxlR3JvdXAocnVsZVNldCkpIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZUdyb3VwID0gcnVsZVNldCBhcyBSdWxlR3JvdXA8VD47XHJcbiAgICAgICAgICAgIHJ1bGVHcm91cC5ydWxlcy5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy5jb21tb25TdmMudW5pcXVlKHRoaXMuZ2V0RGVwZW5kZW5jeVByb3BlcnRpZXNGcm9tUnVsZVNldCh4KSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlU2V0IGFzIFJ1bGU8VD47XHJcbiAgICAgICAgaWYgKHJ1bGUub3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHJ1bGUub3B0aW9ucy5kZXBlbmRlbmN5UHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy5jb21tb25TdmMudW5pcXVlKHJ1bGUub3B0aW9ucy5kZXBlbmRlbmN5UHJvcGVydGllcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbW9uU3ZjLnVuaXF1ZShyZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0UHJvcGVydHlNZXRhZGF0YShwcm9wZXJ0aWVzOiBQcm9wZXJ0eUJhc2U8YW55PltdLCBtb2RlbFNldHRpbmdzTmFtZTogc3RyaW5nLCBjdXJyZW50QWJzb2x1dGVQYXRoOiBzdHJpbmcgPSAnJyk6IHZvaWQge1xyXG4gICAgICAgIGlmICghcHJvcGVydGllcykgcmV0dXJuO1xyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0Fic29sdXRlUGF0aCA9IHRoaXMuc2V0UHJvcGVydHlBYnNvbHV0ZVBhdGgocHJvcCwgY3VycmVudEFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbEluRW1wdHlUZXN0TmFtZXMocHJvcCk7XHJcbiAgICAgICAgICAgIHByb3Auc2V0T3duZXJNb2RlbFNldHRpbmdzTmFtZShtb2RlbFNldHRpbmdzTmFtZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcC5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5TWV0YWRhdGEocHJvcC5wcm9wZXJ0aWVzLCBtb2RlbFNldHRpbmdzTmFtZSwgbmV3QWJzb2x1dGVQYXRoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wLmFycmF5SXRlbVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5TWV0YWRhdGEoW3Byb3AuYXJyYXlJdGVtUHJvcGVydHldLCBtb2RlbFNldHRpbmdzTmFtZSwgbmV3QWJzb2x1dGVQYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0UHJvcGVydHlBYnNvbHV0ZVBhdGgocHJvcGVydHk6IFByb3BlcnR5QmFzZTxhbnk+LCBjdXJyZW50QWJzb2x1dGVQYXRoOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgaXNBcnJheUl0ZW1Qcm9wZXJ0eSA9IFByb3BlcnR5QmFzZS5pc0FycmF5SXRlbVByb3BlcnR5KHByb3BlcnR5KTtcclxuICAgICAgICBjb25zdCBuZXdBYnNvbHV0ZVBhdGhTZWdtZW50ID0gaXNBcnJheUl0ZW1Qcm9wZXJ0eSA/ICdbXScgOiAocHJvcGVydHkgYXMgUHJvcGVydHk8YW55PikubmFtZTtcclxuICAgICAgICBjb25zdCBpc0F0Um9vdCA9ICFjdXJyZW50QWJzb2x1dGVQYXRoO1xyXG4gICAgICAgIGNvbnN0IG5ld0Fic29sdXRlUGF0aCA9IGAke2N1cnJlbnRBYnNvbHV0ZVBhdGh9JHtpc0F0Um9vdCA/ICcnIDogJy4nfSR7bmV3QWJzb2x1dGVQYXRoU2VnbWVudH1gO1xyXG5cclxuICAgICAgICAvLyBzZXQgYWJzb2x1dGUgcGF0aCBmb3IgcHJvcGVydHlcclxuICAgICAgICBwcm9wZXJ0eS5zZXRBYnNvbHV0ZVBhdGgobmV3QWJzb2x1dGVQYXRoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld0Fic29sdXRlUGF0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZpbGxJbkVtcHR5VGVzdE5hbWVzKHByb3BlcnR5OiBQcm9wZXJ0eUJhc2U8YW55Pikge1xyXG4gICAgICAgIHByb3BlcnR5LnZhbGlkXHJcbiAgICAgICAgICAgIC5maWx0ZXIodGVzdCA9PiAhdGVzdC5uYW1lKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgodGVzdCwgaSkgPT4gdGVzdC5uYW1lID0gYHZhbGlkVGVzdCR7aX1gKTtcclxuXHJcbiAgICAgICAgcHJvcGVydHkuZWRpdFxyXG4gICAgICAgICAgICAuZmlsdGVyKHRlc3QgPT4gIXRlc3QubmFtZSlcclxuICAgICAgICAgICAgLmZvckVhY2goKHRlc3QsIGkpID0+IHRlc3QubmFtZSA9IGBlZGl0VGVzdCR7aX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldENvbmZpZ3VyZWRGdW5jVHlwZXM8VD4ocnVsZVNldDogUnVsZVNldDxUPik6IENvbmZpZ3VyZWRGdW5jVHlwZXMge1xyXG4gICAgICAgIGlmICghcnVsZVNldCkgcmV0dXJuIHsgc3luYzogZmFsc2UsIGFzeW5jOiBmYWxzZSB9O1xyXG5cclxuICAgICAgICBjb25zdCBpc1J1bGVHcm91cCA9IHRoaXMuaXNSdWxlR3JvdXAocnVsZVNldCk7XHJcblxyXG4gICAgICAgIGlmIChpc1J1bGVHcm91cCkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlR3JvdXAgPSBydWxlU2V0IGFzIFJ1bGVHcm91cDxUPjtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHJ1bGVHcm91cC5ydWxlc1xyXG4gICAgICAgICAgICAgICAgLm1hcChycyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlndXJlZEZ1bmNUeXBlcyhycyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jOiByZXN1bHRzLmZpbmRJbmRleCh4ID0+ICEheC5zeW5jKSA+PSAwLFxyXG4gICAgICAgICAgICAgICAgYXN5bmM6IHJlc3VsdHMuZmluZEluZGV4KHggPT4gISF4LmFzeW5jKSA+PSAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlU2V0IGFzIFJ1bGU8VD47XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jOiAhIXJ1bGUuZnVuYyxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXJ1bGUuYXN5bmNGdW5jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29uZmlndXJlZEZ1bmNUeXBlcyB7XHJcbiAgICBzeW5jOiBib29sZWFuO1xyXG4gICAgYXN5bmM6IGJvb2xlYW47XHJcbn1cclxuIl19