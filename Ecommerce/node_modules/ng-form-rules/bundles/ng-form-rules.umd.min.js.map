{"version":3,"sources":["null","ng://ng-form-rules/lib/form-rules/injection-tokens/model-settings.token.ts","ng://ng-form-rules/lib/form-rules/injection-tokens/trace-settings.token.ts","ng://ng-form-rules/lib/utils/trace/trace.service.ts","ng://ng-form-rules/lib/utils/common/common.service.ts","ng://ng-form-rules/lib/form-rules/models/test-results-base.ts","ng://ng-form-rules/lib/form-rules/models/property-base.ts","ng://ng-form-rules/lib/rules-engine/services/rules-engine/rules-engine.service.ts","ng://ng-form-rules/lib/form-rules/models/control-state.ts","ng://ng-form-rules/lib/rules-engine/services/reactive-forms-rule/reactive-forms-rule.service.ts","ng://ng-form-rules/lib/utils/utils.module.ts","ng://ng-form-rules/lib/rules-engine/rules-engine.module.ts","ng://ng-form-rules/lib/form-rules/form-rules.module.ts","ng://ng-form-rules/lib/form-rules/models/property.ts","ng://ng-form-rules/lib/form-rules/models/array-item-property.ts","ng://ng-form-rules/lib/form-rules/helper/model-settings-builder.ts","ng://ng-form-rules/lib/form-rules/models/abstract-model-settings.ts","ng://ng-form-rules/lib/form-rules/models/property-test-result.ts","ng://ng-form-rules/lib/form-rules/models/adhoc-model-settings.ts","ng://ng-form-rules/lib/form-rules/models/value-change-options.ts"],"names":["extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","MODEL_SETTINGS_TOKEN","InjectionToken","TRACE_SETTINGS_TOKEN","TraceService","doTrace","trace","msg","fullMsg","getTimeStamp","console","log","Date","toLocaleTimeString","Injectable","Optional","type","Inject","args","CommonService","unique","values","isArray","from","Set","isZeroOrGreater","TestResultsBase","results","defineProperty","failedResults","filter","x","passed","skipped","messages","map","message","PropertyBase","dependencyProperties","valid","distinctUntilChanged","debounceMilliseconds","edit","self","asyncValid","_absolutePath","_dependencyPropertySubscriptions","_ownerModelSettingsName","isArrayItemProperty","property","name","setAbsolutePath","absolutePath","addDependencyPropertySubscription","subscription","clearDependencyPropertySubscriptions","dependencyPropertySubscriptions","forEach","sub$","unsubscribe","setOwnerModelSettingsName","RulesEngineService","settings","traceSvc","commonSvc","_this","registeredSettings","setting","initializeModelSetting","setPropertyMetadata","properties","getModelSettings","assign","getDependencyProperties","tests","deps","t","getDependencyPropertiesFromTest","reduce","prev","current","groupTestsBySyncType","testGroups","sync","async","test","testFuncTypes","conditionResults","getConfiguredFuncTypes","condition","checkResults","check","validate","data","state","runAllTests","pipe","propertyName","editable","runTests","testResults","runTest","runTestsAsync","of","runTest$","runTestAsync","forkJoin","syncGroups","mergeMap","result","take","passedTestResult","failedTestResult","skippedTestResult","processRuleSet","ProcessResultType","Failed","Passed","Skipped","conditionsRuleSetResult$","processRuleSetAsync","checkRuleSetResult$","flatMap","conditionsRuleSetResult","checkRuleSetResult","ruleSet","isRuleGroup","processRuleGroup","processRule","processRuleGroupAsync","processRuleAsync","ruleGroup","rules","passedCount","skippedCount","rule","ruleSetResult","canShortCircuitRuleGroup","asyncRuleSetResults$","ruleSetResults","counts","ruleGroupOptions","options","resultRequirements","ResultsPassRequirement","AllPass","AnyPass","func","rootData","asyncFunc","checkDeps","getDependencyPropertiesFromRuleSet","conditionDeps","apply","modelSettingsName","currentAbsolutePath","prop","newAbsolutePath","setPropertyAbsolutePath","fillInEmptyTestNames","arrayItemProperty","rs","findIndex","ControlState","control","_pristine","pristine","_untouched","untouched","ReactiveFormsRuleService","rulesEngineSvc","formBuilder","createFormGroup","modelSettings","initialValue","Error","formGroup","buildGroup","resetDependencySubscriptions","triggerValueChange","attachModelSettingsToForm","addArrayItemPropertyControl","parentFormArray","buildAbstractControl","index","insert","getModelSettingsFromForm","root","extendValidator","validator","validatorArray","setValidators","tslib_1.__spread","validatorFn","extendAsyncValidator","asyncValidator","asyncValidatorArray","setAsyncValidators","asyncValidatorFn","buildArray","updateOn","buildControl","buildValidatorFunction","buildAsyncValidatorFunction","valueChanges","applyValueChangeOptions","valueChangeOptions","subscribe","persistEditTests","FormControl","FormGroup","propertyValue","ctrl","addControl","FormArray","v","controlContextValues","getControlContextValues","relative","controlState","buildTestResultStatsString","mapToReactiveFormsValidationErrors","rawAsyncFunc","buildAsyncValidatorFunctionRaw","BehaviorSubject","valid$","applyAsyncValidValueChangeOptions","switchMap","passthrough","currentErrors","errors","lastNgFormRulesErrors","getLastErrorForControl","ngFormRules","tap","setLastErrorForControl","parentControl","removeDependencySubscriptions","addDependencySubscriptions","arrayIndex","propertyControl","getPropertyFromParent","setupEditabilityDependencySubscriptions","setupValidationDependencySubscriptions","formArrayControl","dependencyControl","findControlRelatively","setForceAsyncValidationTestForControl","updateValueAndValidity","onlySelf","emitEvent","dpn","disabled","enable","enabled","disable","source$","lastValue","isForce","doesControlHaveForcedAsyncValidation","debounce","timer","EMPTY","getRawValue","parent","at","get","failed","path","relativePaths","buildControlRelativePathArray","pathSegment","getControlByPathSegment","relativePath","split","slashItem","dotSeparated","dotItem","passedResults","skippedResults","FORM_MODEL_SETTINGS_PROPERTY_NAME","force","FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME","CONTROL_LAST_ERROR","patchValue","FormBuilder","UtilsModule","NgModule","imports","declarations","providers","RulesEngineModule","CommonModule","exports","Property","_super","_name","tslib_1.__extends","ArrayItemProperty","ModelSettingsBuilder","extend","validTest","validNamedTest","editTest","editNamedTest","ruleCombo","ruleAsync","ruleSets","AbstractModelSettings","builder","buildProperties","PropertyTestResults","AdhocModelSettings","propertyBuilderFunc","instance","ValueChangeOptions"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { InjectionToken } from \"@angular/core\";\r\n\r\n/**\r\n * Injection token for providing an array of model settings\r\n */\r\nexport let MODEL_SETTINGS_TOKEN = new InjectionToken<string>('ngfr.model-settings');","import { InjectionToken } from \"@angular/core\";\r\n\r\n/**\r\n * Injection token for enabling ng-form-rules tracing\r\n */\r\nexport let TRACE_SETTINGS_TOKEN = new InjectionToken<string>('ngfr.trace-settings');","import { Injectable, Inject, Optional } from '@angular/core';\r\nimport { TRACE_SETTINGS_TOKEN } from '../../form-rules/injection-tokens/trace-settings.token';\r\n\r\n@Injectable()\r\nexport class TraceService {\r\n    constructor(\r\n        @Optional() @Inject(TRACE_SETTINGS_TOKEN) private doTrace: boolean = false\r\n    ) {\r\n    }\r\n\r\n    trace(msg: string) {\r\n        if (!this.doTrace) return;\r\n\r\n        const fullMsg = `[NGFR - ${this.getTimeStamp()}] ${msg}`;\r\n        console.log(fullMsg);\r\n    }\r\n\r\n    private getTimeStamp(): string {\r\n        return (new Date).toLocaleTimeString();\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class CommonService {\r\n    /**\r\n     * Gets unique values from an array\r\n     * @param values Values to get unique items from\r\n     * @returns Unique values array\r\n     */\r\n    unique(values: any[]): any[] {\r\n        if (!Array.isArray(values)) return [];\r\n\r\n        return Array.from(new Set(values));\r\n    }\r\n\r\n    /**\r\n     * Determines if number is zero or greater\r\n     * @param value If number is greater than or equal zero\r\n     */\r\n    isZeroOrGreater(value: number): boolean {\r\n        if (!value && value === 0) return true;\r\n\r\n        if (!value || typeof value !== \"number\") return false;\r\n\r\n        return value > 0;\r\n    }\r\n}\r\n","import { TestResult } from \"./test-result\";\r\n\r\n/**\r\n * Results of executing a collection of tests\r\n */\r\nexport class TestResultsBase<T> {\r\n    constructor(public results: TestResult<T>[]) {\r\n        this.results = this.results || [];\r\n    }\r\n\r\n    /**\r\n     * Whether the tests passed\r\n     */\r\n    get passed(): boolean {\r\n        return !this.failedResults.length;\r\n    }\r\n\r\n    /**\r\n     * Array of test results that passed\r\n     */\r\n    get passedResults(): TestResult<T>[] {\r\n        return this.results.filter(x => !!x.passed && !x.skipped);\r\n    }\r\n\r\n    /**\r\n     * Array of test results that failed\r\n     */\r\n    get failedResults(): TestResult<T>[] {\r\n        return this.results.filter(x => !x.passed);\r\n    }\r\n\r\n    /**\r\n     * Array of test results that were skipped\r\n     */\r\n    get skippedResults(): TestResult<T>[] {\r\n        return this.results.filter(x => !!x.skipped);\r\n    }\r\n\r\n    /**\r\n     * Message of the first test that failed\r\n     */\r\n    get message(): string {\r\n        return this.messages[0];\r\n    }\r\n\r\n    /**\r\n     * Messages of all failed tests\r\n     */\r\n    get messages(): string[] {\r\n        const messages = this.failedResults.map(x => x.message);\r\n        return Array.from(new Set(messages));\r\n    }\r\n}","import { Test } from \"./test\";\r\nimport { Property } from \"./property\";\r\nimport { ArrayItemProperty } from \"./array-item-property\";\r\nimport { Subscription } from \"rxjs\";\r\nimport { ValueChangeOptions } from \"./value-change-options\";\r\nimport { UpdateOn } from \"./update-on\";\r\n\r\n/**\r\n * Base class for a property\r\n */\r\nexport abstract class PropertyBase<T> {\r\n    private _absolutePath: string;\r\n    private _dependencyPropertySubscriptions: Subscription[] = [];\r\n    private _ownerModelSettingsName: string;\r\n\r\n    /**\r\n     * Validation tests\r\n     */\r\n    valid: Test<T>[] = [];\r\n\r\n    /**\r\n     * Editability tests\r\n     */\r\n    edit: Test<T>[] = [];\r\n\r\n    /**\r\n     * Viewability tests\r\n     */\r\n    // view: Test<T>[] = [];\r\n\r\n    /**\r\n     * Properties for a complex object\r\n     */\r\n    properties?: Property<any>[];\r\n\r\n    /**\r\n     * Property for an item of an array\r\n     */\r\n    arrayItemProperty?: ArrayItemProperty<any>;\r\n\r\n    /**\r\n     * The event name for control to update upon.\r\n     */\r\n    updateOn?: UpdateOn = 'change';\r\n\r\n    /**\r\n     * Absolute path to the property from root\r\n     */\r\n    get absolutePath(): string {\r\n        return this._absolutePath;\r\n    }\r\n\r\n    /**\r\n     * Absolute path to property from root\r\n     */\r\n    get dependencyPropertySubscriptions(): Subscription[] {\r\n        return this._dependencyPropertySubscriptions;\r\n    }\r\n\r\n    /**\r\n     * Absolute path to property from root\r\n     */\r\n    get ownerModelSettingsName(): string {\r\n        return this._ownerModelSettingsName;\r\n    }\r\n\r\n    /**\r\n     * Options for how to respond to value changes on property control and dependency controls\r\n     */\r\n    valueChangeOptions: {\r\n        dependencyProperties: {\r\n            valid: ValueChangeOptions,\r\n            edit: ValueChangeOptions\r\n        },\r\n        self: {\r\n            asyncValid: ValueChangeOptions,\r\n            edit: ValueChangeOptions\r\n        }\r\n    } = {\r\n        dependencyProperties: {\r\n            valid: { distinctUntilChanged: false, debounceMilliseconds: 0 },\r\n            edit: { distinctUntilChanged: false, debounceMilliseconds: 0 }\r\n        },\r\n        self: {\r\n            asyncValid: { distinctUntilChanged: false, debounceMilliseconds: 0 },\r\n            edit: { distinctUntilChanged: false, debounceMilliseconds: 0 }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determines if the property is an ArrayItemProperty\r\n     * @param property Property to check\r\n     * @returns Whether or not the property is an ArrayItemProperty\r\n     */\r\n    static isArrayItemProperty<T>(property: PropertyBase<T>): boolean {\r\n        return !(property as Property<T>).name;\r\n    }\r\n\r\n    /**\r\n     * DO NOT CALL! Internal use only\r\n     * @param absolutePath Absolute path to the property from the root\r\n     */\r\n    setAbsolutePath(absolutePath: string): void {\r\n        this._absolutePath = absolutePath;\r\n    }\r\n\r\n    /**\r\n     * DO NOT CALL! Internal use only\r\n     * @param subscription Subscription for the dependency property\r\n     */\r\n    addDependencyPropertySubscription(subscription: Subscription): void {\r\n        this._dependencyPropertySubscriptions.push(subscription);\r\n    }\r\n\r\n    /**\r\n     * DO NOT CALL! Internal use only\r\n     */\r\n    clearDependencyPropertySubscriptions(): void {\r\n        this.dependencyPropertySubscriptions.forEach(sub$ => sub$.unsubscribe());\r\n        this._dependencyPropertySubscriptions = [];\r\n    }\r\n\r\n    /**\r\n     * DO NOT CALL! Internal use only\r\n     * @param name Name of the owner model settings\r\n     */\r\n    setOwnerModelSettingsName(name: string): void {\r\n        this._ownerModelSettingsName = name;\r\n    }\r\n}","import { Injectable, Inject, Optional } from '@angular/core';\r\nimport { MODEL_SETTINGS_TOKEN } from '../../../form-rules/injection-tokens/model-settings.token';\r\nimport { AbstractModelSettings } from '../../../form-rules/models/abstract-model-settings';\r\nimport { Property } from '../../../form-rules/models/property';\r\nimport { RuleGroup } from '../../../form-rules/models/rule-group';\r\nimport { Rule } from '../../../form-rules/models/rule';\r\nimport { Test } from '../../../form-rules/models/test';\r\nimport { TestResult } from '../../../form-rules/models/test-result';\r\nimport { RuleSet } from '../../../form-rules/models/rule-set';\r\nimport { TestRunState } from '../../../form-rules/models/test-run-state';\r\nimport { TraceService } from '../../../utils/trace/trace.service';\r\nimport { CommonService } from '../../../utils/common/common.service';\r\nimport { Observable, forkJoin, of } from 'rxjs';\r\nimport {  map, flatMap, mergeMap, take, tap } from 'rxjs/operators';\r\nimport { TestResultsBase } from '../../../form-rules/models/test-results-base';\r\nimport { PropertyTestResults } from '../../../form-rules/models/property-test-result';\r\nimport { PropertyBase } from '../../../form-rules/models/property-base';\r\nimport { ProcessResultType } from '../../../form-rules/models/proccess-result-type';\r\nimport { TestSyncGroups } from '../../../form-rules/models/test-sync-groups';\r\nimport { ResultsPassRequirement } from '../../../form-rules/models/results-pass-requirement';\r\n\r\n/**\r\n * Engine that digests model settings and applies their rules appropriately\r\n */\r\n@Injectable()\r\nexport class RulesEngineService {\r\n    private registeredSettings: { [key: string]: AbstractModelSettings<any>; };\r\n\r\n    constructor(\r\n        @Optional() @Inject(MODEL_SETTINGS_TOKEN) settings: AbstractModelSettings<any>[],\r\n        private traceSvc: TraceService,\r\n        private commonSvc: CommonService\r\n    ) {\r\n        this.registeredSettings = {};\r\n\r\n        if (!Array.isArray(settings)) return;\r\n\r\n        settings.forEach(setting => {\r\n            this.initializeModelSetting(setting);\r\n            this.registeredSettings[setting.name] = setting;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes model settings and prepares them to be used in a form group\r\n     * @param setting Model setting to initialize\r\n     */\r\n    initializeModelSetting(setting: AbstractModelSettings<any>): void {\r\n        this.traceSvc.trace(`Initializing model settings \"${setting.name}\"`);\r\n        this.setPropertyMetadata(setting.properties, setting.name);\r\n    }\r\n\r\n    /**\r\n     * Gets model settings with the provided name\r\n     * @param name Name of model setting\r\n     * @returns Model settings with the provided name\r\n     */\r\n    getModelSettings<T>(name: string): AbstractModelSettings<T> {\r\n        this.traceSvc.trace(`Retrieving model settings \"${name}\"`);\r\n\r\n        const settings = this.registeredSettings[name];\r\n\r\n        // create new object\r\n        return settings\r\n            ? Object.assign({}, this.registeredSettings[name])\r\n            : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the dependency properties for an array of tests\r\n     * @param tests Tests to get the dependency properties for\r\n     * @returns Dependency properties\r\n     */\r\n    getDependencyProperties<T>(tests: Test<T>[]): string[] {\r\n        if (!tests) return [];\r\n\r\n        const deps = tests\r\n            .map(t => this.getDependencyPropertiesFromTest(t))\r\n            .reduce((prev, current) => prev.concat(current), []);\r\n\r\n        return this.commonSvc.unique(deps);\r\n    }\r\n\r\n    /**\r\n     * Gets tests grouped by their sync type (e.g. sync vs. async)\r\n     * @param tests Test to groups\r\n     * @returns Tests grouped by sync type\r\n     */\r\n    groupTestsBySyncType<T>(tests: Test<T>[]): TestSyncGroups<T> {\r\n        const testGroups = {\r\n            sync: [],\r\n            async: []\r\n        } as TestSyncGroups<T>;\r\n\r\n        if (!tests) return testGroups;\r\n\r\n        tests.forEach(test => {\r\n            const testFuncTypes = {\r\n                sync: false,\r\n                async: false\r\n            } as ConfiguredFuncTypes;\r\n\r\n            const conditionResults = this.getConfiguredFuncTypes(test.condition);\r\n            const checkResults = this.getConfiguredFuncTypes(test.check);\r\n\r\n            testFuncTypes.sync = conditionResults.sync || checkResults.sync;\r\n            testFuncTypes.async = conditionResults.async || checkResults.async;\r\n\r\n            // if there is an async func anywhere in the test's rule sets, then it is considered an async test\r\n            if (testFuncTypes.sync && !testFuncTypes.async) testGroups.sync.push(test);\r\n            if (testFuncTypes.async) testGroups.async.push(test);\r\n        });\r\n\r\n        return testGroups;\r\n    }\r\n\r\n    /**\r\n     * Runs validation tests\r\n     * @param data Data to run validation tests against\r\n     * @param property Property to run validation tests for\r\n     * @returns Results of validation tests\r\n     */\r\n    validate<T>(data: T, property: Property<T>, state?: TestRunState): Observable<PropertyTestResults<T>> {\r\n        return this.runAllTests(data, property.valid, state)\r\n            .pipe(\r\n                map((results: PropertyTestResults<T>) => {\r\n                    results.propertyName = property.absolutePath;\r\n                    return results as PropertyTestResults<T>;\r\n                })\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Runs editability tests\r\n     * @param data Data to run editability tests against\r\n     * @param property Property to run editability tests for\r\n     * * @returns Results of editability tests\r\n     */\r\n    editable<T>(data: T, property: PropertyBase<T>, state?: TestRunState): Observable<PropertyTestResults<T>> {\r\n        return this.runAllTests(data, property.edit, state)\r\n            .pipe(\r\n                map((results: PropertyTestResults<T>) => {\r\n                    results.propertyName = property.absolutePath;\r\n                    return results as PropertyTestResults<T>;\r\n                })\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Runs visibility tests\r\n     * @param data Data to run visibility tests against\r\n     * @param property Property to run visibility tests for\r\n     * * @returns Results of visibility tests\r\n     */\r\n    // visible<T>(data: T, property: Property<T>, state?: TestRunState): Observable<PropertyTestResults<T>> {\r\n    //     return this.runAllTests(data, property.view, state)\r\n    //         .pipe(\r\n    //             map((results: PropertyTestResults<T>) => {\r\n    //                 results.propertyName = property.absolutePath;\r\n    //                 return results as PropertyTestResults<T>;\r\n    //             })\r\n    //         );\r\n    // }\r\n\r\n    /**\r\n     * Runs an array of sync tests\r\n     * @param data Data to perform tests against\r\n     * @param tests Tests to run\r\n     * @returns Result of tests\r\n     */\r\n    runTests<T>(data: T, tests: Test<T>[], state?: TestRunState): TestResultsBase<T> {\r\n        if (!tests || !tests.length) return new TestResultsBase([]);\r\n\r\n        const testResults = tests\r\n            .map(t => this.runTest(data, t, state))\r\n            .filter(x => !!x);\r\n\r\n        return new TestResultsBase(testResults);\r\n    }\r\n\r\n    /**\r\n     * Runs an array of async tests\r\n     * @param data Data to perform tests against\r\n     * @param tests Tests to run\r\n     * @returns Result of tests\r\n     */\r\n    runTestsAsync<T>(data: T, tests: Test<T>[], state?: TestRunState): Observable<TestResultsBase<T>> {\r\n        if (!tests || !tests.length) return of(new TestResultsBase([]));\r\n\r\n        const runTest$ = tests\r\n            .map(test => this.runTestAsync(data, test, state));\r\n\r\n        return forkJoin(runTest$)\r\n            .pipe(\r\n                map(testResults => new TestResultsBase(testResults.filter(x => !!x)))\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Runs an array of sync and async tests\r\n     * @param data Data to perform tests against\r\n     * @param tests Tests to run\r\n     * @returns Result of tests\r\n     */\r\n    runAllTests<T>(data: T, tests: Test<T>[], state?: TestRunState): Observable<TestResultsBase<T>> {\r\n        if (!tests || !tests.length) return of(new TestResultsBase([]));\r\n\r\n        const syncGroups = this.groupTestsBySyncType(tests);\r\n        const syncTestResults = of(this.runTests(data, syncGroups.sync, state));\r\n\r\n        return syncTestResults.pipe(\r\n            mergeMap(result => {\r\n                if (!result.passed) return of(result);\r\n\r\n                return this.runTestsAsync(data, syncGroups.async, state);\r\n            }),\r\n            take(1)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Performs sync test on a set of data\r\n     * @param data Data to perform test against\r\n     * @param test Test to run\r\n     * @returns Result of test\r\n     */\r\n    runTest<T>(data: T, test: Test<T>, state?: TestRunState): TestResult<T> {\r\n        if (!test) return null;\r\n\r\n        const passedTestResult: TestResult<T> = { passed: true, name: test.name, message: null };\r\n        const failedTestResult: TestResult<T> = { passed: false, name: test.name, message: test.message };\r\n        const skippedTestResult: TestResult<T> = { passed: true, skipped: true, name: test.name, message: null };\r\n\r\n        const conditionsRuleSetResult = this.processRuleSet(data, test.condition, state);\r\n        if (conditionsRuleSetResult === ProcessResultType.Failed) return skippedTestResult;\r\n\r\n        const checkRuleSetResult = this.processRuleSet(data, test.check, state);\r\n        switch (checkRuleSetResult) {\r\n            case ProcessResultType.Passed:\r\n                return passedTestResult;\r\n            case ProcessResultType.Failed:\r\n                return failedTestResult;\r\n            case ProcessResultType.Skipped:\r\n            default:\r\n                return skippedTestResult;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs async test on a set of data\r\n     * @param data Data to perform test against\r\n     * @param test Test to run\r\n     * @returns Result of test\r\n     */\r\n    runTestAsync<T>(data: T, test: Test<T>, state?: TestRunState): Observable<TestResult<T>> {\r\n        if (!test) return of(null);\r\n\r\n        const passedTestResult: TestResult<T> = { passed: true, name: test.name, message: null };\r\n        const failedTestResult: TestResult<T> = { passed: false, name: test.name, message: test.message };\r\n        const skippedTestResult: TestResult<T> = { passed: true, skipped: true, name: test.name, message: null };\r\n\r\n        const conditionsRuleSetResult$ = this.processRuleSetAsync(data, test.condition, state);\r\n        const checkRuleSetResult$ = this.processRuleSetAsync(data, test.check, state);\r\n\r\n        return conditionsRuleSetResult$\r\n            .pipe(\r\n                flatMap(conditionsRuleSetResult => {\r\n                    if (conditionsRuleSetResult === ProcessResultType.Failed) return of(skippedTestResult);\r\n\r\n                    return checkRuleSetResult$\r\n                        .pipe(\r\n                            map(checkRuleSetResult => {\r\n                                switch (checkRuleSetResult) {\r\n                                    case ProcessResultType.Passed:\r\n                                        return passedTestResult;\r\n                                    case ProcessResultType.Failed:\r\n                                        return failedTestResult;\r\n                                    case ProcessResultType.Skipped:\r\n                                    default:\r\n                                        return skippedTestResult;\r\n                                }\r\n                            })\r\n                        );\r\n                })\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Processes a sync rule set\r\n     * @param data Data to process rule set against\r\n     * @param ruleSet Rule set to process\r\n     * @returns Result of rule set processing\r\n     */\r\n    processRuleSet<T>(data: T, ruleSet: RuleSet<T>, state?: TestRunState): ProcessResultType {\r\n        if (!ruleSet) return ProcessResultType.Skipped;\r\n\r\n        const isRuleGroup = this.isRuleGroup(ruleSet);\r\n        return isRuleGroup\r\n            ? this.processRuleGroup(data, ruleSet as RuleGroup<T>, state)\r\n            : this.processRule(data, ruleSet as Rule<T>, state);\r\n    }\r\n\r\n    /**\r\n     * Processes an async rule set\r\n     * @param data Data to process rule set against\r\n     * @param ruleSet Rule set to process\r\n     * @returns Result of rule set processing\r\n     */\r\n    processRuleSetAsync<T>(data: T, ruleSet: RuleSet<T>, state?: TestRunState): Observable<ProcessResultType> {\r\n        if (!ruleSet) return of(ProcessResultType.Skipped);\r\n\r\n        const isRuleGroup = this.isRuleGroup(ruleSet);\r\n        return isRuleGroup\r\n            ? this.processRuleGroupAsync(data, ruleSet as RuleGroup<T>, state)\r\n            : this.processRuleAsync(data, ruleSet as Rule<T>, state);\r\n    }\r\n\r\n    private processRuleGroup<T>(data: T, ruleGroup: RuleGroup<T>, state?: TestRunState): ProcessResultType {\r\n        if (!ruleGroup.rules) return ProcessResultType.Skipped;\r\n\r\n        let passedCount = 0;\r\n        let skippedCount = 0;\r\n\r\n        for (let i = 0; i < ruleGroup.rules.length; i++) {\r\n            const rule = ruleGroup.rules[i];\r\n            const ruleSetResult = this.processRuleSet(data, rule, state);\r\n\r\n            if (this.canShortCircuitRuleGroup(ruleSetResult, ruleGroup)) return ruleSetResult;\r\n\r\n            if (ruleSetResult == ProcessResultType.Passed) passedCount++;\r\n            else if (ruleSetResult == ProcessResultType.Skipped) skippedCount++;\r\n        }\r\n\r\n        // if we skipped them all, then return skipped\r\n        if (skippedCount === ruleGroup.rules.length) return ProcessResultType.Skipped;\r\n\r\n        // if we got this far, make sure all tests were passed\r\n        return passedCount === ruleGroup.rules.length ? ProcessResultType.Passed : ProcessResultType.Failed;\r\n    }\r\n\r\n    private processRuleGroupAsync<T>(data: T, ruleGroup: RuleGroup<T>, state?: TestRunState): Observable<ProcessResultType> {\r\n        if (!ruleGroup.rules) return of(ProcessResultType.Skipped);\r\n        const asyncRuleSetResults$ = ruleGroup.rules.map(x => this.processRuleSetAsync(data, x, state));\r\n\r\n        return forkJoin(asyncRuleSetResults$).pipe(\r\n            map(ruleSetResults => {\r\n                const counts = {\r\n                    passed: ruleSetResults.filter(x => x === ProcessResultType.Passed).length,\r\n                    failed: ruleSetResults.filter(x => x === ProcessResultType.Failed).length,\r\n                    skipped: ruleSetResults.filter(x => x === ProcessResultType.Skipped).length,\r\n                };\r\n\r\n                const ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };\r\n\r\n                if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass && counts.passed > 0)\r\n                    return ProcessResultType.Passed;\r\n                if (ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass && counts.passed === ruleSetResults.length)\r\n                    return ProcessResultType.Passed;\r\n                if (counts.skipped === ruleSetResults.length) return ProcessResultType.Skipped;\r\n\r\n                return ProcessResultType.Failed;\r\n            })\r\n        );\r\n    }\r\n\r\n    private processRule<T>(data: T, rule: Rule<T>, state?: TestRunState): ProcessResultType {\r\n        if (!rule.func) return ProcessResultType.Skipped;\r\n\r\n        const rootData = state ? state.rootData : null;\r\n        return rule.func(data, rootData) ? ProcessResultType.Passed : ProcessResultType.Failed;\r\n    }\r\n\r\n    private processRuleAsync<T>(data: T, rule: Rule<T>, state?: TestRunState): Observable<ProcessResultType> {\r\n        if (!rule.func && !rule.asyncFunc) return of(ProcessResultType.Skipped);\r\n\r\n        const rootData = state ? state.rootData : null;\r\n        const funcResult = rule.func\r\n            ? of(rule.func(data, rootData))\r\n            : rule.asyncFunc(data, rootData);\r\n\r\n        return funcResult\r\n            .pipe(\r\n                map(passed => passed ? ProcessResultType.Passed : ProcessResultType.Failed)\r\n            );\r\n    }\r\n\r\n    // private doProcessRule<T>(rule: Rule<T>, state: TestRunState, isAsync: boolean): boolean {\r\n    //     // make sure we have the appropriate func to call\r\n    //     if ((isAsync && !rule.asyncFunc) || (!isAsync && !rule.func)) return false;\r\n\r\n    //     // // if there is missing data, then assume we should process the rule\r\n    //     // if (!rule.options || !rule.options.controlStateOptions || !state || !state.controlState) return true;\r\n\r\n    //     // if (rule.options.controlStateOptions.skipPristine && state.controlState.pristine) return false;\r\n    //     // if (rule.options.controlStateOptions.skipUntouched && state.controlState.untouched) return false;\r\n\r\n    //     return true;\r\n    // }\r\n\r\n    private canShortCircuitRuleGroup<T>(ruleSetResult: ProcessResultType, ruleGroup: RuleGroup<T>): boolean {\r\n        const ruleGroupOptions = ruleGroup.options || { resultRequirements: ResultsPassRequirement.AllPass };\r\n\r\n        return (\r\n            // it passed, and we only need one to pass\r\n            (ruleSetResult == ProcessResultType.Passed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AnyPass)\r\n            ||\r\n            // if failed, and we need all to pass\r\n            (ruleSetResult == ProcessResultType.Failed && ruleGroupOptions.resultRequirements == ResultsPassRequirement.AllPass)\r\n        );\r\n    }\r\n\r\n    private isRuleGroup<T>(ruleSet: RuleSet<T>): boolean {\r\n        const rule = ruleSet as Rule<T>;\r\n        return !rule.func && !rule.asyncFunc;\r\n    }\r\n\r\n    private getDependencyPropertiesFromTest<T>(test: Test<T>): string[] {\r\n        const checkDeps = this.getDependencyPropertiesFromRuleSet<T>(test.check);\r\n        const conditionDeps = this.getDependencyPropertiesFromRuleSet<T>(test.condition);\r\n        return this.commonSvc.unique(checkDeps.concat(conditionDeps));\r\n    }\r\n\r\n    private getDependencyPropertiesFromRuleSet<T>(ruleSet: RuleSet<T>): string[] {\r\n        if (!ruleSet) return [];\r\n\r\n        const result: string[] = [];\r\n\r\n        if (this.isRuleGroup(ruleSet)) {\r\n            const ruleGroup = ruleSet as RuleGroup<T>;\r\n            ruleGroup.rules.forEach(x => {\r\n                result.push(...this.commonSvc.unique(this.getDependencyPropertiesFromRuleSet(x)));\r\n            });\r\n        }\r\n\r\n        const rule = ruleSet as Rule<T>;\r\n        if (rule.options && Array.isArray(rule.options.dependencyProperties)) {\r\n            result.push(...this.commonSvc.unique(rule.options.dependencyProperties));\r\n        }\r\n\r\n        return this.commonSvc.unique(result);\r\n    }\r\n\r\n    private setPropertyMetadata(properties: PropertyBase<any>[], modelSettingsName: string, currentAbsolutePath: string = ''): void {\r\n        if (!properties) return;\r\n\r\n        properties.forEach(prop => {\r\n            const newAbsolutePath = this.setPropertyAbsolutePath(prop, currentAbsolutePath);\r\n            this.fillInEmptyTestNames(prop);\r\n            prop.setOwnerModelSettingsName(modelSettingsName);\r\n\r\n            if (prop.properties) {\r\n                this.setPropertyMetadata(prop.properties, modelSettingsName, newAbsolutePath);\r\n            } else if (prop.arrayItemProperty) {\r\n                this.setPropertyMetadata([prop.arrayItemProperty], modelSettingsName, newAbsolutePath);\r\n            }\r\n        });\r\n    }\r\n\r\n    private setPropertyAbsolutePath(property: PropertyBase<any>, currentAbsolutePath: string = ''): string {\r\n        const isArrayItemProperty = PropertyBase.isArrayItemProperty(property);\r\n        const newAbsolutePathSegment = isArrayItemProperty ? '[]' : (property as Property<any>).name;\r\n        const isAtRoot = !currentAbsolutePath;\r\n        const newAbsolutePath = `${currentAbsolutePath}${isAtRoot ? '' : '.'}${newAbsolutePathSegment}`;\r\n\r\n        // set absolute path for property\r\n        property.setAbsolutePath(newAbsolutePath);\r\n\r\n        return newAbsolutePath;\r\n    }\r\n\r\n    private fillInEmptyTestNames(property: PropertyBase<any>) {\r\n        property.valid\r\n            .filter(test => !test.name)\r\n            .forEach((test, i) => test.name = `validTest${i}`);\r\n\r\n        property.edit\r\n            .filter(test => !test.name)\r\n            .forEach((test, i) => test.name = `editTest${i}`);\r\n    }\r\n\r\n    private getConfiguredFuncTypes<T>(ruleSet: RuleSet<T>): ConfiguredFuncTypes {\r\n        if (!ruleSet) return { sync: false, async: false };\r\n\r\n        const isRuleGroup = this.isRuleGroup(ruleSet);\r\n\r\n        if (isRuleGroup) {\r\n            const ruleGroup = ruleSet as RuleGroup<T>;\r\n            const results = ruleGroup.rules\r\n                .map(rs => {\r\n                    return this.getConfiguredFuncTypes(rs);\r\n                });\r\n\r\n            return {\r\n                sync: results.findIndex(x => !!x.sync) >= 0,\r\n                async: results.findIndex(x => !!x.async) >= 0,\r\n            };\r\n        } else {\r\n            const rule = ruleSet as Rule<T>;\r\n            return {\r\n                sync: !!rule.func,\r\n                async: !!rule.asyncFunc\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\ninterface ConfiguredFuncTypes {\r\n    sync: boolean;\r\n    async: boolean;\r\n}\r\n","import { AbstractControl } from \"@angular/forms\";\r\n\r\n/**\r\n * State of an Angular AbstractControl at the time of running a test\r\n */\r\nexport class ControlState {\r\n    private readonly _pristine: boolean;\r\n    private readonly _untouched: boolean;\r\n\r\n    // get pristine(): boolean { return this._pristine; }\r\n    // get untouched(): boolean { return this._untouched; }\r\n\r\n    private constructor(control: AbstractControl) {\r\n        this._pristine = control.pristine;\r\n        this._untouched = control.untouched;\r\n    }\r\n\r\n    /**\r\n     * Creates a ControlState object based on an Angular control\r\n     * @param control Angular control to generate state from\r\n     * @returns Control state base on Angular control\r\n     */\r\n    static create(control: AbstractControl): ControlState {\r\n        return new ControlState(control);\r\n    }\r\n}","// tslint:disable:max-line-length\r\nimport { Injectable } from \"@angular/core\";\r\nimport { FormGroup, AbstractControl, ValidatorFn, FormBuilder, FormControl, FormArray, ValidationErrors, AsyncValidatorFn } from '@angular/forms';\r\nimport { RulesEngineService } from \"../rules-engine/rules-engine.service\";\r\nimport { Property } from \"../../../form-rules/models/property\";\r\nimport { ArrayItemProperty } from \"../../../form-rules/models/array-item-property\";\r\nimport { PropertyBase } from \"../../../form-rules/models/property-base\";\r\nimport { TraceService } from \"../../../utils/trace/trace.service\";\r\nimport { Observable, BehaviorSubject, of, OperatorFunction, timer, empty, EMPTY } from \"rxjs\";\r\nimport { map, tap, switchMap, take, distinctUntilChanged, debounce } from \"rxjs/operators\";\r\nimport { TestResultsBase } from \"../../../form-rules/models/test-results-base\";\r\nimport { ReactiveFormsValidationErrors } from \"../../../form-rules/models/reactive-forms-validation-errors\";\r\nimport { ReactiveFormsFailedValdation } from \"../../../form-rules/models/reactive-forms-failed-validation\";\r\nimport { ReactiveFormsValidationErrorsData } from \"../../../form-rules/models/reactive-forms-validation-errors-data\";\r\nimport { ControlState } from \"../../../form-rules/models/control-state\";\r\nimport { CommonService } from \"../../../utils/common/common.service\";\r\nimport { AbstractModelSettings } from \"../../../form-rules/models/abstract-model-settings\";\r\nimport { ValueChangeOptions } from \"../../../form-rules/models/value-change-options\";\r\nimport { AddArrayItemPropertyOptions } from \"../../../form-rules/models/add-array-item-property-options\";\r\nimport { UpdateOn } from \"../../../form-rules/models/update-on\";\r\n// tslint:enable:max-line-length\r\n\r\n/**\r\n * Builds reactive forms using configured model settings\r\n */\r\n@Injectable()\r\nexport class ReactiveFormsRuleService {\r\n    private static readonly FORM_MODEL_SETTINGS_PROPERTY_NAME = 'ngFormRulesModelSetting';\r\n    private static readonly FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME = 'ngFormRulesForceAsyncValidTestRun';\r\n    private static readonly CONTROL_LAST_ERROR = 'ngFormRulesControlLastError';\r\n\r\n    constructor(\r\n        private rulesEngineSvc: RulesEngineService,\r\n        private formBuilder: FormBuilder,\r\n        private traceSvc: TraceService,\r\n        private commonSvc: CommonService\r\n    ) {\r\n    }\r\n\r\n    /**\r\n     * Gets model settings with the provided name\r\n     * @param name Name of model setting\r\n     * @returns Model settings with the provided name\r\n     */\r\n    getModelSettings<T>(name: string): AbstractModelSettings<T> {\r\n        return this.rulesEngineSvc.getModelSettings(name);\r\n    }\r\n\r\n    /**\r\n     * Creates a form group using an instance of model settings\r\n     * @param modelSettings Name of the model setting or an instance of model settings to use\r\n     * @param initialValue Initial data to set the form values to\r\n     * @returns Form group created according to defined model settings\r\n     */\r\n    createFormGroup<T>(\r\n        modelSettings: string | AbstractModelSettings<T>,\r\n        initialValue?: any\r\n    ): FormGroup {\r\n        let settings: AbstractModelSettings<T>;\r\n\r\n        if (typeof modelSettings === \"string\") {\r\n            settings = this.rulesEngineSvc.getModelSettings(modelSettings as string);\r\n            if (!settings) throw new Error(`No model setting found with the name \"${modelSettings}\"`);\r\n        } else {\r\n            if (!modelSettings) throw new Error(`Adhoc model setting provided is invalid`);\r\n            settings = modelSettings as AbstractModelSettings<T>;\r\n            this.rulesEngineSvc.initializeModelSetting(settings);\r\n        }\r\n\r\n        this.traceSvc.trace(`Creating form group using model settings \"${settings.name}\"`);\r\n        const formGroup = this.buildGroup(settings.properties, initialValue);\r\n\r\n        this.traceSvc.trace(`Setting up dependency subscriptions`);\r\n        this.resetDependencySubscriptions(formGroup, settings.properties);\r\n\r\n        this.traceSvc.trace(`Patching form group with initial value`);\r\n        this.triggerValueChange(formGroup);\r\n\r\n        this.traceSvc.trace(`Attaching model settings to form`);\r\n        this.attachModelSettingsToForm(formGroup, settings);\r\n\r\n        return formGroup;\r\n    }\r\n\r\n    /**\r\n     * Adds an array item property to an existing form array\r\n     * @param property ArrayItemProperty to for the array item to be added\r\n     * @param parentFormArray The parent FormArray\r\n     * @param initialValue Initial value of the form array item\r\n     * @param options Options for adding new array item property\r\n     */\r\n    addArrayItemPropertyControl<T>(\r\n        property: ArrayItemProperty<T>,\r\n        parentFormArray: FormArray,\r\n        initialValue?: any,\r\n        options?: AddArrayItemPropertyOptions\r\n    ): void {\r\n        const control = this.buildAbstractControl(property, initialValue);\r\n        const willBeLastItem = !options || !this.commonSvc.isZeroOrGreater(options.index) || options.index >= parentFormArray.length;\r\n\r\n        if (willBeLastItem)\r\n            parentFormArray.push(control);\r\n        else\r\n            parentFormArray.insert(options.index, control);\r\n\r\n        const modelSettings = this.getModelSettingsFromForm(parentFormArray.root as FormGroup);\r\n        this.resetDependencySubscriptions(parentFormArray.root, modelSettings.properties);\r\n\r\n        // we need to do this because the item could have been added at any index in the array, and we need\r\n        // trigger a value change to trigger any dependency propertiy valdidations\r\n        this.triggerValueChange(parentFormArray);\r\n    }\r\n\r\n    /**\r\n     * Extends validators generated by ng-form-rules with your own validators\r\n     * @param control Control to extends the validators for\r\n     * @param validator Validator to add\r\n     */\r\n    extendValidator(control: AbstractControl, validator: ValidatorFn | ValidatorFn[]): void {\r\n        if (!validator) return;\r\n\r\n        const validatorArray = Array.isArray(validator) ? validator : [validator];\r\n        control.setValidators([control.validator, ...validatorArray]\r\n            .filter(validatorFn => !!validatorFn));\r\n    }\r\n\r\n    /**\r\n     * Extends async validators generated by ng-form-rules with your own async validators\r\n     * @param control Control to extends the async validators for\r\n     * @param asyncValidator Async validator to add\r\n     */\r\n    extendAsyncValidator(control: AbstractControl, asyncValidator: AsyncValidatorFn | AsyncValidatorFn[]): void {\r\n        if (!asyncValidator) return;\r\n\r\n        const asyncValidatorArray = Array.isArray(asyncValidator) ? asyncValidator : [asyncValidator];\r\n        control.setAsyncValidators([control.asyncValidator, ...asyncValidatorArray]\r\n            .filter(asyncValidatorFn => !!asyncValidatorFn));\r\n    }\r\n\r\n    private buildAbstractControl<T>(property: PropertyBase<T>, initialValue?: any): AbstractControl {\r\n        let control: AbstractControl;\r\n\r\n        if (property.arrayItemProperty) control = this.buildArray(property.arrayItemProperty, initialValue, property.updateOn);\r\n        else if (property.properties) control = this.buildGroup(property.properties, initialValue, property.updateOn);\r\n        else control = this.buildControl(initialValue, property.updateOn);\r\n\r\n        // setup validation tests on value change\r\n        control.setValidators(this.buildValidatorFunction(property));\r\n        control.setAsyncValidators(this.buildAsyncValidatorFunction(property));\r\n\r\n        // setup edit tests on value change\r\n        control.valueChanges\r\n            .pipe(\r\n                this.applyValueChangeOptions(property.valueChangeOptions.self.edit)\r\n            )\r\n            .subscribe(value => {\r\n                this.persistEditTests(control, property);\r\n            });\r\n\r\n        return control;\r\n    }\r\n\r\n    private buildControl<T>(initialValue: any, updateOn?: UpdateOn): FormControl {\r\n        return new FormControl(initialValue, { updateOn: updateOn });\r\n    }\r\n\r\n    private buildGroup<T>(properties: Property<T>[], initialValue: any, updateOn?: UpdateOn): FormGroup {\r\n        const formGroup = new FormGroup({}, { updateOn: updateOn });\r\n\r\n        (properties || []).forEach(p => {\r\n            const propertyValue = initialValue ? initialValue[p.name] : null;\r\n            const ctrl = this.buildAbstractControl(p, propertyValue);\r\n            formGroup.addControl(p.name, ctrl);\r\n        });\r\n\r\n        return formGroup;\r\n    }\r\n\r\n    private buildArray<T>(property: ArrayItemProperty<T>, initialValue: any[], updateOn?: UpdateOn): FormArray {\r\n        initialValue = Array.isArray(initialValue) ? initialValue : [];\r\n\r\n        return new FormArray(\r\n            initialValue.map(v => this.buildAbstractControl(property, v)),\r\n            { updateOn: updateOn }\r\n        );\r\n    }\r\n\r\n    private buildValidatorFunction<T>(property: PropertyBase<T>): ValidatorFn {\r\n        const syncGroups = this.rulesEngineSvc.groupTestsBySyncType(property.valid);\r\n        if (!syncGroups.sync.length) return null;\r\n\r\n        return (control: AbstractControl): ValidationErrors => {\r\n            const controlContextValues = this.getControlContextValues(control, property);\r\n\r\n            const testResults = this.rulesEngineSvc\r\n                .runTests(controlContextValues.relative, syncGroups.sync, {\r\n                    rootData: controlContextValues.root,\r\n                    controlState: ControlState.create(control)\r\n                });\r\n\r\n            if (testResults.results.length) {\r\n                this.traceSvc.trace(`Validated property \"${property.absolutePath}\". ` +\r\n                    this.buildTestResultStatsString(testResults));\r\n            }\r\n\r\n            return this.mapToReactiveFormsValidationErrors(testResults);\r\n        };\r\n    }\r\n\r\n    private buildAsyncValidatorFunction<T>(property: PropertyBase<T>): AsyncValidatorFn {\r\n        const rawAsyncFunc = this.buildAsyncValidatorFunctionRaw(property);\r\n\r\n        if (!rawAsyncFunc) return null;\r\n\r\n        const values = new BehaviorSubject<AbstractControl>(null);\r\n        const valid$ = values.pipe(\r\n            this.applyAsyncValidValueChangeOptions(property.valueChangeOptions.self.asyncValid),\r\n            switchMap(x => {\r\n                // pass through means we did not execute the ng-form-rules async tests\r\n                if (x.passthrough) {\r\n                    const currentErrors = x.control.errors || {};\r\n                    const lastNgFormRulesErrors = this.getLastErrorForControl(x.control);\r\n\r\n                    // return the last ng-form-rules errors (if any) alongside non ng-form-rules errors.\r\n                    // this handles scenario where debounce and distinct are used and state goes from:\r\n                    //    invalid -> make changes and back them out -> valid\r\n                    return of(Object.assign(currentErrors, { ngFormRules: lastNgFormRulesErrors } as ReactiveFormsValidationErrors));\r\n                } else {\r\n                    return rawAsyncFunc(x.control);\r\n                }\r\n            }),\r\n            take(1)\r\n        );\r\n\r\n        return (control: AbstractControl): Promise<ValidationErrors> | Observable<ValidationErrors> => {\r\n            values.next(control);\r\n            return valid$;\r\n        };\r\n    }\r\n\r\n    private buildAsyncValidatorFunctionRaw<T>(property: PropertyBase<T>): AsyncValidatorFn {\r\n        const syncGroups = this.rulesEngineSvc.groupTestsBySyncType(property.valid);\r\n        if (!syncGroups.async.length) return null;\r\n\r\n        return (control: AbstractControl) => {\r\n            const controlContextValues = this.getControlContextValues(control, property);\r\n\r\n            return this.rulesEngineSvc.runTestsAsync(controlContextValues.relative, syncGroups.async, {\r\n                rootData: controlContextValues.root,\r\n                controlState: ControlState.create(control)\r\n            }).pipe(\r\n                tap(testResults => {\r\n                    if (testResults.results.length) {\r\n                        this.traceSvc.trace(`Validated (async) property \"${property.absolutePath}\". ` +\r\n                            this.buildTestResultStatsString(testResults));\r\n                    }\r\n                }),\r\n                map(this.mapToReactiveFormsValidationErrors),\r\n                tap(x => this.setLastErrorForControl(control, (x || {}).ngFormRules))\r\n            );\r\n        };\r\n    }\r\n\r\n    private resetDependencySubscriptions<T>(\r\n        parentControl: AbstractControl,\r\n        properties: PropertyBase<T>[],\r\n    ): void {\r\n        this.removeDependencySubscriptions(properties);\r\n        this.addDependencySubscriptions(parentControl, properties);\r\n    }\r\n\r\n    private removeDependencySubscriptions<T>(\r\n        properties: PropertyBase<T>[]\r\n    ): void {\r\n        (properties || []).forEach(property => {\r\n            property.clearDependencyPropertySubscriptions();\r\n\r\n            if (property.properties) {\r\n                this.removeDependencySubscriptions(property.properties);\r\n            }\r\n\r\n            if (property.arrayItemProperty) {\r\n                this.removeDependencySubscriptions([property.arrayItemProperty]);\r\n            }\r\n        });\r\n    }\r\n\r\n    private addDependencySubscriptions<T>(\r\n        parentControl: AbstractControl,\r\n        properties: PropertyBase<T>[],\r\n        arrayIndex?: number\r\n    ): void {\r\n        (properties || []).forEach(property => {\r\n            const propertyControl = this.getPropertyFromParent(parentControl, property, arrayIndex);\r\n            if (!propertyControl) return;\r\n\r\n            this.setupEditabilityDependencySubscriptions(propertyControl, parentControl, property);\r\n            this.setupValidationDependencySubscriptions(propertyControl, parentControl, property);\r\n\r\n            if (property.properties) {\r\n                this.addDependencySubscriptions(propertyControl, property.properties);\r\n            }\r\n\r\n            if (property.arrayItemProperty) {\r\n                // if there is an arrayItemProperty we know that we are working with a FormArray control\r\n                const formArrayControl = (propertyControl as FormArray);\r\n                for (let i = 0; i < formArrayControl.length; i++) {\r\n                    this.addDependencySubscriptions(formArrayControl, [property.arrayItemProperty], i);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private setupValidationDependencySubscriptions<T>(\r\n        propertyControl: AbstractControl, parentControl: AbstractControl, property: PropertyBase<T>\r\n    ): void {\r\n        const dependencyPropNames = this.rulesEngineSvc.getDependencyProperties(property.valid);\r\n\r\n        dependencyPropNames.forEach(d => {\r\n            const dependencyControl = this.findControlRelatively(parentControl, d);\r\n\r\n            if (!dependencyControl) return;\r\n\r\n            const sub$ = dependencyControl.valueChanges\r\n                .pipe(\r\n                    this.applyValueChangeOptions(property.valueChangeOptions.dependencyProperties.valid)\r\n                )\r\n                .subscribe(value => {\r\n                    this.setForceAsyncValidationTestForControl(propertyControl, true);\r\n                    propertyControl.updateValueAndValidity({ onlySelf: true, emitEvent: false });\r\n                });\r\n\r\n            property.addDependencyPropertySubscription(sub$);\r\n        });\r\n    }\r\n\r\n    private setupEditabilityDependencySubscriptions<T>(\r\n        propertyControl: AbstractControl,\r\n        parentControl: AbstractControl,\r\n        property: PropertyBase<T>\r\n    ): void {\r\n        const dependencyPropNames = this.rulesEngineSvc.getDependencyProperties(property.edit);\r\n\r\n        dependencyPropNames.forEach(dpn => {\r\n            const dependencyControl = this.findControlRelatively(parentControl, dpn);\r\n\r\n            if (!dependencyControl) return;\r\n\r\n            // setup control to perform edit tests when dependency property changes\r\n            const sub$ = dependencyControl.valueChanges\r\n                .pipe(\r\n                    this.applyValueChangeOptions(property.valueChangeOptions.dependencyProperties.edit)\r\n                )\r\n                .subscribe(value => {\r\n                    this.persistEditTests(propertyControl, property);\r\n                });\r\n\r\n            property.addDependencyPropertySubscription(sub$);\r\n        });\r\n    }\r\n\r\n    private persistEditTests<T>(propertyControl: AbstractControl, property: PropertyBase<T>): void {\r\n        const controlContextValues = this.getControlContextValues(propertyControl, property);\r\n\r\n        this.rulesEngineSvc.editable(controlContextValues.relative, property, {\r\n            rootData: controlContextValues.root,\r\n            controlState: ControlState.create(propertyControl)\r\n        }).subscribe(testResults => {\r\n            if (testResults.results.length) {\r\n                this.traceSvc.trace(`Editable property \"${property.absolutePath}\". ` +\r\n                    this.buildTestResultStatsString(testResults));\r\n            }\r\n\r\n            if (testResults.passed && propertyControl.disabled)\r\n                propertyControl.enable({ emitEvent: false });\r\n            else if (!testResults.passed && propertyControl.enabled)\r\n                propertyControl.disable({ emitEvent: false });\r\n        });\r\n    }\r\n\r\n    private applyAsyncValidValueChangeOptions(\r\n        valueChangeOptions: ValueChangeOptions\r\n    ): OperatorFunction<AbstractControl, AsyncValidationPassthroughable> {\r\n        return (source$: Observable<AbstractControl>): Observable<AsyncValidationPassthroughable> => {\r\n            let lastValue: any;\r\n            let isForce: boolean;\r\n\r\n            return source$.pipe(\r\n                tap(control => {\r\n                    isForce = this.doesControlHaveForcedAsyncValidation(control);\r\n                    this.setForceAsyncValidationTestForControl(control, false);\r\n                }),\r\n                debounce(x => {\r\n                    return isForce || valueChangeOptions.debounceMilliseconds > 0\r\n                        ? timer(valueChangeOptions.debounceMilliseconds)\r\n                        : EMPTY;\r\n                }),\r\n                map(control => {\r\n                    return {\r\n                        control: control,\r\n                        passthrough: !(control.value !== lastValue || !valueChangeOptions.distinctUntilChanged || isForce)\r\n                    } as AsyncValidationPassthroughable;\r\n                }),\r\n                tap(x => {\r\n                    if (!x.passthrough) lastValue = x.control.value;\r\n                })\r\n            );\r\n        };\r\n    }\r\n\r\n    private applyValueChangeOptions(valueChangeOptions: ValueChangeOptions): OperatorFunction<any, any> {\r\n        return (source$: Observable<any>): Observable<any> => {\r\n            return source$.pipe(\r\n                debounce(x => {\r\n                    return valueChangeOptions.debounceMilliseconds > 0\r\n                        ? timer(valueChangeOptions.debounceMilliseconds)\r\n                        : EMPTY;\r\n                }),\r\n                valueChangeOptions.distinctUntilChanged ? distinctUntilChanged() : tap()\r\n            );\r\n        };\r\n    }\r\n\r\n    private getControlContextValues<T>(control: AbstractControl, property: Property<T> | ArrayItemProperty<T>): ControlContextValues {\r\n        const rootValue = (control.root as FormGroup).getRawValue();\r\n\r\n        // use the control value if an array item, otherwise use the parent control\r\n        const relativeValue = PropertyBase.isArrayItemProperty(property)\r\n            ? control.value\r\n            : control.parent.getRawValue();\r\n\r\n        return {\r\n            root: rootValue,\r\n            relative: relativeValue\r\n        };\r\n    }\r\n\r\n    private getPropertyFromParent<T>(\r\n        parentControl: AbstractControl,\r\n        property: PropertyBase<T>,\r\n        arrayIndex?: number\r\n    ) {\r\n        return PropertyBase.isArrayItemProperty(property)\r\n            ? (parentControl as FormArray).at(arrayIndex)\r\n            : parentControl.get((property as Property<T>).name);\r\n    }\r\n\r\n    private mapToReactiveFormsValidationErrors<T>(testResults: TestResultsBase<T>): ReactiveFormsValidationErrors {\r\n        // if passed, Angular reactive forms wants us to return null, otherwise return an object with the validation info\r\n        if (!testResults || testResults.passed) return null;\r\n\r\n        const failed: { [key: string]: ReactiveFormsFailedValdation } = {};\r\n\r\n        testResults.failedResults.forEach(test => {\r\n            failed[test.name] = { message: test.message };\r\n        });\r\n\r\n        return {\r\n            ngFormRules: {\r\n                message: testResults.message,\r\n                failed: failed\r\n            } as ReactiveFormsValidationErrorsData\r\n        };\r\n    }\r\n\r\n    private findControlRelatively(control: AbstractControl, path: string) {\r\n        const relativePaths = this.buildControlRelativePathArray(path);\r\n\r\n        if (!relativePaths.length) return null;\r\n\r\n        let result: AbstractControl;\r\n        relativePaths.forEach(pathSegment => {\r\n            result = this.getControlByPathSegment(result || control, pathSegment);\r\n            if (!result) return;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    private buildControlRelativePathArray(relativePath: string): string[] {\r\n        const result: string[] = [];\r\n\r\n        if (!relativePath || typeof relativePath !== \"string\") return result;\r\n\r\n        // takes care of './', '../', and '/'\r\n        const slashSeparated = relativePath.split(\"/\");\r\n\r\n        slashSeparated.forEach(slashItem => {\r\n            const dotSeparated = slashItem.split(\".\")\r\n                .filter(dotItem => !!dotItem);\r\n\r\n            if (dotSeparated.length)\r\n                result.push(...dotSeparated);\r\n            else\r\n                result.push(slashItem);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    private getControlByPathSegment(control: AbstractControl, pathSegment: string): AbstractControl {\r\n        switch (pathSegment) {\r\n            case \"\":\r\n                return control.root;\r\n            case \"..\":\r\n                return control.parent;\r\n            case \".\":\r\n                return control;\r\n            default:\r\n                return control.get(pathSegment);\r\n        }\r\n    }\r\n\r\n    private buildTestResultStatsString<T>(testResults: TestResultsBase<T>) {\r\n        return `Executed ${testResults.results.length} tests ` +\r\n            `(${testResults.passedResults.length} PASS | ` +\r\n            `${testResults.failedResults.length} FAIL | `\r\n            + `${testResults.skippedResults.length} SKIP)`;\r\n    }\r\n\r\n    private attachModelSettingsToForm<T>(formGroup: FormGroup, modelSettings: AbstractModelSettings<T>): void {\r\n        formGroup[ReactiveFormsRuleService.FORM_MODEL_SETTINGS_PROPERTY_NAME] = modelSettings;\r\n    }\r\n\r\n    private getModelSettingsFromForm<T>(formGroup: FormGroup): AbstractModelSettings<T> {\r\n        return formGroup[ReactiveFormsRuleService.FORM_MODEL_SETTINGS_PROPERTY_NAME] as AbstractModelSettings<T>;\r\n    }\r\n\r\n    private setForceAsyncValidationTestForControl(control: AbstractControl, force: boolean): void {\r\n        control[ReactiveFormsRuleService.FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME] = force;\r\n    }\r\n\r\n    private setLastErrorForControl(control: AbstractControl, errors: ReactiveFormsValidationErrorsData): void {\r\n        control[ReactiveFormsRuleService.CONTROL_LAST_ERROR] = errors;\r\n    }\r\n\r\n    private getLastErrorForControl(control: AbstractControl): ReactiveFormsValidationErrorsData {\r\n        return control[ReactiveFormsRuleService.CONTROL_LAST_ERROR];\r\n    }\r\n\r\n    private doesControlHaveForcedAsyncValidation(control: AbstractControl): boolean {\r\n        return !!(control[ReactiveFormsRuleService.FORCE_ASYNC_VALID_TEST_RUN_PROPERTY_NAME]);\r\n    }\r\n\r\n    private triggerValueChange(control: AbstractControl): void {\r\n        control.patchValue(control.value);\r\n    }\r\n}\r\n\r\ninterface ControlContextValues {\r\n    root: any;\r\n    relative: any;\r\n}\r\n\r\ninterface AsyncValidationPassthroughable {\r\n    control: AbstractControl;\r\n    passthrough: boolean;\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { TraceService } from './trace/trace.service';\r\nimport { CommonService } from './common/common.service';\r\n\r\n@NgModule({\r\n  imports: [],\r\n  declarations: [],\r\n  providers: [\r\n      TraceService,\r\n      CommonService\r\n  ]\r\n})\r\nexport class UtilsModule { }\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RulesEngineService } from './services/rules-engine/rules-engine.service';\r\nimport { ReactiveFormsRuleService } from './services/reactive-forms-rule/reactive-forms-rule.service';\r\nimport { ReactiveFormsModule } from '@angular/forms';\r\nimport { UtilsModule } from '../utils/utils.module';\r\n\r\n@NgModule({\r\n    imports: [\r\n        CommonModule,\r\n        UtilsModule\r\n    ],\r\n    providers: [\r\n        RulesEngineService,\r\n        ReactiveFormsRuleService\r\n    ],\r\n    declarations: []\r\n})\r\nexport class RulesEngineModule { }\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RulesEngineModule } from '../rules-engine/rules-engine.module';\r\n\r\n/**\r\n * Main module for ng-form-rules\r\n */\r\n@NgModule({\r\n  imports: [\r\n    CommonModule,\r\n    RulesEngineModule,\r\n  ],\r\n  declarations: [],\r\n  exports: [\r\n      RulesEngineModule,\r\n  ]\r\n})\r\nexport class FormRulesModule { }\r\n","import { PropertyBase } from \"./property-base\";\r\n\r\n/**\r\n * Non-array item property\r\n */\r\nexport class Property<T> extends PropertyBase<T> {\r\n    private _name: string;\r\n\r\n    /**\r\n     * Name of the property\r\n     */\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    constructor(name: string) {\r\n        super();\r\n        this._name = name;\r\n    }\r\n}","import { PropertyBase } from \"./property-base\";\r\n\r\n/**\r\n * A property representing an array item (e.g. an array of Address objects)\r\n */\r\nexport class ArrayItemProperty<T> extends PropertyBase<T> {}","import { Property } from '../models/property';\r\nimport { RuleGroup } from '../models/rule-group';\r\nimport { Rule } from '../models/rule';\r\nimport { Test } from '../models/test';\r\nimport { ArrayItemProperty } from '../models/array-item-property';\r\nimport { RuleSet } from '../models/rule-set';\r\nimport { RuleFunc } from '../models/rule-func';\r\nimport { RuleOptions } from '../models/rule-options';\r\nimport { AsyncRuleFunc } from '../models/async-rule-func';\r\nimport { RuleGroupOptions } from '../models/rule-group-options';\r\nimport { ResultsPassRequirement } from '../models/results-pass-requirement';\r\n\r\n/**\r\n * Utility class for building model settings\r\n */\r\nexport class ModelSettingsBuilder {\r\n    /**\r\n     * Creates a property\r\n     * @param propertyName Property name\r\n     * @param extend Function to extend the property\r\n     * @returns Created property\r\n     */\r\n    property<T>(propertyName: keyof T, extend?: (prop: Property<T>) => void): Property<T> {\r\n        if (!propertyName || typeof propertyName !== 'string') throw Error('Invalid property name');\r\n\r\n        const property = new Property<T>(propertyName);\r\n\r\n        if (extend) extend(property);\r\n\r\n        return property;\r\n    }\r\n\r\n    /**\r\n     * Creates an array item property\r\n     * @param extend Function to extend the array item property\r\n     * @returns Created array item property\r\n     */\r\n    arrayItemProperty<T>(extend?: (prop: ArrayItemProperty<T>) => void): ArrayItemProperty<T> {\r\n        const property = new ArrayItemProperty<T>();\r\n\r\n        if (extend) extend(property);\r\n\r\n        return property;\r\n    }\r\n\r\n    /**\r\n     * Creates a validation test\r\n     * @param message Message when the test fails\r\n     * @param check Check rule set for the test\r\n     * @param condition Condition rule set for the test\r\n     * @returns Created validation test\r\n     */\r\n    validTest<T>(message: string, check: RuleSet<T>, condition?: RuleSet<T>): Test<T> {\r\n        return this.validNamedTest(null, message, check, condition);\r\n    }\r\n\r\n    /**\r\n     * Creates a named validation test\r\n     * @param name Name of the test\r\n     * @param message Message when the test fails\r\n     * @param check Check rule set for the test\r\n     * @param condition Condition rule set for the test\r\n     * @returns Created named validation test\r\n     */\r\n    validNamedTest<T>(name: string, message: string, check: RuleSet<T>, condition?: RuleSet<T>): Test<T> {\r\n        return {\r\n            name: name,\r\n            message: message,\r\n            check: check,\r\n            condition: condition\r\n        } as Test<T>;\r\n    }\r\n\r\n    /**\r\n     * Creates an edit test\r\n     * @param check Check rule set for the test\r\n     * @param condition Condition rule set for the test\r\n     * @returns Created edit test\r\n     */\r\n    editTest<T>(check: RuleSet<T>, condition?: RuleSet<T>): Test<T> {\r\n        return this.editNamedTest(null, check, condition);\r\n    }\r\n\r\n    /**\r\n     * Creates a named edit test\r\n     * @param name Name of the test\r\n     * @param check Check rule set for the test\r\n     * @param condition Condition rule set for the test\r\n     * @returns Created named edit test\r\n     */\r\n    editNamedTest<T>(name: string, check: RuleSet<T>, condition?: RuleSet<T>): Test<T> {\r\n        return {\r\n            name: name,\r\n            check: check,\r\n            condition: condition\r\n        } as Test<T>;\r\n    }\r\n\r\n    /**\r\n     * Creates a rule\r\n     * @param func Function for the rule\r\n     * @param options Additional rule options\r\n     * @returns Created rule\r\n     */\r\n    rule<T, R>(func: RuleFunc<T, R>, options?: RuleOptions): Rule<T> {\r\n        return this.ruleCombo(func, null, options);\r\n    }\r\n\r\n    /**\r\n     * Creates an async rule\r\n     * @param asyncFunc Async function for the rule\r\n     * @param options Additional rule options\r\n     * @returns Created rule\r\n     */\r\n    ruleAsync<T, R>(asyncFunc: AsyncRuleFunc<T, R>, options?: RuleOptions): Rule<T> {\r\n        return this.ruleCombo(null, asyncFunc, options);\r\n    }\r\n\r\n    /**\r\n     * Creates a combo rule that has both syncronous and async functions\r\n     * @param func Function for the rule\r\n     * @param asyncFunc Async function for the rule\r\n     * @param options Additional rule options\r\n     * @returns Created rule\r\n     */\r\n    ruleCombo<T, R>(func: RuleFunc<T, R>, asyncFunc: AsyncRuleFunc<T, R>, options?: RuleOptions): Rule<T> {\r\n        return {\r\n            func: func,\r\n            asyncFunc: asyncFunc,\r\n            options: options\r\n        } as Rule<T>;\r\n    }\r\n\r\n    /**\r\n     * Creates a rule group\r\n     * @param ruleSets Rule sets for the rule group\r\n     * @param options Additional rule group options\r\n     * @returns Created rule group\r\n     */\r\n    ruleGroup<T>(ruleSets: RuleSet<T>[], options?: RuleGroupOptions): RuleGroup<T> {\r\n        return {\r\n            rules: ruleSets,\r\n            options: options || { resultRequirements: ResultsPassRequirement.AllPass }\r\n        } as RuleGroup<T>;\r\n    }\r\n}","import { ModelSettingsBuilder } from \"../helper/model-settings-builder\";\r\nimport { Property } from \"./property\";\r\n\r\n/**\r\n * Base class for model settings\r\n */\r\nexport abstract class AbstractModelSettings<T> {\r\n    private _name: string;\r\n\r\n    /**\r\n     * Name of the model setting\r\n     */\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Helper for building properties, tests, and rules\r\n     */\r\n    protected builder: ModelSettingsBuilder;\r\n\r\n    /**\r\n     * Properties configured for the model settings\r\n     */\r\n    properties: Property<T>[];\r\n\r\n    /**\r\n     * Creates model settings\r\n     * @param name Name of the model settings\r\n     */\r\n    constructor(name: string) {\r\n        this.builder = new ModelSettingsBuilder();\r\n        this._name = name;\r\n        this.properties = this.buildProperties() || [];\r\n    }\r\n\r\n    /**\r\n     * Abstract function for building the properties\r\n     */\r\n    protected abstract buildProperties(): Property<T>[];\r\n}","import { TestResultsBase } from \"./test-results-base\";\r\nimport { TestResult } from \"./test-result\";\r\n\r\nexport class PropertyTestResults<T> extends TestResultsBase<T> {\r\n    constructor(public propertyName: string, results: TestResult<T>[]) {\r\n        super(results);\r\n    }\r\n}","import { AbstractModelSettings } from \"./abstract-model-settings\";\r\nimport { ModelSettingsBuilder } from \"../helper/model-settings-builder\";\r\nimport { Property } from \"./property\";\r\n\r\n/**\r\n * Class for creating adhoc (non-registered) model settings\r\n */\r\nexport class AdhocModelSettings<T> extends AbstractModelSettings<T> {\r\n    /**\r\n     * Creates model settings\r\n     * @param propertyBuilderFunc Function that takes a ModelSettingsBuilder and uses it to return an array of properties\r\n     * @returns Model settings configured with properties returned from the 'propertyBuilderFunc' function parameter\r\n     */\r\n    static create<T>(propertyBuilderFunc: (builder: ModelSettingsBuilder) => Property<T>[]): AbstractModelSettings<T> {\r\n        const instance = new AdhocModelSettings();\r\n        instance.properties = !!propertyBuilderFunc ? propertyBuilderFunc(instance.builder) || [] : [];\r\n\r\n        return instance;\r\n    }\r\n\r\n    private constructor() {\r\n        // since these settings are not registered, just use a static name\r\n        super('adhoc');\r\n    }\r\n\r\n    protected buildProperties(): Property<T>[] {\r\n        // this is just needed to satisfy the AbstractModelSettings<T> contract\r\n        return [];\r\n    }\r\n}","/**\r\n * Options for how and when to process value changes in a form control\r\n */\r\nexport class ValueChangeOptions {\r\n    /**\r\n     * Consider value changed only if it is different\r\n     */\r\n    distinctUntilChanged?: boolean;\r\n\r\n    /**\r\n     * Milliseconds to debounce value changes\r\n     */\r\n    debounceMilliseconds?: number;\r\n}"]}