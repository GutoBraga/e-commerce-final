import { AbstractModelSettings } from '../../../form-rules/models/abstract-model-settings';
import { Property } from '../../../form-rules/models/property';
import { Test } from '../../../form-rules/models/test';
import { TestResult } from '../../../form-rules/models/test-result';
import { RuleSet } from '../../../form-rules/models/rule-set';
import { TestRunState } from '../../../form-rules/models/test-run-state';
import { TraceService } from '../../../utils/trace/trace.service';
import { CommonService } from '../../../utils/common/common.service';
import { Observable } from 'rxjs';
import { TestResultsBase } from '../../../form-rules/models/test-results-base';
import { PropertyTestResults } from '../../../form-rules/models/property-test-result';
import { PropertyBase } from '../../../form-rules/models/property-base';
import { ProcessResultType } from '../../../form-rules/models/proccess-result-type';
import { TestSyncGroups } from '../../../form-rules/models/test-sync-groups';
/**
 * Engine that digests model settings and applies their rules appropriately
 */
import * as ɵngcc0 from '@angular/core';
export declare class RulesEngineService {
    private traceSvc;
    private commonSvc;
    private registeredSettings;
    constructor(settings: AbstractModelSettings<any>[], traceSvc: TraceService, commonSvc: CommonService);
    /**
     * Initializes model settings and prepares them to be used in a form group
     * @param setting Model setting to initialize
     */
    initializeModelSetting(setting: AbstractModelSettings<any>): void;
    /**
     * Gets model settings with the provided name
     * @param name Name of model setting
     * @returns Model settings with the provided name
     */
    getModelSettings<T>(name: string): AbstractModelSettings<T>;
    /**
     * Gets the dependency properties for an array of tests
     * @param tests Tests to get the dependency properties for
     * @returns Dependency properties
     */
    getDependencyProperties<T>(tests: Test<T>[]): string[];
    /**
     * Gets tests grouped by their sync type (e.g. sync vs. async)
     * @param tests Test to groups
     * @returns Tests grouped by sync type
     */
    groupTestsBySyncType<T>(tests: Test<T>[]): TestSyncGroups<T>;
    /**
     * Runs validation tests
     * @param data Data to run validation tests against
     * @param property Property to run validation tests for
     * @returns Results of validation tests
     */
    validate<T>(data: T, property: Property<T>, state?: TestRunState): Observable<PropertyTestResults<T>>;
    /**
     * Runs editability tests
     * @param data Data to run editability tests against
     * @param property Property to run editability tests for
     * * @returns Results of editability tests
     */
    editable<T>(data: T, property: PropertyBase<T>, state?: TestRunState): Observable<PropertyTestResults<T>>;
    /**
     * Runs visibility tests
     * @param data Data to run visibility tests against
     * @param property Property to run visibility tests for
     * * @returns Results of visibility tests
     */
    /**
     * Runs an array of sync tests
     * @param data Data to perform tests against
     * @param tests Tests to run
     * @returns Result of tests
     */
    runTests<T>(data: T, tests: Test<T>[], state?: TestRunState): TestResultsBase<T>;
    /**
     * Runs an array of async tests
     * @param data Data to perform tests against
     * @param tests Tests to run
     * @returns Result of tests
     */
    runTestsAsync<T>(data: T, tests: Test<T>[], state?: TestRunState): Observable<TestResultsBase<T>>;
    /**
     * Runs an array of sync and async tests
     * @param data Data to perform tests against
     * @param tests Tests to run
     * @returns Result of tests
     */
    runAllTests<T>(data: T, tests: Test<T>[], state?: TestRunState): Observable<TestResultsBase<T>>;
    /**
     * Performs sync test on a set of data
     * @param data Data to perform test against
     * @param test Test to run
     * @returns Result of test
     */
    runTest<T>(data: T, test: Test<T>, state?: TestRunState): TestResult<T>;
    /**
     * Performs async test on a set of data
     * @param data Data to perform test against
     * @param test Test to run
     * @returns Result of test
     */
    runTestAsync<T>(data: T, test: Test<T>, state?: TestRunState): Observable<TestResult<T>>;
    /**
     * Processes a sync rule set
     * @param data Data to process rule set against
     * @param ruleSet Rule set to process
     * @returns Result of rule set processing
     */
    processRuleSet<T>(data: T, ruleSet: RuleSet<T>, state?: TestRunState): ProcessResultType;
    /**
     * Processes an async rule set
     * @param data Data to process rule set against
     * @param ruleSet Rule set to process
     * @returns Result of rule set processing
     */
    processRuleSetAsync<T>(data: T, ruleSet: RuleSet<T>, state?: TestRunState): Observable<ProcessResultType>;
    private processRuleGroup<T>(data, ruleGroup, state?);
    private processRuleGroupAsync<T>(data, ruleGroup, state?);
    private processRule<T>(data, rule, state?);
    private processRuleAsync<T>(data, rule, state?);
    private canShortCircuitRuleGroup<T>(ruleSetResult, ruleGroup);
    private isRuleGroup<T>(ruleSet);
    private getDependencyPropertiesFromTest<T>(test);
    private getDependencyPropertiesFromRuleSet<T>(ruleSet);
    private setPropertyMetadata(properties, modelSettingsName, currentAbsolutePath?);
    private setPropertyAbsolutePath(property, currentAbsolutePath?);
    private fillInEmptyTestNames(property);
    private getConfiguredFuncTypes<T>(ruleSet);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<RulesEngineService, [{ optional: true; }, null, null]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<RulesEngineService>;
}

//# sourceMappingURL=rules-engine.service.d.ts.map